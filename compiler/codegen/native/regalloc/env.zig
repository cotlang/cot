//! Machine environment for the register allocator.
//!
//! Ported from regalloc2's `src/lib.rs` MachineEnv struct.
//!
//! This module defines the ISA-specific register information that the
//! register allocator needs to make allocation decisions.

const std = @import("std");
const index = @import("index.zig");

const PReg = index.PReg;
const PRegSet = index.PRegSet;
const RegClass = index.RegClass;

//=============================================================================
// MachineEnv - ISA register information
//=============================================================================

/// A machine environment tells the register allocator which registers
/// are available to allocate and what registers may be used as scratch
/// registers for each class.
pub const MachineEnv = struct {
    /// Preferred physical registers for each class.
    /// These are the registers that will be allocated first, if free.
    ///
    /// If an explicit scratch register is provided in `scratch_by_class`,
    /// then it must NOT appear in this list.
    preferred_regs_by_class: [3]PRegSet,

    /// Non-preferred physical registers for each class.
    /// These are the registers that will be allocated if a preferred
    /// register is not available; using one of these is considered
    /// suboptimal, but still better than spilling.
    ///
    /// If an explicit scratch register is provided in `scratch_by_class`,
    /// then it must NOT appear in this list.
    non_preferred_regs_by_class: [3]PRegSet,

    /// Optional dedicated scratch register per class.
    /// This is needed to perform moves between registers when cyclic
    /// move patterns occur.
    ///
    /// The register should NOT be placed in either the preferred or
    /// non-preferred list (i.e., it is not otherwise allocatable).
    ///
    /// The register allocator will freely use this register *between*
    /// instructions, but *within* the machine code generated by a single
    /// regalloc-level instruction, the client is free to use it.
    ///
    /// If a scratch register is not provided, the register allocator
    /// will automatically allocate one as needed, spilling a value to
    /// the stack if necessary.
    scratch_by_class: [3]?PReg,

    /// Some PRegs can be designated as locations on the stack rather
    /// than actual registers. These can be used to tell the register
    /// allocator about pre-defined stack slots used for function
    /// arguments and return values.
    ///
    /// PRegs in this list cannot be used as an allocatable or scratch
    /// register.
    fixed_stack_slots: []const PReg,

    /// Create an empty MachineEnv with no allocatable registers.
    pub fn empty() MachineEnv {
        return .{
            .preferred_regs_by_class = [_]PRegSet{PRegSet.empty()} ** 3,
            .non_preferred_regs_by_class = [_]PRegSet{PRegSet.empty()} ** 3,
            .scratch_by_class = [_]?PReg{null} ** 3,
            .fixed_stack_slots = &.{},
        };
    }

    /// Get all allocatable registers (preferred + non-preferred) for a class.
    pub fn allocatableRegs(self: MachineEnv, class: RegClass) PRegSet {
        const idx = @intFromEnum(class);
        return self.preferred_regs_by_class[idx].unionWith(self.non_preferred_regs_by_class[idx]);
    }

    /// Get the total number of allocatable registers.
    pub fn totalAllocatableCount(self: MachineEnv) u32 {
        var count: u32 = 0;
        for (0..3) |i| {
            count += self.preferred_regs_by_class[i].count();
            count += self.non_preferred_regs_by_class[i].count();
        }
        return count;
    }

    /// Check if a register is allocatable (in preferred or non-preferred).
    pub fn isAllocatable(self: MachineEnv, preg: PReg) bool {
        const idx = @intFromEnum(preg.class());
        return self.preferred_regs_by_class[idx].contains(preg) or
            self.non_preferred_regs_by_class[idx].contains(preg);
    }

    /// Check if a register is the dedicated scratch register.
    pub fn isScratch(self: MachineEnv, preg: PReg) bool {
        const idx = @intFromEnum(preg.class());
        if (self.scratch_by_class[idx]) |scratch| {
            return scratch.eql(preg);
        }
        return false;
    }
};

//=============================================================================
// ARM64 MachineEnv
//=============================================================================

/// The pinned register for vmctx on ARM64 (x21).
/// Port of Cranelift's PINNED_REG from cranelift/codegen/src/isa/aarch64/inst/regs.rs
const PINNED_REG_ARM64: usize = 21;

/// The pinned register for vmctx on x64 (r15).
/// Port of Cranelift's PINNED_REG from cranelift/codegen/src/isa/x64/inst/regs.rs
const PINNED_REG_X64: usize = 15;

/// Create a MachineEnv for ARM64 (AArch64).
///
/// Integer registers: x0-x28 (x29=FP, x30=LR, x31=SP/ZR are special)
/// Float registers: v0-v31
/// x21 is reserved as the pinned register for vmctx (excluded from allocation)
pub fn arm64MachineEnv() MachineEnv {
    var env = MachineEnv.empty();

    // Integer registers: x0-x17 are caller-saved (preferred)
    // x18 is platform register (avoided on many OSes)
    // x19-x28 are callee-saved (non-preferred), EXCEPT x21 which is pinned
    // x29 = FP, x30 = LR, x31 = SP/ZR (not allocatable)
    for (0..18) |i| {
        env.preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(i, .int));
    }
    // Add x19-x28 but skip x21 (pinned register)
    // Port of Cranelift's create_reg_env(enable_pinned_reg: true) from abi.rs
    for (19..29) |i| {
        if (i != PINNED_REG_ARM64) {
            env.non_preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(i, .int));
        }
    }

    // Float/SIMD registers: v0-v7 are caller-saved (preferred)
    // v8-v15 lower 64 bits are callee-saved (non-preferred)
    // v16-v31 are caller-saved (preferred)
    for (0..8) |i| {
        env.preferred_regs_by_class[@intFromEnum(RegClass.float)].add(PReg.new(i, .float));
    }
    for (8..16) |i| {
        env.non_preferred_regs_by_class[@intFromEnum(RegClass.float)].add(PReg.new(i, .float));
    }
    for (16..32) |i| {
        env.preferred_regs_by_class[@intFromEnum(RegClass.float)].add(PReg.new(i, .float));
    }

    // Use x16 as scratch (IP0 - intra-procedure-call scratch register)
    // Remove from preferred set
    env.preferred_regs_by_class[@intFromEnum(RegClass.int)].remove(PReg.new(16, .int));
    env.scratch_by_class[@intFromEnum(RegClass.int)] = PReg.new(16, .int);

    return env;
}

//=============================================================================
// x64 MachineEnv
//=============================================================================

/// Create a MachineEnv for x86-64.
///
/// Integer registers: rax(0), rcx(1), rdx(2), rbx(3), rsp(4), rbp(5), rsi(6), rdi(7), r8-r15
/// Float registers: xmm0-xmm15
pub fn x64MachineEnv() MachineEnv {
    var env = MachineEnv.empty();

    // x64 register encoding:
    // 0=rax, 1=rcx, 2=rdx, 3=rbx, 4=rsp, 5=rbp, 6=rsi, 7=rdi, 8-15=r8-r15

    // Caller-saved (preferred): rax, rcx, rdx, rsi, rdi, r8-r11
    env.preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(0, .int)); // rax
    env.preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(1, .int)); // rcx
    env.preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(2, .int)); // rdx
    env.preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(6, .int)); // rsi
    env.preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(7, .int)); // rdi
    for (8..12) |i| {
        env.preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(i, .int));
    }

    // Callee-saved (non-preferred): rbx, r12-r14
    // rbp (5) and rsp (4) are not allocatable
    // r15 is excluded (pinned register for vmctx)
    // Port of Cranelift's create_reg_env(enable_pinned_reg: true) from abi.rs
    env.non_preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(3, .int)); // rbx
    for (12..16) |i| {
        if (i != PINNED_REG_X64) {
            env.non_preferred_regs_by_class[@intFromEnum(RegClass.int)].add(PReg.new(i, .int));
        }
    }

    // Float/SSE: xmm0-xmm5 caller-saved (preferred), xmm6-xmm15 callee-saved on Windows
    // On System V ABI (Linux, macOS), all xmm0-xmm15 are caller-saved
    // We'll use System V conventions
    for (0..16) |i| {
        env.preferred_regs_by_class[@intFromEnum(RegClass.float)].add(PReg.new(i, .float));
    }

    // Use r11 as scratch register
    env.preferred_regs_by_class[@intFromEnum(RegClass.int)].remove(PReg.new(11, .int));
    env.scratch_by_class[@intFromEnum(RegClass.int)] = PReg.new(11, .int);

    return env;
}

//=============================================================================
// Tests
//=============================================================================

test "MachineEnv empty" {
    const env = MachineEnv.empty();
    try std.testing.expectEqual(@as(u32, 0), env.totalAllocatableCount());

    for (0..3) |i| {
        try std.testing.expect(env.scratch_by_class[i] == null);
    }
}

test "ARM64 MachineEnv" {
    const env = arm64MachineEnv();

    // Check we have integer registers
    const int_class = @intFromEnum(RegClass.int);
    const int_regs = env.allocatableRegs(.int);
    try std.testing.expect(int_regs.count() > 0);

    // x0 should be allocatable (preferred)
    try std.testing.expect(env.preferred_regs_by_class[int_class].contains(PReg.new(0, .int)));

    // x19 should be non-preferred (callee-saved)
    try std.testing.expect(env.non_preferred_regs_by_class[int_class].contains(PReg.new(19, .int)));

    // x16 should be scratch
    try std.testing.expect(env.scratch_by_class[int_class] != null);
    try std.testing.expect(env.scratch_by_class[int_class].?.eql(PReg.new(16, .int)));
    try std.testing.expect(!env.isAllocatable(PReg.new(16, .int)));
    try std.testing.expect(env.isScratch(PReg.new(16, .int)));

    // Float registers
    const float_regs = env.allocatableRegs(.float);
    try std.testing.expect(float_regs.count() == 32);
}

test "x64 MachineEnv" {
    const env = x64MachineEnv();

    // Check we have integer registers
    const int_class = @intFromEnum(RegClass.int);
    const int_regs = env.allocatableRegs(.int);
    try std.testing.expect(int_regs.count() > 0);

    // rax should be preferred
    try std.testing.expect(env.preferred_regs_by_class[int_class].contains(PReg.new(0, .int)));

    // rbx should be non-preferred (callee-saved)
    try std.testing.expect(env.non_preferred_regs_by_class[int_class].contains(PReg.new(3, .int)));

    // rsp and rbp should NOT be allocatable
    try std.testing.expect(!env.isAllocatable(PReg.new(4, .int))); // rsp
    try std.testing.expect(!env.isAllocatable(PReg.new(5, .int))); // rbp

    // r11 should be scratch
    try std.testing.expect(env.scratch_by_class[int_class] != null);
    try std.testing.expect(env.scratch_by_class[int_class].?.eql(PReg.new(11, .int)));
    try std.testing.expect(!env.isAllocatable(PReg.new(11, .int)));

    // Float registers
    const float_regs = env.allocatableRegs(.float);
    try std.testing.expect(float_regs.count() == 16);
}

test "MachineEnv isAllocatable and isScratch" {
    const env = arm64MachineEnv();

    // x0 is allocatable but not scratch
    try std.testing.expect(env.isAllocatable(PReg.new(0, .int)));
    try std.testing.expect(!env.isScratch(PReg.new(0, .int)));

    // x16 is scratch, not allocatable
    try std.testing.expect(!env.isAllocatable(PReg.new(16, .int)));
    try std.testing.expect(env.isScratch(PReg.new(16, .int)));

    // x29 (FP) is neither
    try std.testing.expect(!env.isAllocatable(PReg.new(29, .int)));
    try std.testing.expect(!env.isScratch(PReg.new(29, .int)));
}
