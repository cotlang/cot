@safe

struct SafePoint { x: i64, y: i64 }

impl SafePoint {
    fn getX(self: SafePoint) i64 { return self.x }
    fn sum(self: SafePoint) i64 { return self.x + self.y }
    fn setX(self: SafePoint, val: i64) void { self.x = val }
}

fn createPoint(x: i64, y: i64) *SafePoint {
    return new SafePoint { x: x, y: y }
}

fn acceptPoint(p: SafePoint) i64 {
    return p.x + p.y
}

test "safe self param" {
    var p = new SafePoint { x: 10, y: 20 }
    @assertEq(p.getX(), 10)
    @assertEq(p.sum(), 30)
}

test "safe return type" {
    var p = createPoint(3, 4)
    @assertEq(p.x, 3)
    @assertEq(p.y, 4)
}

test "safe function param" {
    var p = new SafePoint { x: 5, y: 6 }
    @assertEq(acceptPoint(p), 11)
}

test "safe var annotation coercion" {
    var p: SafePoint = new SafePoint { x: 5, y: 6 }
    @assertEq(p.x, 5)
}

test "safe explicit pointer still works" {
    var p: *SafePoint = new SafePoint { x: 7, y: 8 }
    @assertEq(p.x, 7)
}

test "safe stack value unchanged" {
    var p = SafePoint { .x = 1, .y = 2 }
    @assertEq(p.x + p.y, 3)
}

test "safe mutation via method" {
    var p = new SafePoint { x: 10, y: 20 }
    p.setX(99)
    @assertEq(p.getX(), 99)
}

test "safe scalars unchanged" {
    var x: i64 = 42
    var s: string = "hello"
    var b: bool = true
    @assertEq(x, 42)
    @assertEq(s, "hello")
    @assertEq(b, true)
}

// --- Feature 1: Field init shorthand ---

test "field init shorthand in new expr" {
    var x: i64 = 10
    var y: i64 = 20
    var p = new SafePoint { x, y }
    @assertEq(p.x, 10)
    @assertEq(p.y, 20)
}

test "field init shorthand mixed" {
    var x: i64 = 5
    var p = new SafePoint { x, y: 99 }
    @assertEq(p.x, 5)
    @assertEq(p.y, 99)
}

// --- Feature 2: Unified init syntax (colon syntax for stack struct init) ---

test "colon syntax stack struct init" {
    var p = SafePoint { x: 1, y: 2 }
    @assertEq(p.x + p.y, 3)
}

test "colon syntax stack struct shorthand" {
    var x: i64 = 7
    var y: i64 = 8
    var p = SafePoint { x, y }
    @assertEq(p.x, 7)
    @assertEq(p.y, 8)
}

test "colon syntax mixed shorthand and explicit" {
    var x: i64 = 3
    var p = SafePoint { x, y: 42 }
    @assertEq(p.x, 3)
    @assertEq(p.y, 42)
}

test "period syntax still works" {
    var p = SafePoint { .x = 100, .y = 200 }
    @assertEq(p.x + p.y, 300)
}

// --- Feature 3: Implicit self in @safe mode ---

struct ImplicitSelfPoint { x: i64, y: i64 }

impl ImplicitSelfPoint {
    fn getX() i64 { return self.x }
    fn getY() i64 { return self.y }
    fn sum() i64 { return self.x + self.y }
    fn setX(val: i64) void { self.x = val }
}

test "implicit self getter" {
    var p = new ImplicitSelfPoint { x: 42, y: 58 }
    @assertEq(p.getX(), 42)
    @assertEq(p.getY(), 58)
}

test "implicit self computed method" {
    var p = new ImplicitSelfPoint { x: 10, y: 20 }
    @assertEq(p.sum(), 30)
}

test "implicit self mutation" {
    var p = new ImplicitSelfPoint { x: 1, y: 2 }
    p.setX(99)
    @assertEq(p.getX(), 99)
}

test "explicit self still works in safe mode" {
    var p = new SafePoint { x: 5, y: 6 }
    @assertEq(p.getX(), 5)
}

// --- Feature 4: Constructor sugar ---

struct Rect { width: i64, height: i64 }

impl Rect {
    fn init(self: *Rect, w: i64, h: i64) void {
        self.width = w
        self.height = h
    }

    fn area(self: *Rect) i64 {
        return self.width * self.height
    }
}

test "constructor sugar basic" {
    var r = new Rect(10, 20)
    @assertEq(r.width, 10)
    @assertEq(r.height, 20)
}

test "constructor sugar with method call" {
    var r = new Rect(5, 8)
    @assertEq(r.area(), 40)
}

test "constructor sugar zero args" {
    var p = new SafePoint { x: 0, y: 0 }
    @assertEq(p.x, 0)
}

// Constructor with implicit self
struct Circle { radius: i64 }

impl Circle {
    fn init(r: i64) void {
        self.radius = r
    }

    fn diameter() i64 {
        return self.radius * 2
    }
}

test "constructor sugar with implicit self" {
    var c = new Circle(7)
    @assertEq(c.radius, 7)
    @assertEq(c.diameter(), 14)
}

// --- Feature 5: Auto-ref (pass structs to pointer params without &) ---
// In @safe mode, structs are passed by reference automatically.
// No & needed — just like TypeScript/C# where objects are always references.

struct Counter { value: i64 }

fn incrementCounter(c: *Counter) void {
    c.value = c.value + 1
}

fn getCounterValue(c: *Counter) i64 {
    return c.value
}

impl Counter {
    fn reset() void { self.value = 0 }
    fn inc() void { self.value = self.value + 1 }
    fn get() i64 { return self.value }
}

test "auto-ref: pass local to pointer param" {
    var c = Counter { value: 0 }
    incrementCounter(c)
    @assertEq(c.value, 1)
}

test "auto-ref: mutations visible to caller" {
    var c = Counter { value: 10 }
    incrementCounter(c)
    incrementCounter(c)
    incrementCounter(c)
    @assertEq(c.value, 13)
}

test "auto-ref: read through pointer param" {
    var c = Counter { value: 42 }
    @assertEq(getCounterValue(c), 42)
}

test "auto-ref: multiple functions same variable" {
    var c = Counter { value: 0 }
    incrementCounter(c)
    @assertEq(getCounterValue(c), 1)
    incrementCounter(c)
    @assertEq(getCounterValue(c), 2)
}

struct Scanner { pos: i64, line: i64 }
struct Ast { count: i64 }
struct Errors { count: i64 }

fn scannerInit() Scanner {
    return Scanner { pos: 0, line: 1 }
}

struct Parser {
    scanner: *Scanner,
    ast: *Ast,
    errors: *Errors,
    tok: i64,
}

fn parserInit(scanner: *Scanner, ast: *Ast, errors: *Errors) Parser {
    return Parser { scanner: scanner, ast: ast, errors: errors, tok: 0 }
}

impl Parser {
    fn advance() void {
        self.scanner.pos = self.scanner.pos + 1
        self.tok = self.scanner.pos
    }

    fn addNode() void {
        self.ast.count = self.ast.count + 1
    }
}

test "auto-ref: parser pattern — no & needed" {
    var s = scannerInit()
    var ast = Ast { count: 0 }
    var errors = Errors { count: 0 }
    var p = parserInit(s, ast, errors)
    p.advance()
    p.advance()
    p.addNode()
    @assertEq(s.pos, 2)
    @assertEq(ast.count, 1)
    @assertEq(p.tok, 2)
}

test "auto-ref: field access mutation propagates" {
    var s = scannerInit()
    var ast = Ast { count: 0 }
    var errors = Errors { count: 0 }
    var p = parserInit(s, ast, errors)
    p.scanner.pos = 100
    @assertEq(s.pos, 100)
}

test "auto-ref: explicit & still works" {
    var c = Counter { value: 0 }
    incrementCounter(&c)
    @assertEq(c.value, 1)
}
