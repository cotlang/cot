// Threading E2E tests â€” Phases 1-5
import "std/thread"
import "std/channel"
import "std/sys"

// ============================================================================
// Phase 1: Thread creation & joining
// ============================================================================

var worker_ran: i64 = 0

fn simple_worker(arg: i64) void {
    worker_ran = 1
}

test "spawn and join" {
    worker_ran = 0
    var t = Thread.spawn(@ptrToInt(simple_worker), 0)
    t.join()
    @assertEq(worker_ran, 1)
}

var arg_received: i64 = 0

fn arg_worker(arg: i64) void {
    arg_received = arg
}

test "thread receives argument" {
    arg_received = 0
    var t = Thread.spawn(@ptrToInt(arg_worker), 42)
    t.join()
    @assertEq(arg_received, 42)
}

// ============================================================================
// Phase 2: Mutex
// ============================================================================

var counter: i64 = 0
var mtx: Mutex = undefined

fn increment_worker(arg: i64) void {
    var i: i64 = 0
    while (i < 1000) {
        mtx.lock()
        counter = counter + 1
        mtx.unlock()
        i = i + 1
    }
}

test "mutex protects shared counter" {
    mtx = Mutex.init()
    counter = 0
    var t1 = Thread.spawn(@ptrToInt(increment_worker), 0)
    var t2 = Thread.spawn(@ptrToInt(increment_worker), 0)
    t1.join()
    t2.join()
    @assertEq(counter, 2000)
    mtx.destroy()
}

test "mutex tryLock" {
    var m = Mutex.init()
    @assert(m.tryLock())
    m.unlock()
    m.destroy()
}

// ============================================================================
// Phase 3: Condition Variables
// ============================================================================

var cond_value: i64 = 0
var cond_mtx: Mutex = undefined
var cond_var: Condition = undefined

fn cond_producer(arg: i64) void {
    cond_mtx.lock()
    cond_value = 42
    cond_var.signal()
    cond_mtx.unlock()
}

fn cond_consumer(arg: i64) void {
    cond_mtx.lock()
    while (cond_value == 0) {
        cond_var.wait(&cond_mtx)
    }
    cond_mtx.unlock()
}

test "condition variable signal" {
    cond_mtx = Mutex.init()
    cond_var = Condition.init()
    cond_value = 0
    var c = Thread.spawn(@ptrToInt(cond_consumer), 0)
    var p = Thread.spawn(@ptrToInt(cond_producer), 0)
    p.join()
    c.join()
    @assertEq(cond_value, 42)
    cond_mtx.destroy()
    cond_var.destroy()
}

// ============================================================================
// Phase 4: Atomic Operations
// ============================================================================

var atomic_counter: i64 = 0

fn atomic_increment_worker(arg: i64) void {
    var i: i64 = 0
    while (i < 1000) {
        @atomicAdd(&atomic_counter, 1)
        i = i + 1
    }
}

test "atomicAdd two threads" {
    atomic_counter = 0
    var t1 = Thread.spawn(@ptrToInt(atomic_increment_worker), 0)
    var t2 = Thread.spawn(@ptrToInt(atomic_increment_worker), 0)
    t1.join()
    t2.join()
    @assertEq(atomic_counter, 2000)
}

test "atomicLoad and atomicStore" {
    var val: i64 = 0
    @atomicStore(&val, 42)
    var loaded = @atomicLoad(&val)
    @assertEq(loaded, 42)
}

test "atomicExchange" {
    var val: i64 = 10
    var old = @atomicExchange(&val, 20)
    @assertEq(old, 10)
    @assertEq(@atomicLoad(&val), 20)
}

test "atomicCAS success" {
    var val: i64 = 42
    var old = @atomicCAS(&val, 42, 99)
    @assertEq(old, 42)
    @assertEq(@atomicLoad(&val), 99)
}

test "atomicCAS failure" {
    var val: i64 = 42
    var old = @atomicCAS(&val, 0, 99)
    @assertEq(old, 42)
    @assertEq(@atomicLoad(&val), 42)
}

// ============================================================================
// Phase 5: Channel(T)
// ============================================================================

var ch: Channel(i64) = undefined

fn chan_producer(arg: i64) void {
    var i: i64 = 0
    while (i < 100) {
        ch.send(i)
        i = i + 1
    }
}

fn chan_consumer(arg: i64) void {
    var sum: i64 = 0
    var i: i64 = 0
    while (i < 100) {
        sum = sum + ch.recv()
        i = i + 1
    }
    @assertEq(sum, 4950)
}

test "channel producer-consumer" {
    ch = Channel(i64).init(16)
    var p = Thread.spawn(@ptrToInt(chan_producer), 0)
    var c = Thread.spawn(@ptrToInt(chan_consumer), 0)
    p.join()
    c.join()
    ch.destroy()
}

test "channel send recv single thread" {
    var c = Channel(i64).init(4)
    c.send(10)
    c.send(20)
    c.send(30)
    @assertEq(c.recv(), 10)
    @assertEq(c.recv(), 20)
    @assertEq(c.recv(), 30)
    c.destroy()
}

test "channel close and isClosed" {
    var c = Channel(i64).init(4)
    @assert(!c.isClosed())
    c.close()
    @assert(c.isClosed())
    c.destroy()
}

test "channel isEmpty" {
    var c = Channel(i64).init(4)
    @assert(c.isEmpty())
    c.send(1)
    @assert(!c.isEmpty())
    c.recv()
    @assert(c.isEmpty())
    c.destroy()
}
