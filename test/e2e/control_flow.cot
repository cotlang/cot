// E2E tests: Control Flow (82 tests)
// Ported from bootstrap-0.2
// Skipped: 021-025,065,095 (extern/malloc), 040,041,047,058,066,069,086,088,090,099,100 (malformed)

// === Helper functions ===

fn cf01_check(x: i64) i64 { if x > 0 { return 1; } return 0; }
fn cf02_sum(n: i64) i64 { var s: i64 = 0; var i: i64 = 0; while i < n { s = s + i; i = i + 1; } return s; }
fn cf03_classify(x: i64) i64 { if x > 0 { if x > 10 { return 2; } return 1; } return 0; }
fn cf04_test_else(x: i64) i64 { if x > 0 { return 1; } else { return 0; } }
fn cf05_classify(x: i64) i64 { if x < 0 { return 0; } else if x == 0 { return 1; } else { return 2; } }
fn cf06_find_first_gt(limit: i64) i64 {
    var i: i64 = 0;
    while i < 100 { if i > limit { break; } i = i + 1; }
    return i;
}
fn cf07_sum_odd(n: i64) i64 {
    var sum: i64 = 0; var i: i64 = 0;
    while i < n { i = i + 1; if (i % 2) == 0 { continue; } sum = sum + i; }
    return sum;
}
fn cf08_mul_table_sum(n: i64) i64 {
    var sum: i64 = 0; var i: i64 = 1;
    while i <= n { var j: i64 = 1; while j <= n { sum = sum + (i * j); j = j + 1; } i = i + 1; }
    return sum;
}
fn cf09_find_zero(a: i64, b: i64, c: i64) i64 {
    if a == 0 { return 1; } if b == 0 { return 2; } if c == 0 { return 3; } return 0;
}
fn cf10_check(a: i64, b: i64, c: i64) i64 {
    if a > 0 { if b > 0 { if c > 0 { return 1; } } } return 0;
}
fn cf11_deep_nest(x: i64) i64 {
    if x > 0 { if x > 5 { if x > 10 { if x > 15 { return 4; } return 3; } return 2; } return 1; } return 0;
}
fn cf12_sum_even(n: i64) i64 {
    var sum: i64 = 0; var i: i64 = 0;
    while i <= n { if (i % 2) == 0 { sum = sum + i; } i = i + 1; }
    return sum;
}
fn cf13_conditional_sum(do_sum: i64, n: i64) i64 {
    if do_sum != 0 { var sum: i64 = 0; var i: i64 = 1; while i <= n { sum = sum + i; i = i + 1; } return sum; }
    return 0;
}
fn cf14_find_product(limit: i64) i64 {
    var result: i64 = 0; var i: i64 = 1;
    while i < 10 {
        var j: i64 = 1;
        while j < 10 { if i * j > limit { result = i * j; break; } j = j + 1; }
        if result > 0 { break; }
        i = i + 1;
    }
    return result;
}
fn cf15_multi_return(x: i64) i64 {
    if x < 0 { return 0 - 1; } if x == 0 { return 0; } if x < 10 { return 1; } if x < 100 { return 2; } return 3;
}
fn cf16_count_down(n: i64) i64 {
    var count: i64 = 0; var i: i64 = n; while i > 0 { count = count + 1; i = i - 1; } return count;
}
fn cf17_gcd(a_in: i64, b_in: i64) i64 {
    var a: i64 = a_in; var b: i64 = b_in;
    while b != 0 { var t: i64 = b; b = a % b; a = t; }
    return a;
}
fn cf18_count_fizzbuzz(n: i64) i64 {
    var count: i64 = 0; var i: i64 = 1;
    while i <= n { if (i % 3) == 0 { if (i % 5) == 0 { count = count + 1; } } i = i + 1; }
    return count;
}
fn cf19_find_first_divisible(n: i64, divisor: i64) i64 {
    var i: i64 = 1; while i <= n { if (i % divisor) == 0 { return i; } i = i + 1; } return 0;
}
fn cf20_sum_digits(n: i64) i64 {
    var sum: i64 = 0; var x: i64 = n; while x > 0 { sum = sum + (x % 10); x = x / 10; } return sum;
}
fn cf26_count_to(n: i64) i64 { var i: i64 = 0; while i < n { i = i + 1; } return i; }
fn cf27_false_cond() i64 { if 0 != 0 { return 1; } return 0; }
fn cf28_true_cond() i64 { if 1 == 1 { return 42; } return 0; }
fn cf29_find_sum_gt(limit: i64) i64 {
    var sum: i64 = 0; var i: i64 = 1;
    while i < 100 { sum = sum + i; if sum > limit { break; } i = i + 1; }
    return sum;
}
fn cf30_first_divisible(n: i64, d1: i64, d2: i64) i64 {
    var i: i64 = 1;
    while i <= n { if (i % d1) == 0 { break; } if (i % d2) == 0 { break; } i = i + 1; }
    return i;
}
fn cf31_classify(x: i64) i64 {
    if x < 10 { return 0; } else if x < 20 { return 1; } else if x < 30 { return 2; }
    else if x < 40 { return 3; } else if x < 50 { return 4; } else { return 5; }
}
fn cf32_while_zero() i64 { var count: i64 = 0; while 0 != 0 { count = count + 1; } return count; }
fn cf33_nested_else(a: i64, b: i64) i64 {
    if a > 0 { if b > 0 { return 1; } else { return 2; } } else { if b > 0 { return 3; } else { return 4; } }
}
fn cf34_count_matches(limit: i64, mod_val: i64) i64 {
    var count: i64 = 0; var i: i64 = 1;
    while i <= limit { if (i % mod_val) == 0 { count = count + 1; } i = i + 1; }
    return count;
}
fn cf35_sum_alternating(n: i64) i64 {
    var sum: i64 = 0; var i: i64 = 1; var sign: i64 = 1;
    while i <= n { sum = sum + sign * i; sign = 0 - sign; i = i + 1; }
    return sum;
}
fn cf36_count_odd_in_range(lo: i64, hi: i64) i64 {
    var count: i64 = 0; var i: i64 = lo;
    while i <= hi { if (i % 2) == 0 { i = i + 1; continue; } count = count + 1; i = i + 1; }
    return count;
}
fn cf37_sum_matrix(n: i64) i64 {
    var sum: i64 = 0; var i: i64 = 1;
    while i <= n { var j: i64 = 1; while j <= n { sum = sum + i * j; j = j + 1; } i = i + 1; }
    return sum;
}
fn cf45_check(x: i64) i64 {
    if x < 0 { return 0 - 1; } if x == 0 { return 0; } if x == 1 { return 1; } return x * 2;
}
fn cf46_grade(score: i64) i64 {
    if score >= 90 { return 4; } if score >= 80 { return 3; } if score >= 70 { return 2; }
    if score >= 60 { return 1; } return 0;
}
fn cf49_classify(n: i64) i64 {
    if n < 0 { return 0 - 1; } if n == 0 { return 0; } if n < 10 { return 1; } if n < 100 { return 2; } return 3;
}
fn cf50_sum_until_threshold() i64 {
    var sum: i64 = 0; var i: i64 = 0;
    while i < 100 { sum = sum + i; if sum > 20 { i = i + 1; if i > 0 { return sum; } } i = i + 1; }
    return 0;
}
fn cf51_find_div3(start: i64, end_val: i64) i64 {
    var i: i64 = start; while i <= end_val { if i % 3 == 0 { return i; } i = i + 1; } return 0 - 1;
}
fn cf52_count_in_range(start: i64, end_val: i64, divisor: i64) i64 {
    var count: i64 = 0; var i: i64 = start;
    while i <= end_val { if i % divisor == 0 { count = count + 1; } i = i + 1; }
    return count;
}
fn cf53_sum_range(start: i64, end_val: i64) i64 {
    var sum: i64 = 0; var i: i64 = start;
    while i <= end_val { sum = sum + i; i = i + 1; }
    return sum;
}
fn cf54_product_range(start: i64, end_val: i64) i64 {
    var prod: i64 = 1; var i: i64 = start;
    while i <= end_val { prod = prod * i; i = i + 1; }
    return prod;
}
fn cf55_sum_odds(n: i64) i64 {
    var sum: i64 = 0; var i: i64 = 1;
    while i <= n { if i % 2 == 1 { sum = sum + i; } i = i + 1; }
    return sum;
}
fn cf56_check(x: i64, y: i64) i64 {
    if x > 0 { if y > 0 { return 1; } return 2; } return 3;
}
fn cf70_is_prime(n: i64) i64 {
    if n <= 1 { return 0; } if n <= 3 { return 1; } if n % 2 == 0 { return 0; }
    var i: i64 = 3; while i * i <= n { if n % i == 0 { return 0; } i = i + 2; }
    return 1;
}
fn cf71_day_of_week(d: i64) i64 {
    if d == 0 { return 0; } if d == 1 { return 1; } if d == 2 { return 2; }
    if d == 3 { return 3; } if d == 4 { return 4; } if d == 5 { return 5; }
    if d == 6 { return 6; } return 0 - 1;
}
fn cf72_grade(score: i64) i64 {
    if score >= 90 { return 4; } if score >= 80 { return 3; } if score >= 70 { return 2; }
    if score >= 60 { return 1; } return 0;
}
fn cf73_in_range(x: i64, lo: i64, hi: i64) i64 {
    if x >= lo { if x <= hi { return 1; } } return 0;
}
fn cf74_clamp(x: i64, lo: i64, hi: i64) i64 {
    if x < lo { return lo; } if x > hi { return hi; } return x;
}
fn cf75_find_first_positive(a: i64, b: i64, c: i64, d: i64) i64 {
    if a > 0 { return a; } if b > 0 { return b; } if c > 0 { return c; } if d > 0 { return d; } return 0;
}
fn cf76_sign(x: i64) i64 { if x > 0 { return 1; } if x < 0 { return 0 - 1; } return 0; }
fn cf77_all_true(a: i64, b: i64, c: i64) i64 {
    if a != 0 { if b != 0 { if c != 0 { return 1; } } } return 0;
}
fn cf78_any_true(a: i64, b: i64, c: i64) i64 {
    if a != 0 { return 1; } if b != 0 { return 1; } if c != 0 { return 1; } return 0;
}
fn cf79_count_divisible(n: i64, d: i64) i64 {
    var count: i64 = 0; var i: i64 = 1;
    while i <= n { if i % d == 0 { count = count + 1; } i = i + 1; }
    return count;
}
fn cf80_sum_divisible(n: i64, d: i64) i64 {
    var sum: i64 = 0; var i: i64 = 1;
    while i <= n { if i % d == 0 { sum = sum + i; } i = i + 1; }
    return sum;
}
fn cf81_countdown(n: i64) i64 {
    var result: i64 = 0; var i: i64 = n; while i > 0 { result = result + i; i = i - 1; } return result;
}
fn cf82_even_sum(n: i64) i64 {
    var sum: i64 = 0; var i: i64 = 2; while i <= n { sum = sum + i; i = i + 2; } return sum;
}
fn cf83_odd_sum(n: i64) i64 {
    var sum: i64 = 0; var i: i64 = 1; while i <= n { sum = sum + i; i = i + 2; } return sum;
}
fn cf87_classify(x: i64) i64 {
    if x < 0 { return 0 - 1; } if x == 0 { return 0; } if x < 10 { return 1; } if x < 100 { return 2; } return 3;
}
fn cf89_grade(score: i64) i64 {
    if score >= 90 { return 4; } else { if score >= 80 { return 3; } else { if score >= 70 { return 2; } else { if score >= 60 { return 1; } else { return 0; } } } }
}
fn cf91_find_first_even(a: i64, b: i64, c: i64, d: i64) i64 {
    if a % 2 == 0 { return a; } if b % 2 == 0 { return b; } if c % 2 == 0 { return c; }
    if d % 2 == 0 { return d; } return 0 - 1;
}
fn cf92_classify_char(c: i64) i64 {
    if c >= 48 { if c <= 57 { return 1; } } if c >= 65 { if c <= 90 { return 2; } }
    if c >= 97 { if c <= 122 { return 2; } } return 0;
}
fn cf93_find_divisor(n: i64) i64 {
    var i: i64 = 2; while i < n { if n % i == 0 { return i; } i = i + 1; } return 0 - 1;
}
fn cf97_fizzbuzz(n: i64) i64 {
    if n % 15 == 0 { return 3; } if n % 5 == 0 { return 2; } if n % 3 == 0 { return 1; } return 0;
}

// === Tests ===

test "001: positive check" {
    @assert_eq(cf01_check(5), 1)
}

test "002: loop sum" {
    @assert_eq(cf02_sum(5), 10)
}

test "003: nested classify" {
    @assert_eq(cf03_classify(5), 1)
}

test "004: if else" {
    @assert_eq(cf04_test_else(5), 1)
}

test "005: else if chain" {
    @assert_eq(cf05_classify(0), 1)
}

test "006: break in loop" {
    @assert_eq(cf06_find_first_gt(10), 11)
}

test "007: continue skip even" {
    @assert_eq(cf07_sum_odd(10), 25)
}

test "008: nested loop product" {
    @assert_eq(cf08_mul_table_sum(3), 36)
}

test "009: find zero position" {
    @assert_eq(cf09_find_zero(1, 0, 1), 2)
}

test "010: triple positive check" {
    @assert_eq(cf10_check(1, 2, 3), 1)
}

test "011: deep nesting" {
    @assert_eq(cf11_deep_nest(12), 3)
}

test "012: sum even numbers" {
    @assert_eq(cf12_sum_even(10), 30)
}

test "013: conditional sum" {
    @assert_eq(cf13_conditional_sum(1, 5), 15)
}

test "014: nested break product" {
    @assert_eq(cf14_find_product(20), 21)
}

test "015: multi return ranges" {
    @assert_eq(cf15_multi_return(50), 2)
}

test "016: countdown loop" {
    @assert_eq(cf16_count_down(10), 10)
}

test "017: gcd algorithm" {
    @assert_eq(cf17_gcd(48, 18), 6)
}

test "018: count fizzbuzz" {
    @assert_eq(cf18_count_fizzbuzz(30), 2)
}

test "019: first divisible" {
    @assert_eq(cf19_find_first_divisible(10, 3), 3)
}

test "020: sum digits" {
    @assert_eq(cf20_sum_digits(12345), 15)
}

// 021-025: skipped (extern/malloc)

test "026: count to n" {
    @assert_eq(cf26_count_to(100), 100)
}

test "027: false condition" {
    @assert_eq(cf27_false_cond(), 0)
}

test "028: true condition" {
    @assert_eq(cf28_true_cond(), 42)
}

test "029: break on sum limit" {
    @assert_eq(cf29_find_sum_gt(50), 55)
}

test "030: first divisible two" {
    @assert_eq(cf30_first_divisible(20, 7, 11), 7)
}

test "031: range classify" {
    @assert_eq(cf31_classify(35), 3)
}

test "032: while false body" {
    @assert_eq(cf32_while_zero(), 0)
}

test "033: nested else branches" {
    @assert_eq(cf33_nested_else(0 - 1, 5), 3)
}

test "034: count modulo matches" {
    @assert_eq(cf34_count_matches(20, 4), 5)
}

test "035: alternating sum" {
    @assert_eq(cf35_sum_alternating(10), 0 - 5)
}

test "036: count odd in range" {
    @assert_eq(cf36_count_odd_in_range(1, 10), 5)
}

test "037: matrix sum" {
    @assert_eq(cf37_sum_matrix(4), 100)
}

test "038: nested loop count" {
    var sum: i64 = 0; var i: i64 = 0;
    while i < 5 { var j: i64 = 0; while j < 5 { sum = sum + 1; j = j + 1; } i = i + 1; }
    @assert_eq(sum, 25)
}

test "039: triple nested loop" {
    var sum: i64 = 0; var i: i64 = 0;
    while i < 3 { var j: i64 = 0; while j < 3 { var k: i64 = 0; while k < 3 { sum = sum + 1; k = k + 1; } j = j + 1; } i = i + 1; }
    @assert_eq(sum, 27)
}

// 040,041: skipped (malformed)

test "042: and in condition" {
    var a: i64 = 5; var b: i64 = 10; var c: i64 = 15;
    @assert(a < b and b < c)
    @assert(a + b == c)
}

test "043: or in condition" {
    var x: i64 = 5;
    @assert(x == 3 or x == 5 or x == 7)
}

test "044: and or combined" {
    var a: i64 = 1; var b: i64 = 2; var c: i64 = 3;
    @assert((a < b and b < c) or (a == 1 and c == 3))
}

test "045: multi-path check" {
    @assert_eq(cf45_check(0 - 5), 0 - 1)
    @assert_eq(cf45_check(0), 0)
    @assert_eq(cf45_check(1), 1)
    @assert_eq(cf45_check(5), 10)
}

test "046: grade classification" {
    @assert_eq(cf46_grade(95), 4)
    @assert_eq(cf46_grade(85), 3)
    @assert_eq(cf46_grade(75), 2)
    @assert_eq(cf46_grade(65), 1)
    @assert_eq(cf46_grade(55), 0)
}

// 047: skipped (malformed)

test "048: deep nesting true" {
    var x: i64 = 100;
    @assert(x > 0)
    @assert(x > 10)
    @assert(x > 50)
    @assert(x > 75)
    @assert(x > 90)
}

test "049: classify ranges" {
    @assert_eq(cf49_classify(0 - 5), 0 - 1)
    @assert_eq(cf49_classify(0), 0)
    @assert_eq(cf49_classify(5), 1)
    @assert_eq(cf49_classify(50), 2)
    @assert_eq(cf49_classify(500), 3)
}

test "050: sum until threshold" {
    @assert_eq(cf50_sum_until_threshold(), 21)
}

test "051: find divisible by 3" {
    @assert_eq(cf51_find_div3(10, 20), 12)
}

test "052: count in range" {
    @assert_eq(cf52_count_in_range(1, 100, 7), 14)
}

test "053: sum range" {
    @assert_eq(cf53_sum_range(1, 100), 5050)
}

test "054: product range" {
    @assert_eq(cf54_product_range(1, 6), 720)
}

test "055: sum odd numbers" {
    @assert_eq(cf55_sum_odds(10), 25)
}

test "056: two-arg classify" {
    @assert_eq(cf56_check(1, 1), 1)
    @assert_eq(cf56_check(1, 0 - 1), 2)
    @assert_eq(cf56_check(0 - 1, 1), 3)
}

test "057: while with and" {
    var i: i64 = 0; var sum: i64 = 0;
    while i < 10 and sum < 20 { sum = sum + i; i = i + 1; }
    @assert_eq(sum, 21)
}

// 058: skipped (malformed)

test "059: infinite loop break" {
    var i: i64 = 0;
    while 1 == 1 { i = i + 1; if i >= 10 { break; } }
    @assert_eq(i, 10)
}

test "060: countdown to zero" {
    var n: i64 = 10; while n > 0 { n = n - 1; }
    @assert_eq(n, 0)
}

test "061: step by two sum" {
    var sum: i64 = 0; var i: i64 = 0;
    while i < 10 { sum = sum + i; i = i + 2; }
    @assert_eq(sum, 20)
}

test "062: power of two loop" {
    var x: i64 = 1; var i: i64 = 0;
    while i < 10 { x = x * 2; i = i + 1; }
    @assert_eq(x, 1024)
}

test "063: harmonic sum check" {
    var sum: i64 = 0; var i: i64 = 1;
    while i <= 100 { sum = sum + 1000 / i; i = i + 1; }
    @assert(sum > 5000)
}

test "064: nested loop counter" {
    var outer: i64 = 0; var i: i64 = 0;
    while i < 5 { var j: i64 = 0; while j < 5 { outer = outer + 1; j = j + 1; } i = i + 1; }
    @assert_eq(outer, 25)
}

// 065,066: skipped (extern/malformed)

test "067: alternating sign sum" {
    var sum: i64 = 0; var i: i64 = 1; var sign: i64 = 1;
    while i <= 10 { sum = sum + sign * i; sign = 0 - sign; i = i + 1; }
    @assert_eq(sum, 0 - 5)
}

test "068: fibonacci loop" {
    var a: i64 = 0; var b: i64 = 1; var i: i64 = 0;
    while i < 10 { var t: i64 = a + b; a = b; b = t; i = i + 1; }
    @assert_eq(a, 55)
}

// 069: skipped (malformed)

test "070: count primes to 100" {
    var count: i64 = 0; var n: i64 = 2;
    while n <= 100 { count = count + cf70_is_prime(n); n = n + 1; }
    @assert_eq(count, 25)
}

test "071: day of week" {
    @assert_eq(cf71_day_of_week(3), 3)
    @assert_eq(cf71_day_of_week(7), 0 - 1)
}

test "072: grade function" {
    @assert_eq(cf72_grade(95), 4)
    @assert_eq(cf72_grade(75), 2)
    @assert_eq(cf72_grade(55), 0)
}

test "073: in range check" {
    @assert_eq(cf73_in_range(5, 0, 10), 1)
    @assert_eq(cf73_in_range(15, 0, 10), 0)
}

test "074: clamp function" {
    @assert_eq(cf74_clamp(5, 0, 10), 5)
    @assert_eq(cf74_clamp(0 - 5, 0, 10), 0)
    @assert_eq(cf74_clamp(15, 0, 10), 10)
}

test "075: first positive" {
    @assert_eq(cf75_find_first_positive(0 - 1, 0 - 2, 3, 4), 3)
}

test "076: sign function" {
    @assert_eq(cf76_sign(42), 1)
    @assert_eq(cf76_sign(0 - 5), 0 - 1)
    @assert_eq(cf76_sign(0), 0)
}

test "077: all true check" {
    @assert_eq(cf77_all_true(1, 1, 1), 1)
    @assert_eq(cf77_all_true(1, 0, 1), 0)
}

test "078: any true check" {
    @assert_eq(cf78_any_true(0, 0, 1), 1)
    @assert_eq(cf78_any_true(0, 0, 0), 0)
}

test "079: count divisible" {
    @assert_eq(cf79_count_divisible(20, 3), 6)
}

test "080: sum divisible" {
    @assert_eq(cf80_sum_divisible(10, 2), 30)
}

test "081: countdown sum" {
    @assert_eq(cf81_countdown(5), 15)
}

test "082: even sum" {
    @assert_eq(cf82_even_sum(10), 30)
}

test "083: odd sum" {
    @assert_eq(cf83_odd_sum(10), 25)
}

test "084: nested loop 3x4" {
    var sum: i64 = 0; var i: i64 = 0;
    while i < 3 { var j: i64 = 0; while j < 4 { sum = sum + 1; j = j + 1; } i = i + 1; }
    @assert_eq(sum, 12)
}

test "085: triple nested 2x3x4" {
    var sum: i64 = 0; var i: i64 = 0;
    while i < 2 { var j: i64 = 0; while j < 3 { var k: i64 = 0; while k < 4 { sum = sum + 1; k = k + 1; } j = j + 1; } i = i + 1; }
    @assert_eq(sum, 24)
}

// 086: skipped (malformed)

test "087: classify value" {
    @assert_eq(cf87_classify(50), 2)
}

// 088: skipped (malformed)

test "089: nested else grade" {
    @assert_eq(cf89_grade(85), 3)
}

// 090: skipped (malformed)

test "091: first even value" {
    @assert_eq(cf91_find_first_even(1, 3, 4, 5), 4)
}

test "092: classify char code" {
    @assert_eq(cf92_classify_char(65), 2)
}

test "093: find divisor" {
    @assert_eq(cf93_find_divisor(15), 3)
}

test "094: triangular loop sum" {
    var sum: i64 = 0; var i: i64 = 1;
    while i <= 5 { var j: i64 = 1; while j <= i { sum = sum + j; j = j + 1; } i = i + 1; }
    @assert_eq(sum, 35)
}

// 095: skipped (extern/malloc)

test "096: multiple divisibility" {
    var n: i64 = 24;
    @assert(n % 2 == 0)
    @assert(n % 3 == 0)
    @assert(n % 4 == 0)
}

test "097: fizzbuzz classify" {
    @assert_eq(cf97_fizzbuzz(15), 3)
    @assert_eq(cf97_fizzbuzz(9), 1)
    @assert_eq(cf97_fizzbuzz(10), 2)
    @assert_eq(cf97_fizzbuzz(7), 0)
}

test "098: factorial loop" {
    var product: i64 = 1; var i: i64 = 1;
    while i <= 5 { product = product * i; i = i + 1; }
    @assert_eq(product, 120)
}

// 099,100: skipped (malformed)
