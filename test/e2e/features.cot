// Combined native E2E test program — inline test format.
// Each `test "name" { ... }` block runs independently.

import "std/list"
import "std/map"
import "std/string"
import "std/sys"

// ============================================================================
// Shared type declarations
// ============================================================================

struct Foo { x: i64 }
struct Bar { y: i64 }
struct Point { x: i64, y: i64 }
struct Config { width: i64 = 800, height: i64 = 600, debug: i64 = 0 }
struct Partial { name: string, score: i64 = 100 }
type Coord = Point;

const Color = enum { Red, Green, Blue }
const Status = enum { Ok = 0, Warning = 50, Error = 100 }
const Level = enum { Low = 10, Medium = 50, High = 100 }

union State { Init, Running, Done }
union Result { Ok: i64, Err: i32 }
union Event { Click: i64, Hover, KeyPress: i64 }
union Container { point: Point, val: i64, none }

const MyError = error { Fail, NotFound }

impl Level {
    fn isHigh(self: *Level) bool {
        return self.* == 100
    }

    fn toInt(self: *Level) i64 {
        return self.*
    }
}

// DFoo: Foo variant with deinit (deinit tests need Foo_deinit but ARC tests must NOT have it)
struct DFoo { x: i64 }
fn DFoo_deinit(self: *DFoo) void { return }

// ============================================================================
// Shared helper functions
// ============================================================================

fn double(x: i64) i64 { return x + x }

fn createFoo(val: i64) *Foo {
    return new Foo { x: val }
}

fn makeFoo(v: i64) *Foo {
    return new Foo { x: v }
}

fn add(a: i64, b: i64) i64 { return a + b }

fn dbl(x: i64) i64 { return x * 2 }

fn apply_fn(f: fn(i64) -> i64, x: i64) i64 {
    return f(x)
}

fn inc(x: i64) i64 { return x + 1 }
fn dec(x: i64) i64 { return x - 1 }

fn mayFail(x: i64) MyError!i64 {
    if (x < 0) { return error.Fail }
    return x * 2
}

fn inner() MyError!i64 {
    return error.Fail
}

fn outer() MyError!i64 {
    var x = try inner()
    return x + 1
}

fn createDFoo(val: i64) *DFoo {
    return new DFoo { x: val }
}

// ============================================================================
// Generic type declarations
// ============================================================================

struct Pair(T, U) { first: T, second: U }
struct Box(T) { value: T }
struct BoxC(T) { value: T, count: i64 }
struct Counter(T) { value: T }
struct CounterM(T) { value: T, count: i64 }

// List(T) imported from std/list

// ============================================================================
// Generic helper functions (free function pattern)
// ============================================================================

fn max(T)(a: T, b: T) T {
    if (a > b) { return a }
    return b
}

fn generic_add(T)(a: T, b: T) T {
    return a + b
}

fn Box_getValue(T)(self: *Box(T)) T {
    return self.value
}

fn getSize(T)() i64 {
    return @sizeOf(T)
}

fn allocOne(T)(value: T) *T {
    var ptr = @intToPtr(*T, alloc(0, @sizeOf(T)))
    ptr.* = value
    return ptr
}

fn CounterM_increment(T)(self: *CounterM(T)) void {
    self.count = self.count + 1
}

// List free functions
fn List_ensureCapacity(T)(self: *List(T), needed: i64) void {
    if (self.capacity >= needed) { return }
    var new_cap: i64 = 8
    if (self.capacity > 0) { new_cap = self.capacity * 2 }
    var bytes = new_cap * @sizeOf(T)
    if (self.capacity == 0) {
        self.items = alloc(0, bytes)
    } else {
        self.items = realloc(self.items, bytes)
    }
    self.capacity = new_cap
}

fn List_append(T)(self: *List(T), value: T) void {
    List_ensureCapacity(T)(self, self.count + 1)
    var ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
    ptr.* = value
    self.count = self.count + 1
}

fn List_get(T)(self: *List(T), index: i64) T {
    var ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
    return ptr.*
}

fn List_set(T)(self: *List(T), index: i64, value: T) void {
    var ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
    ptr.* = value
}

fn List_pop(T)(self: *List(T)) T {
    self.count = self.count - 1
    var ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
    return ptr.*
}

// ============================================================================
// Generic impl blocks
// ============================================================================

impl Counter(T) {
    fn get(self: *Counter(T)) T {
        return self.value
    }
}

impl BoxC(T) {
    fn getCount(self: *BoxC(T)) i64 {
        return self.count
    }
    fn increment(self: *BoxC(T)) void {
        self.count = self.getCount() + 1
    }
}

impl Box(T) {
    fn get(self: *Box(T)) T {
        return self.value
    }
}

impl Pair(T, U) {
    fn sum(self: *Pair(T, U)) i64 {
        return self.first + self.second
    }
}

// List(T) impl imported from std/list

// ============================================================================
// Tests: Baseline
// ============================================================================

test "baseline" {
    // Constants
    @assertEq(42, 42)
    @assertEq(10 + 5, 15)
    @assertEq(20 - 8, 12)
    @assertEq(6 * 7, 42)
    @assertEq(2 + 3 * 4, 14)

    // Variables
    var x = 10
    var y = 5
    @assertEq(x + y, 15)

    // If/else
    if (10 > 5) {
        var ok = 1
        @assertEq(ok, 1)
    } else {
        @assert(1 == 0)
    }

    // While loop
    var sum: i64 = 0
    var i: i64 = 1
    while (i <= 10) {
        sum = sum + i
        i = i + 1
    }
    @assertEq(sum, 55)
}

// ============================================================================
// Tests: Phase 3 language features
// ============================================================================

test "phase3" {
    // Char literals
    var c1 = 'A'
    @assertEq(c1, 65)
    var c2 = '\n'
    @assertEq(c2, 10)

    // Type alias + struct
    var coord: Coord = Coord { .x = 10, .y = 20 }
    @assertEq(coord.x + coord.y, 30)

    // Builtins
    @assertEq(@sizeOf(i64), 8)
    @assertEq(@sizeOf(Point), 16)
    @assertEq(@alignOf(i64), 8)
    var big: i64 = 42
    var small = @intCast(i32, big)
    @assertEq(small, 42)

    // Enums
    var color: i64 = Color.Green
    @assertEq(color, 1)
    var status: i64 = Status.Error
    @assertEq(status, 100)

    // Union
    var state: i64 = State.Running
    @assertEq(state, 1)

    // Bitwise ops
    var a = 255
    var b = 15
    @assertEq(a & b, 15)
    @assertEq((240 | 15) - 200, 55)
    @assertEq((a ^ b) & 255, 240)
    @assertEq((~0) & 255, 255)
    @assertEq(1 << 4, 16)
    @assertEq(64 >> 2, 16)

    // Compound assignment
    var x = 10
    x += 5
    @assertEq(x, 15)
    x -= 3
    @assertEq(x, 12)
    x *= 2
    @assertEq(x, 24)
    var y = 255
    y &= 15
    @assertEq(y, 15)

    // Optional types
    var opt1: ?i64 = 42
    @assertEq(opt1.?, 42)
    var opt2: ?i64 = null
    @assertEq(opt2 orelse 99, 99)
    var opt3: ?i64 = 42
    @assertEq(opt3 orelse 99, 42)

    // Switch
    var sw1 = switch 2 {
        1 => 10,
        2 => 20,
        3 => 30,
        else => 0,
    }
    @assertEq(sw1, 20)

    var level = Level.Medium
    var sw2 = switch level {
        Level.Low => 1,
        Level.Medium => 50,
        Level.High => 99,
        else => 0,
    }
    @assertEq(sw2, 50)
}

// ============================================================================
// Tests: Function call + float
// ============================================================================

test "func_call" {
    @assertEq(double(10), 20)
}

test "float_locals" {
    var x: f64 = 3.14
    var y: f64 = 0.0
}

// ============================================================================
// Tests: Union payloads
// ============================================================================

test "union_payload" {
    var r: Result = Result.Ok(42)
    @assertEq(r.tag, 0)
    var val = r.Ok
    @assertEq(val, 42)
    var e: Result = Result.Err(99)
    @assertEq(e.tag, 1)
}

test "union_mixed" {
    var e1: Event = Event.Hover
    @assertEq(e1.tag, 1)
    var e2: Event = Event.Click(100)
    @assertEq(e2.tag, 0)
    var clicks = e2.Click
    @assertEq(clicks, 100)
}

test "union_switch_no_capture" {
    var r: Result = Result.Ok(42)
    var matched: i64 = 0
    switch r {
        Result.Ok => { matched = 1 },
        Result.Err => { matched = 2 },
    }
    @assertEq(matched, 1)
}

test "union_switch_capture" {
    var r: Result = Result.Ok(42)
    var matched: i64 = 0
    var captured: i64 = 0
    switch r {
        Result.Ok |val| => {
            matched = 1
            captured = val
        },
        Result.Err |e| => { matched = 2 },
    }
    @assertEq(matched, 1)
    @assertEq(captured, 42)
}

test "union_struct_payload_capture" {
    var p = Point { .x = 10, .y = 20 }
    var c: Container = Container.point(p)
    var cx: i64 = 0
    var cy: i64 = 0
    switch c {
        Container.point |pt| => {
            cx = pt.x
            cy = pt.y
        },
        Container.val |v| => {},
        Container.none => {},
    }
    @assertEq(cx, 10)
    @assertEq(cy, 20)
}

test "union_switch_expr_no_payload" {
    var s = State.Running
    const val = switch (s) {
        State.Init => 1,
        State.Running => 2,
        State.Done => 3,
    }
    @assertEq(val, 2)
}

test "union_switch_expr_no_payload_else" {
    var e = Event.Hover
    const matched = switch (e) {
        Event.Hover => true,
        else => false,
    }
    @assertEq(matched, true)
}

// ============================================================================
// Tests: Error unions
// ============================================================================

test "error_union_catch" {
    var result = mayFail(-1) catch 99
    @assertEq(result, 99)
    var success = mayFail(5) catch 99
    @assertEq(success, 10)
}

test "error_union_try" {
    var result = outer() catch 42
    @assertEq(result, 42)
}

// ============================================================================
// Tests: Defer
// ============================================================================

test "defer_basic" {
    var x: i64 = 10
    defer x = 99
    @assertEq(x, 10)
}

test "defer_loop_break" {
    var sum: i64 = 0
    var i: i64 = 0
    while (i < 5) {
        defer sum = sum + 1
        i = i + 1
        if (i == 3) { break }
    }
    @assertEq(sum, 3)
}

test "defer_lifo" {
    var x: i64 = 2
    defer x = x + 1
    defer x = x * 10
    @assertEq(x, 2)
}

// ============================================================================
// Tests: ARC
// ============================================================================

test "arc_func_return_new" {
    var p = createFoo(42)
    @assertEq(p.x, 42)
}

test "arc_copy_local" {
    var p = new Foo { x: 10 }
    var q = p
    @assertEq(q.x, 10)
}

test "arc_reassignment" {
    var p = new Foo { x: 1 }
    var q = new Foo { x: 2 }
    p = q
    @assertEq(p.x, 2)
}

test "arc_return_forward" {
    var f = makeFoo(77)
    @assertEq(f.x, 77)
}

test "arc_dealloc_basic" {
    var p = new Foo { x: 42 }
    @assertEq(p.x, 42)
}

test "arc_dealloc_multi" {
    var a = makeFoo(10)
    var b = makeFoo(20)
    var c = makeFoo(12)
    @assertEq(a.x + b.x + c.x, 42)
}

// ============================================================================
// Tests: Memory (alloc, dealloc, realloc)
// ============================================================================

test "builtin_alloc_dealloc" {
    var ptr = alloc(0, 8)
    dealloc(ptr)
}

test "builtin_realloc" {
    var ptr = alloc(0, 8)
    var ptr2 = realloc(ptr, 16)
    dealloc(ptr2)
}

test "freelist_reuse" {
    var p1 = alloc(0, 8)
    dealloc(p1)
    var p2 = alloc(0, 8)
    dealloc(p2)
    var p3 = alloc(0, 8)
    dealloc(p3)
}

// ============================================================================
// Tests: Deinit (uses DFoo with DFoo_deinit)
// ============================================================================

test "deinit_basic" {
    var p = new DFoo { x: 42 }
    @assertEq(p.x, 42)
}

test "deinit_no_use" {
    var p = new DFoo { x: 42 }
}

test "deinit_mixed" {
    var f = new DFoo { x: 10 }
    var b = new Bar { y: 20 }
    @assertEq(f.x + b.y, 30)
}

test "deinit_alloc_reuse" {
    var p1 = createDFoo(10)
    var v1 = p1.x
    var p2 = createDFoo(20)
    @assertEq(v1 + p2.x, 30)
}

// ============================================================================
// Tests: Function pointers
// ============================================================================

test "fnptr_basic" {
    var f = add
    @assertEq(f(3, 4), 7)
}

test "fnptr_param" {
    @assertEq(apply_fn(dbl, 5), 10)
}

test "fnptr_reassign" {
    var f = inc
    var a = f(10)
    f = dec
    var b = f(10)
    @assertEq(a + b, 20)
}

// ============================================================================
// Tests: Closures
// ============================================================================

test "closure_no_capture" {
    var f = fn(x: i64) i64 { return x * 2 }
    @assertEq(f(21), 42)
}

test "closure_capture" {
    var x: i64 = 10
    var f = fn(y: i64) i64 { return x + y }
    @assertEq(f(5), 15)
}

test "closure_multi_capture" {
    var a: i64 = 3
    var b: i64 = 7
    var f = fn(x: i64) i64 { return a + b + x }
    @assertEq(f(10), 20)
}

test "closure_passed" {
    var offset: i64 = 100
    var g = fn(x: i64) i64 { return x + offset }
    @assertEq(apply_fn(g, 5), 105)
}

// ============================================================================
// Tests: Generics (plain functions)
// ============================================================================

test "generic_fn_basic" {
    @assertEq(max(i64)(3, 7), 7)
}

test "generic_struct_basic" {
    var p: Pair(i64, i64) = undefined
    p.first = 10
    p.second = 20
    @assertEq(p.first + p.second, 30)
}

test "generic_fn_multi_inst" {
    var x: i64 = generic_add(i64)(10, 20)
    var y: i32 = generic_add(i32)(3, 4)
    @assertEq(x + y, 37)
}

test "generic_struct_param" {
    var b: Box(i64) = undefined
    b.value = 42
    @assertEq(Box_getValue(i64)(&b), 42)
}

test "sizeof_generic" {
    @assertEq(getSize(i64)(), 8)
}

test "alloc_inttoptr_generic" {
    var p = allocOne(i64)(42)
    var result = p.*
    dealloc(@ptrToInt(p))
    @assertEq(result, 42)
}

test "generic_field_mutation" {
    var c: CounterM(i64) = undefined
    c.value = 10
    c.count = 0
    CounterM_increment(i64)(&c)
    CounterM_increment(i64)(&c)
    @assertEq(c.count, 2)
}

// ============================================================================
// Tests: List(T) free function pattern
// ============================================================================

test "list_basic" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    List_append(i64)(&list, 10)
    List_append(i64)(&list, 20)
    List_append(i64)(&list, 30)
    var a = List_get(i64)(&list, 0)
    var b = List_get(i64)(&list, 1)
    var c = List_get(i64)(&list, 2)
    @assertEq(a + b + c, 60)
}

test "list_growth" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    var i: i64 = 0
    while (i < 20) {
        List_append(i64)(&list, i)
        i = i + 1
    }
    var first = List_get(i64)(&list, 0)
    var last = List_get(i64)(&list, 19)
    @assertEq(first + last + list.count, 39)
}

test "list_pop" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    List_append(i64)(&list, 10)
    List_append(i64)(&list, 20)
    List_append(i64)(&list, 30)
    var popped = List_pop(i64)(&list)
    @assertEq(popped + list.count, 32)
}

test "list_set" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    List_append(i64)(&list, 10)
    List_append(i64)(&list, 20)
    List_append(i64)(&list, 30)
    List_set(i64)(&list, 1, 50)
    @assertEq(List_get(i64)(&list, 0) + List_get(i64)(&list, 1) + List_get(i64)(&list, 2), 90)
}

test "list_multi_type" {
    var a: List(i64) = undefined
    a.items = 0
    a.count = 0
    a.capacity = 0
    var b: List(i32) = undefined
    b.items = 0
    b.count = 0
    b.capacity = 0
    List_append(i64)(&a, 100)
    List_append(i32)(&b, 5)
    var x = List_get(i64)(&a, 0)
    var y: i64 = List_get(i32)(&b, 0)
    @assertEq(x + y, 105)
}

// ============================================================================
// Tests: List(T) impl pattern (dot-call syntax)
// ============================================================================

test "list_impl_basic" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    list.append(10)
    list.append(20)
    list.append(30)
    var a = list.get(0)
    var b = list.get(1)
    var c = list.get(2)
    @assertEq(a + b + c, 60)
}

test "list_impl_growth" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    var i: i64 = 0
    while (i < 20) {
        list.append(i)
        i = i + 1
    }
    var first = list.get(0)
    var last = list.get(19)
    @assertEq(first + last + list.count, 39)
}

test "list_impl_pop" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    list.append(10)
    list.append(20)
    list.append(30)
    var popped = list.pop()
    @assertEq(popped + list.count, 32)
}

test "list_impl_set" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    list.append(10)
    list.append(20)
    list.append(30)
    list.set(1, 50)
    @assertEq(list.get(0) + list.get(1) + list.get(2), 90)
}

test "list_impl_multi_type" {
    var a: List(i64) = undefined
    a.items = 0
    a.count = 0
    a.capacity = 0
    var b: List(i32) = undefined
    b.items = 0
    b.count = 0
    b.capacity = 0
    a.append(100)
    b.append(5)
    var x = a.get(0)
    var y: i64 = b.get(0)
    @assertEq(x + y, 105)
}

// ============================================================================
// Tests: Generic impl blocks
// ============================================================================

test "generic_impl_basic" {
    var c: Counter(i64) = undefined
    c.value = 42
    @assertEq(c.get(), 42)
}

test "generic_impl_self_call" {
    var b: BoxC(i64) = undefined
    b.value = 10
    b.count = 0
    b.increment()
    b.increment()
    b.increment()
    @assertEq(b.count + b.value, 13)
}

test "generic_impl_multi_inst" {
    var a: Box(i64) = undefined
    a.value = 30
    var b: Box(i32) = undefined
    b.value = 12
    var x: i64 = a.get()
    var y: i64 = b.get()
    @assertEq(x + y, 42)
}

test "generic_impl_forward_ref" {
    var b: BoxC(i64) = undefined
    b.value = 10
    b.count = 0
    b.increment()
    b.increment()
    @assertEq(b.count + b.value, 12)
}

test "generic_impl_two_params" {
    var p: Pair(i64, i64) = undefined
    p.first = 30
    p.second = 12
    @assertEq(p.sum(), 42)
}

// ============================================================================
// Tests: Struct literals, zero init, new for generics
// ============================================================================

test "generic_struct_literal" {
    var p = Pair(i64, i64) { .first = 10, .second = 32 }
    @assertEq(p.first + p.second, 42)
}

test "generic_struct_literal_methods" {
    var p = Pair(i64, i64) { .first = 30, .second = 12 }
    @assertEq(p.sum(), 42)
}

test "zero_init_basic" {
    var p: Point = .{}
    @assertEq(p.x + p.y, 0)
}

test "zero_init_generic" {
    var p: Pair(i64, i64) = .{}
    @assertEq(p.first + p.second, 0)
}

test "new_generic" {
    var p = new Pair(i64, i64) { first: 30, second: 12 }
    @assertEq(p.first + p.second, 42)
}

// ============================================================================
// memcpy function
// ============================================================================

test "memcpy_basic" {
    var src = alloc(0, 24)
    var dst = alloc(0, 24)
    var p0 = @intToPtr(*i64, src)
    p0.* = 10
    var p1 = @intToPtr(*i64, src + 8)
    p1.* = 20
    var p2 = @intToPtr(*i64, src + 16)
    p2.* = 30
    memcpy(dst, src, 24)
    var d0 = @intToPtr(*i64, dst)
    var d1 = @intToPtr(*i64, dst + 8)
    var d2 = @intToPtr(*i64, dst + 16)
    @assertEq(d0.*, 10)
    @assertEq(d1.*, 20)
    @assertEq(d2.*, 30)
    dealloc(src)
    dealloc(dst)
}

test "memcpy_zero_length" {
    var buf = alloc(0, 8)
    @intToPtr(*i64, buf).* = 42
    memcpy(buf, buf, 0)
    @assertEq(@intToPtr(*i64, buf).*, 42)
    dealloc(buf)
}

// ============================================================================
// @trap builtin
// ============================================================================

test "trap_not_reached" {
    var x: i64 = 42
    if (x == 0) { @trap() }
}

// ============================================================================
// Slice parameter passing
// ============================================================================

fn get_slice_len(items: []i64) i64 {
    return items.len
}

fn slice_sum(items: []i64) i64 {
    var total: i64 = 0
    var i: i64 = 0
    while (i < items.len) {
        total = total + items[i]
        i = i + 1
    }
    return total
}

test "slice_param_basic" {
    var arr = [10, 20, 30]
    var s = arr[0:3]
    @assertEq(get_slice_len(s), 3)
}

test "slice_param_iteration" {
    var arr = [10, 20, 30, 40, 50]
    var s = arr[1:4]
    @assertEq(slice_sum(s), 90)
}

// ============================================================================
// Traits
// ============================================================================

trait Greetable {
    fn greet(self: *Self) i64
}

struct TraitDog { age: i64 }

impl Greetable for TraitDog {
    fn greet(self: *TraitDog) i64 {
        return self.age
    }
}

test "trait_basic" {
    var d = TraitDog { .age = 42 }
    @assertEq(d.greet(), 42)
}

trait Doubled {
    fn doubled(self: *Self) i64
}

impl Doubled for i64 {
    fn doubled(self: *i64) i64 {
        return self.* * 2
    }
}

test "trait_primitive" {
    var x: i64 = 21
    @assertEq(x.doubled(), 42)
}

trait HasValue {
    fn value(self: *Self) i64
}

struct TraitCat { lives: i64 }

impl HasValue for TraitCat {
    fn value(self: *TraitCat) i64 {
        return self.lives
    }
}

impl HasValue for TraitDog {
    fn value(self: *TraitDog) i64 {
        return self.age
    }
}

test "trait_multi_impl" {
    var c = TraitCat { .lives = 9 }
    var d = TraitDog { .age = 3 }
    @assertEq(c.value() + d.value(), 12)
}

fn extractValue(T)(item: *T) i64 {
    return item.value()
}

test "trait_generic_usage" {
    var b = TraitCat { .lives = 99 }
    @assertEq(extractValue(TraitCat)(&b), 99)
}

trait TraitEq {
    fn eq(self: *Self, other: *Self) i64
}

struct TraitPoint { x: i64, y: i64 }

impl TraitEq for TraitPoint {
    fn eq(self: *TraitPoint, other: *TraitPoint) i64 {
        if (self.x == other.x) {
            if (self.y == other.y) {
                return 1
            }
        }
        return 0
    }
}

test "trait_self_type" {
    var a = TraitPoint { .x = 3, .y = 4 }
    var b = TraitPoint { .x = 3, .y = 4 }
    var c = TraitPoint { .x = 1, .y = 2 }
    @assertEq(a.eq(&b), 1)
    @assertEq(a.eq(&c), 0)
}

// ============================================================================
// Wave 2: Const evaluation
// ============================================================================

const CE_SIZE: i64 = 8
const CE_DOUBLE: i64 = CE_SIZE * 2
const CE_TRIPLE: i64 = CE_SIZE + CE_SIZE + CE_SIZE

test "const_eval_arithmetic" {
    // Go: cmd/compile/internal/ir/const.go — const folding chains
    @assertEq(CE_DOUBLE, 16)
    @assertEq(CE_TRIPLE, 24)
    @assertEq(CE_DOUBLE + CE_TRIPLE, 40)
}

struct CEPoint { x: i64, y: i64 }
const CE_POINT_SIZE: i64 = @sizeOf(CEPoint)
const CE_I64_SIZE: i64 = @sizeOf(i64)

test "const_eval_sizeof" {
    // Zig: @sizeOf resolved at comptime. Go: unsafe.Sizeof is const-foldable.
    @assertEq(CE_I64_SIZE, 8)
    @assertEq(CE_POINT_SIZE, 16)
    @assertEq(CE_POINT_SIZE + CE_I64_SIZE, 24)
}

// ============================================================================
// Wave 2: Trait bounds
// ============================================================================

trait BComparable {
    fn bcmp(self: *Self, other: *Self) i64
}

impl BComparable for i64 {
    fn bcmp(self: *i64, other: *i64) i64 {
        if (self.* > other.*) { return 1 }
        if (self.* < other.*) { return 0 - 1 }
        return 0
    }
}

fn bounded_max(T)(a: T, b: T) T where T: BComparable {
    var x = a
    var y = b
    if (x.bcmp(&y) > 0) { return a }
    return b
}

test "trait_bound_basic" {
    // Rust: fn max<T: Ord>(a: T, b: T) -> T
    // Go 1.18: func Max[T constraints.Ordered](a, b T) T
    @assertEq(bounded_max(i64)(10, 20), 20)
    @assertEq(bounded_max(i64)(30, 5), 30)
}

trait BAddable {
    fn bval(self: *Self) i64
}

impl BAddable for i64 {
    fn bval(self: *i64) i64 { return self.* }
}

fn bounded_sum(T)(a: T, b: T) i64 where T: BAddable {
    var x = a
    var y = b
    return x.bval() + y.bval()
}

test "trait_bound_multi" {
    @assertEq(bounded_sum(i64)(10, 32), 42)
}

// ============================================================================
// Wave 2: Match expressions (wildcards, guards, ranges)
// ============================================================================

fn match_classify_wildcard(x: i64) i64 {
    return switch x {
        1 => 10,
        2 => 20,
        _ => 99,
    }
}

test "match_wildcard" {
    // Zig: _ in switch covers all remaining values. Rust: _ in match is catch-all.
    @assertEq(match_classify_wildcard(1), 10)
    @assertEq(match_classify_wildcard(2), 20)
    @assertEq(match_classify_wildcard(42), 99)
    @assertEq(match_classify_wildcard(0), 99)
}

fn match_classify_guard(x: i64) i64 {
    return switch x {
        1 if x > 0 => 10,
        2 => 20,
        _ => 0,
    }
}

test "match_guard" {
    // Rust: match x { n if n > 10 => "big", _ => "small" }
    @assertEq(match_classify_guard(1), 10)
    @assertEq(match_classify_guard(2), 20)
    @assertEq(match_classify_guard(99), 0)
}

fn match_classify_range(x: i64) i64 {
    return switch x {
        1..5 => 1,
        6..10 => 2,
        _ => 3,
    }
}

test "match_range" {
    // Zig: 1...10 (inclusive). Rust: 1..=10. Cot: 1..10 (inclusive).
    @assertEq(match_classify_range(1), 1)
    @assertEq(match_classify_range(3), 1)
    @assertEq(match_classify_range(5), 1)
    @assertEq(match_classify_range(6), 2)
    @assertEq(match_classify_range(10), 2)
    @assertEq(match_classify_range(0), 3)
    @assertEq(match_classify_range(11), 3)
}

// ============================================================================
// Wave 2: Tuple types
// ============================================================================

test "tuple_basic" {
    var t = (10, 20)
    @assertEq(t.0, 10)
    @assertEq(t.1, 20)
    @assertEq(t.0 + t.1, 30)
}

test "tuple_nested" {
    var a = (1, 2)
    var b = (3, 4)
    @assertEq(a.0 + a.1 + b.0 + b.1, 10)
}

test "tuple_three" {
    var t = (100, 200, 300)
    @assertEq(t.0 + t.1 + t.2, 600)
}

// ============================================================================
// SRET: Function returns for multi-word types
// ============================================================================

fn make_pair() (i64, i64) {
    return (10, 20)
}

test "sret_tuple_return" {
    var p = make_pair()
    @assertEq(p.0, 10)
    @assertEq(p.1, 20)
    @assertEq(p.0 + p.1, 30)
}

fn make_point() Point {
    return Point { .x = 10, .y = 20 }
}

test "sret_struct_return" {
    var p = make_point()
    @assertEq(p.x, 10)
    @assertEq(p.y, 20)
    @assertEq(p.x + p.y, 30)
}

fn double_pair() (i64, i64) {
    var p = make_pair()
    return (p.0 * 2, p.1 * 2)
}

test "sret_chain" {
    var d = double_pair()
    @assertEq(d.0, 20)
    @assertEq(d.1, 40)
    @assertEq(d.0 + d.1, 60)
}

// ============================================================================
// Tests: Production List(T) — bounds, growth, deinit, insert, remove
// ============================================================================

test "list_bounds_get" {
    // Verify valid boundary indices work (can't test traps from within same program)
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    // get(0) and get(count-1) must succeed
    @assertEq(list.get(0), 10)
    @assertEq(list.get(2), 30)
    // set boundary
    list.set(0, 99)
    @assertEq(list.get(0), 99)
    list.set(2, 88)
    @assertEq(list.get(2), 88)
    list.free()
}

test "list_growth_go" {
    // Go's nextslicecap: 2x for cap<256, ~1.25x for larger
    var list: List(i64) = .{}
    var i: i64 = 0
    while (i < 300) {
        list.append(i)
        i = i + 1
    }
    @assertEq(list.len(), 300)
    // Verify first and last elements survive growth
    @assertEq(list.get(0), 0)
    @assertEq(list.get(299), 299)
    // After 256 elements, growth should be ~1.25x, so capacity < 512 (which 2x would give)
    // With Go's formula: after 256, next cap = 256 + (256+768)/4 = 256 + 256 = 512
    // Then 512 is enough for 300, so cap should be 512
    // But the key test: capacity >= 300 and the data is correct
    @assert(list.cap() >= 300)
    list.free()
}

test "list_free" {
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.free()
    @assertEq(list.count, 0)
    @assertEq(list.capacity, 0)
    @assertEq(list.items, 0)
}

test "list_clear" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    var cap_before = list.cap()
    list.clear()
    @assertEq(list.len(), 0)
    // Capacity retained after clear
    @assertEq(list.cap(), cap_before)
    // Can reuse after clear
    list.append(99)
    @assertEq(list.get(0), 99)
    list.free()
}

test "list_insert" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(30)
    list.append(40)
    // Insert at beginning
    list.insert(0, 5)
    // Insert in middle (between 10 and 30)
    list.insert(2, 20)
    // Insert at end
    list.insert(5, 50)
    // Expected: [5, 10, 20, 30, 40, 50]
    @assertEq(list.len(), 6)
    @assertEq(list.get(0), 5)
    @assertEq(list.get(1), 10)
    @assertEq(list.get(2), 20)
    @assertEq(list.get(3), 30)
    @assertEq(list.get(4), 40)
    @assertEq(list.get(5), 50)
    list.free()
}

test "list_ordered_remove" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(40)
    list.append(50)
    // Remove from beginning
    var first = list.orderedRemove(0)
    @assertEq(first, 10)
    // Now: [20, 30, 40, 50]
    @assertEq(list.len(), 4)
    @assertEq(list.get(0), 20)
    // Remove from middle
    var mid = list.orderedRemove(1)
    @assertEq(mid, 30)
    // Now: [20, 40, 50]
    @assertEq(list.len(), 3)
    @assertEq(list.get(0), 20)
    @assertEq(list.get(1), 40)
    @assertEq(list.get(2), 50)
    list.free()
}

test "list_swap_remove" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(40)
    // SwapRemove index 1 (value 20): last element (40) moves to index 1
    var removed = list.swapRemove(1)
    @assertEq(removed, 20)
    // Now: [10, 40, 30]
    @assertEq(list.len(), 3)
    @assertEq(list.get(0), 10)
    @assertEq(list.get(1), 40)
    @assertEq(list.get(2), 30)
    // SwapRemove last element (no swap needed)
    var last = list.swapRemove(2)
    @assertEq(last, 30)
    @assertEq(list.len(), 2)
    list.free()
}

test "list_reverse" {
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.append(4)
    list.append(5)
    list.reverse()
    @assertEq(list.get(0), 5)
    @assertEq(list.get(1), 4)
    @assertEq(list.get(2), 3)
    @assertEq(list.get(3), 2)
    @assertEq(list.get(4), 1)
    list.free()
}

test "list_clone" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    var copy = list.clone()
    // Verify clone has same data
    @assertEq(copy.len(), 3)
    @assertEq(copy.get(0), 10)
    @assertEq(copy.get(1), 20)
    @assertEq(copy.get(2), 30)
    // Mutate original, verify clone unaffected
    list.set(0, 99)
    @assertEq(copy.get(0), 10)
    list.free()
    copy.free()
}

test "list_last" {
    var list: List(i64) = .{}
    list.append(10)
    @assertEq(list.last(), 10)
    list.append(20)
    @assertEq(list.last(), 20)
    list.append(30)
    @assertEq(list.last(), 30)
    var popped = list.pop()
    @assertEq(list.last(), 20)
    list.free()
}

test "memcpy_overlap" {
    // Test overlapping memcpy (memmove semantics) — used by insert/orderedRemove
    var buf = alloc(0, 40)
    // Write [10, 20, 30, 40, 50] at positions 0-4
    @intToPtr(*i64, buf).* = 10
    @intToPtr(*i64, buf + 8).* = 20
    @intToPtr(*i64, buf + 16).* = 30
    @intToPtr(*i64, buf + 24).* = 40
    @intToPtr(*i64, buf + 32).* = 0
    // Shift right: copy [0..3] to [1..4] (dst > src, backward copy path)
    memcpy(buf + 8, buf, 32)
    // Expected: [10, 10, 20, 30, 40]
    @assertEq(@intToPtr(*i64, buf).*, 10)
    @assertEq(@intToPtr(*i64, buf + 8).*, 10)
    @assertEq(@intToPtr(*i64, buf + 16).*, 20)
    @assertEq(@intToPtr(*i64, buf + 24).*, 30)
    @assertEq(@intToPtr(*i64, buf + 32).*, 40)
    dealloc(buf)
}

// ============================================================================
// Tests: List(T) Tier 1+2 — search, resize, bulk ops, compact
// ============================================================================

test "list_contains" {
    // Go: slices.Contains — linear scan
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    @assertEq(list.contains(20), 1)
    @assertEq(list.contains(99), 0)
    @assertEq(list.contains(10), 1)
    @assertEq(list.contains(30), 1)
    list.free()
}

test "list_index_of" {
    // Go: slices.Index — return index or -1
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(20)
    @assertEq(list.indexOf(10), 0)
    @assertEq(list.indexOf(20), 1)
    @assertEq(list.indexOf(30), 2)
    @assertEq(list.indexOf(99), 0 - 1)
    list.free()
}

test "list_equal" {
    // Go: slices.Equal — element-wise comparison
    var a: List(i64) = .{}
    a.append(1)
    a.append(2)
    a.append(3)
    var b: List(i64) = .{}
    b.append(1)
    b.append(2)
    b.append(3)
    @assertEq(a.equal(&b), 1)
    // Different length
    b.append(4)
    @assertEq(a.equal(&b), 0)
    // Same length, different content
    var c: List(i64) = .{}
    c.append(1)
    c.append(99)
    c.append(3)
    @assertEq(a.equal(&c), 0)
    a.free()
    b.free()
    c.free()
}

test "list_first" {
    var list: List(i64) = .{}
    list.append(42)
    list.append(99)
    @assertEq(list.first(), 42)
    list.insert(0, 7)
    @assertEq(list.first(), 7)
    list.free()
}

test "list_resize" {
    // Zig: resize — grow (undefined elements) or shrink
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    // Shrink
    list.resize(2)
    @assertEq(list.len(), 2)
    @assertEq(list.get(0), 10)
    @assertEq(list.get(1), 20)
    // Grow (new elements undefined, but count changes)
    list.resize(5)
    @assertEq(list.len(), 5)
    // Original elements preserved
    @assertEq(list.get(0), 10)
    @assertEq(list.get(1), 20)
    // Can write to new slots
    list.set(2, 30)
    list.set(3, 40)
    list.set(4, 50)
    @assertEq(list.get(4), 50)
    list.free()
}

test "list_append_n_times" {
    // Zig: appendNTimes — fill with value
    var list: List(i64) = .{}
    list.appendNTimes(42, 5)
    @assertEq(list.len(), 5)
    @assertEq(list.get(0), 42)
    @assertEq(list.get(4), 42)
    // Append more
    list.appendNTimes(0, 3)
    @assertEq(list.len(), 8)
    @assertEq(list.get(5), 0)
    @assertEq(list.get(7), 0)
    list.free()
}

test "list_insert_slice" {
    // Zig: insertSlice — bulk insert at position
    var list: List(i64) = .{}
    list.append(1)
    list.append(5)
    // Prepare source buffer [2, 3, 4]
    var src = alloc(0, 24)
    @intToPtr(*i64, src).* = 2
    @intToPtr(*i64, src + 8).* = 3
    @intToPtr(*i64, src + 16).* = 4
    // Insert at index 1: [1, 2, 3, 4, 5]
    list.insertSlice(1, src, 3)
    dealloc(src)
    @assertEq(list.len(), 5)
    @assertEq(list.get(0), 1)
    @assertEq(list.get(1), 2)
    @assertEq(list.get(2), 3)
    @assertEq(list.get(3), 4)
    @assertEq(list.get(4), 5)
    list.free()
}

test "list_replace_range" {
    // Zig: replaceRange / Go: slices.Replace
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.append(4)
    list.append(5)
    // Replace [1..3) (elements 2,3) with [20, 30, 40] — growing
    var src1 = alloc(0, 24)
    @intToPtr(*i64, src1).* = 20
    @intToPtr(*i64, src1 + 8).* = 30
    @intToPtr(*i64, src1 + 16).* = 40
    list.replaceRange(1, 2, src1, 3)
    dealloc(src1)
    // Expected: [1, 20, 30, 40, 4, 5]
    @assertEq(list.len(), 6)
    @assertEq(list.get(0), 1)
    @assertEq(list.get(1), 20)
    @assertEq(list.get(2), 30)
    @assertEq(list.get(3), 40)
    @assertEq(list.get(4), 4)
    @assertEq(list.get(5), 5)
    // Replace [1..4) (elements 20,30,40) with [99] — shrinking
    var src2 = alloc(0, 8)
    @intToPtr(*i64, src2).* = 99
    list.replaceRange(1, 3, src2, 1)
    dealloc(src2)
    // Expected: [1, 99, 4, 5]
    @assertEq(list.len(), 4)
    @assertEq(list.get(0), 1)
    @assertEq(list.get(1), 99)
    @assertEq(list.get(2), 4)
    @assertEq(list.get(3), 5)
    list.free()
}

test "list_shrink_and_free" {
    // Zig: shrinkAndFree — reduce length and realloc
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(40)
    list.append(50)
    var old_cap = list.cap()
    list.shrinkAndFree(3)
    @assertEq(list.len(), 3)
    @assertEq(list.cap(), 3)
    @assertEq(list.get(0), 10)
    @assertEq(list.get(1), 20)
    @assertEq(list.get(2), 30)
    // Shrink to 0 frees everything
    list.shrinkAndFree(0)
    @assertEq(list.count, 0)
    @assertEq(list.capacity, 0)
}

test "list_delete_range" {
    // Go: slices.Delete(s, i, j) — remove [start, end)
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.append(4)
    list.append(5)
    // Delete [1, 3) — remove elements 2, 3
    list.deleteRange(1, 3)
    // Expected: [1, 4, 5]
    @assertEq(list.len(), 3)
    @assertEq(list.get(0), 1)
    @assertEq(list.get(1), 4)
    @assertEq(list.get(2), 5)
    // Delete [0, 1) — remove first element
    list.deleteRange(0, 1)
    // Expected: [4, 5]
    @assertEq(list.len(), 2)
    @assertEq(list.get(0), 4)
    list.free()
}

test "list_ensure_unused" {
    // Zig: ensureUnusedCapacity
    var list: List(i64) = .{}
    list.append(1)
    list.ensureUnusedCapacity(100)
    @assert(list.cap() >= 101)
    @assertEq(list.len(), 1)
    @assertEq(list.get(0), 1)
    list.free()
}

test "list_is_empty" {
    var list: List(i64) = .{}
    @assertEq(list.isEmpty(), 1)
    list.append(42)
    @assertEq(list.isEmpty(), 0)
    list.pop()
    @assertEq(list.isEmpty(), 1)
}

test "list_compact" {
    // Go: slices.Compact — remove consecutive duplicates
    var list: List(i64) = .{}
    list.append(1)
    list.append(1)
    list.append(2)
    list.append(2)
    list.append(2)
    list.append(3)
    list.append(1)
    list.append(1)
    list.compact()
    // Expected: [1, 2, 3, 1]
    @assertEq(list.len(), 4)
    @assertEq(list.get(0), 1)
    @assertEq(list.get(1), 2)
    @assertEq(list.get(2), 3)
    @assertEq(list.get(3), 1)
    list.free()
}

test "list_struct" {
    var list: List(Point) = .{}
    defer list.free()
    const p1 = Point { .x = 10, .y = 20 }
    const p2 = Point { .x = 30, .y = 40 }
    list.append(p1)
    list.append(p2)
    @assertEq(list.len(), 2)
    @assertEq(list.get(0).x, 10)
    @assertEq(list.get(0).y, 20)
    @assertEq(list.get(1).x, 30)
    @assertEq(list.get(1).y, 40)
}

struct BigStruct {
    name: string,
    age: int,
    score: int,
    active: bool,
    level: int,
    health: int,
    mana: int,
    speed: int,
}

test "list_struct_8_fields" {
    var list: List(BigStruct) = .{}
    defer list.free()
    const s1 = BigStruct { .name = "alice", .age = 30, .score = 100, .active = true, .level = 5, .health = 200, .mana = 50, .speed = 10 }
    const s2 = BigStruct { .name = "bob", .age = 25, .score = 80, .active = false, .level = 3, .health = 150, .mana = 30, .speed = 8 }
    list.append(s1)
    list.append(s2)
    @assertEq(list.len(), 2)
    @assertEq(list.get(0).name, "alice")
    @assertEq(list.get(0).age, 30)
    @assertEq(list.get(0).score, 100)
    @assertEq(list.get(0).active, true)
    @assertEq(list.get(0).level, 5)
    @assertEq(list.get(0).health, 200)
    @assertEq(list.get(0).mana, 50)
    @assertEq(list.get(0).speed, 10)
    @assertEq(list.get(1).name, "bob")
    @assertEq(list.get(1).age, 25)
    @assertEq(list.get(1).active, false)
    @assertEq(list.get(1).speed, 8)
}

// ============================================================================
// Comptime target builtins
// ============================================================================

test "target_os returns string" {
    var os = @targetOs()
    var len = @lenOf(os)
    @assert(len > 0)
}

test "target_arch returns string" {
    var arch = @targetArch()
    var len = @lenOf(arch)
    @assert(len > 0)
}

test "target returns string" {
    var t = @target()
    var len = @lenOf(t)
    @assert(len > 0)
}

test "comptime if folds integer" {
    const val: i64 = if (1 == 1) { 42 } else { 99 }
    @assertEq(val, 42)
}

test "comptime if folds else branch" {
    const val: i64 = if (1 == 2) { 42 } else { 99 }
    @assertEq(val, 99)
}

test "comptime if target_os string compare" {
    const flag: i64 = if (@targetOs() == "linux") { 64 } else { 512 }
    // On macOS this should be 512, on linux 64
    @assert(flag > 0)
}

test "comptime if target_os neq" {
    const flag: i64 = if (@targetOs() != "nonexistent_os") { 1 } else { 0 }
    @assertEq(flag, 1)
}

// ============================================================================
// Tests: @string builtin — construct string from raw (ptr, len)
// ============================================================================

test "string builtin constructs from ptr and len" {
    var s = "hello"
    var ptr = @ptrOf(s)
    var len = @lenOf(s)
    var s2 = @string(ptr, len)
    @assertEq(@lenOf(s2), 5)
}

test "string builtin roundtrip" {
    var s = "world"
    var s2 = @string(@ptrOf(s), @lenOf(s))
    @assert(s == s2)
}

// ============================================================
// comptime blocks and @compileError
// ============================================================

test "comptime block evaluates simple expression" {
    const x = comptime { 40 + 2 }
    @assertEq(x, 42)
}

test "comptime block with nested arithmetic" {
    const y = comptime { 10 * 3 + 7 }
    @assertEq(y, 37)
}

test "comptime block used in expression" {
    var a = 10 + comptime { 5 * 6 }
    @assertEq(a, 40)
}

test "compileError in dead branch is not triggered" {
    const mode = 1
    if (mode == 1) {
        @assert(true)
    } else {
        @compileError("this should never be reached")
    }
}

test "compileError in dead else with target check" {
    if (@targetOs() == "macos") {
        @assert(true)
    } else if (@targetOs() == "linux") {
        @assert(true)
    } else if (@targetOs() == "freestanding") {
        @assert(true)
    } else if (@targetOs() == "wasi") {
        @assert(true)
    } else {
        @compileError("unsupported OS")
    }
}

// ============================================================================
// Auto-deref (pointer.field auto-inserts pointer.*.field)
// ============================================================================

test "auto-deref struct field read" {
    var p = new Point { x: 10, y: 20 }
    @assertEq(p.x, 10)
    @assertEq(p.y, 20)
}

test "auto-deref struct field write" {
    var p = new Point { x: 0, y: 0 }
    p.x = 42
    p.y = 99
    @assertEq(p.x, 42)
    @assertEq(p.y, 99)
}

test "auto-deref method call" {
    var b = new Box(i64) { value: 77 }
    @assertEq(b.get(), 77)
}

test "auto-deref explicit deref still works" {
    var p = new Foo { x: 5 }
    @assertEq(p.*.x, 5)
    @assertEq(p.x, 5)
}

test "auto-deref compound assignment" {
    var p = new Point { x: 10, y: 20 }
    p.x = p.x + 5
    @assertEq(p.x, 15)
}

test "auto-deref returned pointer" {
    var f = createFoo(33)
    @assertEq(f.x, 33)
}

// --- String compound reassignment ---

fn getGreeting() string {
    return "hello world"
}

test "string reassignment from function call" {
    var s = ""
    s = getGreeting()
    @assertEq(@lenOf(s), 11)
    @assertEq(s, "hello world")
}

test "string reassignment preserves length" {
    var s = "short"
    @assertEq(@lenOf(s), 5)
    s = "a longer string"
    @assertEq(@lenOf(s), 15)
    @assertEq(s, "a longer string")
}

test "string conditional reassignment" {
    var s = ""
    var flag: i64 = 1
    if (flag == 1) {
        s = "yes"
    }
    @assertEq(s, "yes")
    @assertEq(@lenOf(s), 3)
}

test "while not done" {
    var done = false
    var count: i64 = 0
    while (not done) {
        count = count + 1
        if (count == 5) {
            done = true
        }
    }
    @assertEq(count, 5)
}

test "not operator on bool" {
    var x = true
    var y = not x
    @assertEq(y, 0)
    var z = not false
    @assertEq(z, 1)
}

// =============================================================================
// errdefer — Zig reference: AstGen.zig:3132-3200, test/behavior/defer.zig:34-233
// =============================================================================

var errdefer_tracker: i64 = 0

fn errdefer_fail() !i64 {
    errdefer errdefer_tracker = 1
    return error.Fail
}

fn errdefer_succeed() !i64 {
    errdefer errdefer_tracker = 1
    return 42
}

test "errdefer runs on error" {
    errdefer_tracker = 0
    var result = errdefer_fail() catch 0
    @assertEq(result, 0)
    @assertEq(errdefer_tracker, 1)
}

test "errdefer does not run on success" {
    errdefer_tracker = 0
    var result = errdefer_succeed() catch 0
    @assertEq(result, 42)
    @assertEq(errdefer_tracker, 0)
}

var errdefer_order: i64 = 0

fn errdefer_ordering() !i64 {
    defer errdefer_order = errdefer_order * 10 + 1
    errdefer errdefer_order = errdefer_order * 10 + 2
    defer errdefer_order = errdefer_order * 10 + 3
    return error.Fail
}

test "errdefer LIFO ordering with defer" {
    errdefer_order = 0
    var result = errdefer_ordering() catch 0
    // LIFO on error: defer(3), errdefer(2), defer(1) → 321
    @assertEq(errdefer_order, 321)
}

var errdefer_order2: i64 = 0

fn errdefer_ordering_success() !i64 {
    defer errdefer_order2 = errdefer_order2 * 10 + 1
    errdefer errdefer_order2 = errdefer_order2 * 10 + 2
    defer errdefer_order2 = errdefer_order2 * 10 + 3
    return 99
}

test "errdefer skipped on success, defers still run" {
    errdefer_order2 = 0
    var result = errdefer_ordering_success() catch 0
    @assertEq(result, 99)
    // LIFO on success: defer(3), skip errdefer, defer(1) → 31
    @assertEq(errdefer_order2, 31)
}

var errdefer_try_tracker: i64 = 0

fn errdefer_inner() !i64 {
    return error.Fail
}

fn errdefer_try_propagate() !i64 {
    errdefer errdefer_try_tracker = 1
    var x = try errdefer_inner()
    return x
}

test "errdefer runs on try propagation" {
    errdefer_try_tracker = 0
    var result = errdefer_try_propagate() catch 0
    @assertEq(result, 0)
    @assertEq(errdefer_try_tracker, 1)
}

// =============================================================================
// if optional unwrap — Zig pattern: if (expr) |val| { ... }
// =============================================================================

test "if optional unwrap non-null" {
    var x: ?i64 = 42
    var result: i64 = 0
    if (x) |val| {
        result = val
    }
    @assertEq(result, 42)
}

test "if optional unwrap null" {
    var x: ?i64 = null
    var result: i64 = 99
    if (x) |val| {
        result = val
    }
    @assertEq(result, 99)
}

test "if optional unwrap with else" {
    var x: ?i64 = null
    var result: i64 = 0
    if (x) |val| {
        result = val * 2
    } else {
        result = -1
    }
    @assertEq(result, -1)
}

test "if optional unwrap non-null with else" {
    var x: ?i64 = 10
    var result: i64 = 0
    if (x) |val| {
        result = val * 2
    } else {
        result = -1
    }
    @assertEq(result, 20)
}

test "if optional unwrap expr" {
    var x: ?i64 = 5
    var result = if (x) |val| { val + 10 } else { -1 }
    @assertEq(result, 15)
}

test "if optional unwrap expr null" {
    var x: ?i64 = null
    var result = if (x) |val| { val + 10 } else { -1 }
    @assertEq(result, -1)
}

// =============================================================================
// Named error set switch matching — catch |err| switch err { error.X => ... }
// =============================================================================

const TestError = error { NotFound, PermissionDenied, IoError }

fn fail_not_found() !i64 {
    return error.NotFound
}

fn fail_io() !i64 {
    return error.IoError
}

test "catch switch on error variant" {
    var result = fail_not_found() catch |err| switch err {
        error.NotFound => -1,
        error.PermissionDenied => -2,
        _ => -99,
    }
    @assertEq(result, -1)
}

test "catch switch io error" {
    var result = fail_io() catch |err| switch err {
        error.NotFound => -1,
        error.IoError => -3,
        _ => -99,
    }
    @assertEq(result, -3)
}

test "catch switch default case" {
    var result = fail_not_found() catch |err| switch err {
        error.PermissionDenied => -2,
        _ => -99,
    }
    @assertEq(result, -99)
}

// ============================================================================
// Map iteration (for k, v in map)
// Reference: Go range.go:241-270 (mapIterStart/mapIterNext desugaring)
// Reference: Zig array_hash_map.zig:749-770 (Iterator with next())
// ============================================================================

test "for key value in map" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    m.set(2, 200)
    m.set(3, 300)
    var sum: i64 = 0
    for k, v in m {
        sum = sum + k + v
    }
    @assertEq(sum, 606)
    m.free()
}

test "for key value in map single entry" {
    var m: Map(i64, i64) = .{}
    m.set(42, 99)
    var key_sum: i64 = 0
    var val_sum: i64 = 0
    for k, v in m {
        key_sum = key_sum + k
        val_sum = val_sum + v
    }
    @assertEq(key_sum, 42)
    @assertEq(val_sum, 99)
    m.free()
}

test "for key value in empty map" {
    var m: Map(i64, i64) = .{}
    var count: i64 = 0
    for k, v in m {
        count = count + 1
    }
    @assertEq(count, 0)
    m.free()
}

// ============================================================================
// Feature 5: Labeled break / labeled continue
// Reference: Zig AstGen.zig label resolution, Go labeled statements
// ============================================================================

test "labeled break from nested for loops" {
    var result: i64 = 0
    outer: for i in 0..5 {
        for j in 0..5 {
            if (i == 2) {
                if (j == 3) {
                    break :outer
                }
            }
            result = result + 1
        }
    }
    // i=0: 5, i=1: 5, i=2: 3 (j=0,1,2 then break) = 13
    @assertEq(result, 13)
}

test "labeled continue from nested for loops" {
    var result: i64 = 0
    outer: for i in 0..3 {
        for j in 0..3 {
            if (j == 1) {
                continue :outer
            }
            result = result + 1
        }
    }
    // each outer iteration only counts j=0
    @assertEq(result, 3)
}

test "labeled break from nested while loops" {
    var result: i64 = 0
    var i: i64 = 0
    outer: while (i < 5) {
        var j: i64 = 0
        while (j < 5) {
            if (i == 3) {
                break :outer
            }
            result = result + 1
            j = j + 1
        }
        i = i + 1
    }
    // i=0: 5, i=1: 5, i=2: 5, i=3: break immediately = 15
    @assertEq(result, 15)
}

test "labeled continue from nested while loops" {
    var result: i64 = 0
    var i: i64 = 0
    outer: while (i < 3) {
        var j: i64 = 0
        while (j < 3) {
            if (j == 1) {
                i = i + 1
                continue :outer
            }
            result = result + 1
            j = j + 1
        }
        i = i + 1
    }
    // each outer iteration only counts j=0, then continue :outer
    @assertEq(result, 3)
}

test "labeled break with mixed for and while" {
    var result: i64 = 0
    outer: for i in 0..4 {
        var j: i64 = 0
        while (j < 4) {
            if (i == 2) {
                if (j == 1) {
                    break :outer
                }
            }
            result = result + 1
            j = j + 1
        }
    }
    // i=0: 4, i=1: 4, i=2: 1 (j=0 then break) = 9
    @assertEq(result, 9)
}

// ============================================================================
// Wave 5: Language Features (Zig Ports)
// ============================================================================

// -- noreturn type --

fn exit_wrapper(code: i64) noreturn {
    exit(code)
}

test "noreturn in if branch" {
    var x = 10
    if (x > 100) { exit(1) }
    @assertEq(x, 10)
}

test "noreturn with exit wrapper" {
    var x = 42
    if (x != 42) { exit_wrapper(1) }
    @assertEq(x, 42)
}

// -- inferred error sets (!T) --

fn mayFail2(x: i64) !i64 {
    if (x < 0) { return error.Negative }
    return x * 2
}

test "inferred error set catch" {
    var result = mayFail2(-1) catch 99
    @assertEq(result, 99)
}

test "inferred error set success" {
    var result = mayFail2(5) catch 0
    @assertEq(result, 10)
}

fn wrapperInferred() !i64 {
    var x = try mayFail2(5)
    return x + 1
}

test "inferred try propagation" {
    var result = wrapperInferred() catch 0
    @assertEq(result, 11)
}

// -- destructuring --

fn getPair() (i64, i64) {
    return (10, 20)
}

fn getTriple() (i64, i64, i64) {
    return (1, 2, 3)
}

test "destructure tuple literal" {
    const a, b = (10, 20)
    @assertEq(a, 10)
    @assertEq(b, 20)
}

test "destructure from function" {
    const x, y = getPair()
    @assertEq(x + y, 30)
}

test "destructure var" {
    var x, y = (1, 2)
    x = x + 10
    @assertEq(x, 11)
    @assertEq(y, 2)
}

test "destructure three elements" {
    const a, b, c = getTriple()
    @assertEq(a + b + c, 6)
}

// -- @embedFile --

test "embed file basic" {
    const data = @embedFile("embed_data.txt")
    @assert(@lenOf(data) > 0)
}

test "embed file content" {
    const data = @embedFile("embed_data.txt")
    @assertEq(@lenOf(data), 22)
}

// -- @hasField --

struct HFPoint { x: i64, y: i64 }

test "hasField true" {
    @assert(@hasField(HFPoint, "x"))
    @assert(@hasField(HFPoint, "y"))
}

test "hasField false" {
    @assert(!@hasField(HFPoint, "z"))
    @assert(!@hasField(HFPoint, "w"))
}

test "hasField comptime branch" {
    if (@hasField(HFPoint, "x")) {
        @assert(true)
    } else {
        @compileError("unreachable")
    }
}

// -- @TypeOf --

test "typeof var decl" {
    const x: i64 = 42
    var y: @TypeOf(x) = 10
    @assertEq(y, 10)
}

test "typeof in expression" {
    var a: i64 = 5
    var b: i64 = @TypeOf(a)  // should be i64 type, 0 at runtime (returns the type, not value)
    @assertEq(a, 5)
}

// -- @field --

struct FPoint { x: i64, y: i64 }

test "field access" {
    var p = FPoint { .x = 10, .y = 20 }
    @assertEq(@field(p, "x"), 10)
    @assertEq(@field(p, "y"), 20)
}

test "field with hasField" {
    if (@hasField(FPoint, "x")) {
        var p = FPoint { .x = 42, .y = 0 }
        @assertEq(@field(p, "x"), 42)
    }
}

// -- Error set merge --

const MergeFileError = error { NotFound, PermDenied }
const MergeNetError = error { Timeout, Refused }
const AllErrors = MergeFileError || MergeNetError

fn doFileErr() MergeFileError!i64 { return error.NotFound }

fn doAllErr() AllErrors!i64 {
    var x = try doFileErr()
    return x
}

test "error set merge" {
    var r = doAllErr() catch 99
    @assertEq(r, 99)
}

// -- inline for --

test "inline for range" {
    var sum: i64 = 0
    inline for i in 0..5 { sum = sum + i }
    @assertEq(sum, 10)
}

test "inline for comptime" {
    var product: i64 = 1
    inline for i in 1..6 { product = product * i }
    @assertEq(product, 120)
}

// -- Runtime safety (bounds check) --

test "bounds check valid" {
    var arr = [10, 20, 30]
    @assertEq(arr[0], 10)
    @assertEq(arr[2], 30)
}

test "null unwrap valid" {
    var x: ?i64 = 42
    @assertEq(x.?, 42)
}

// -- unreachable keyword --

test "unreachable in switch else" {
    var x: i64 = 2
    var result = switch x {
        1 => 10,
        2 => 20,
        3 => 30,
        else => unreachable,
    }
    @assertEq(result, 20)
}

test "unreachable in if branch" {
    var x: i64 = 42
    var result: i64 = 0
    if (x > 0) {
        result = x
    } else {
        unreachable
    }
    @assertEq(result, 42)
}

// ============================================================================
// Default struct field values
// ============================================================================

test "struct default all fields" {
    var c = Config {}
    @assertEq(c.width, 800)
    @assertEq(c.height, 600)
    @assertEq(c.debug, 0)
}

test "struct default override some" {
    var c = Config { .width = 1920 }
    @assertEq(c.width, 1920)
    @assertEq(c.height, 600)
    @assertEq(c.debug, 0)
}

test "struct default override all" {
    var c = Config { .width = 320, .height = 240, .debug = 1 }
    @assertEq(c.width, 320)
    @assertEq(c.height, 240)
    @assertEq(c.debug, 1)
}

test "struct default mixed required and default" {
    var p = Partial { .name = "alice" }
    @assertEq(p.score, 100)
}

test "struct default mixed override default" {
    var p = Partial { .name = "bob", .score = 42 }
    @assertEq(p.score, 42)
}

// ============================================================================
// while (optional) |capture| — Zig pattern
// ============================================================================

struct Iter { pos: i64, limit: i64 }

impl Iter {
    fn next(self: *Iter) ?i64 {
        if (self.pos >= self.limit) {
            return null
        }
        var val = self.pos
        self.pos = self.pos + 1
        return val
    }
}

test "while optional capture" {
    var it = Iter { .pos = 1, .limit = 4 }
    var sum: i64 = 0
    while (it.next()) |val| {
        sum = sum + val
    }
    @assertEq(sum, 6)
}

test "while optional capture no iterations" {
    var it = Iter { .pos = 5, .limit = 3 }
    var sum: i64 = 0
    while (it.next()) |val| {
        sum = sum + val
    }
    @assertEq(sum, 0)
}

// ============================================================================
// while continue expression — Zig pattern: while (cond) : (expr) { ... }
// ============================================================================

test "while continue expression" {
    var i: i64 = 0
    var sum: i64 = 0
    while (i < 5) : (i = i + 1) {
        sum = sum + i
    }
    @assertEq(sum, 10)
    @assertEq(i, 5)
}

// ============================================================================
// Enum methods — impl on enums
// ============================================================================

test "enum method pointer receiver" {
    var lvl = Level.High
    @assertEq(lvl.isHigh(), true)
    @assertEq(lvl.toInt(), 100)
}

test "enum method dispatch" {
    var lvl = Level.Low
    @assertEq(lvl.isHigh(), false)
    @assertEq(lvl.toInt(), 10)
}

// ============================================================================
// Exhaustive switch — compile error on missing variants (Zig/Rust pattern)
// ============================================================================

fn colorToInt(c: Color) i64 {
    return switch (c) {
        Color.Red => 1,
        Color.Green => 2,
        Color.Blue => 3,
    }
}

fn colorWithElse(c: Color) i64 {
    return switch (c) {
        Color.Red => 10,
        else => 0,
    }
}

test "exhaustive switch all variants" {
    var c = Color.Blue
    @assertEq(colorToInt(c), 3)
    var r = Color.Red
    @assertEq(colorToInt(r), 1)
}

test "switch with else branch" {
    var c = Color.Green
    @assertEq(colorWithElse(c), 0)
    var r = Color.Red
    @assertEq(colorWithElse(r), 10)
}

// ============================================================================
// Extern structs (Tier 1.10)
// ============================================================================

// ============================================================================
// Extern structs (Tier 1.10)
// ============================================================================

extern struct CHeader { magic: u32, version: u32 }
extern struct MixedExtern { a: u8, b: u32, c: u8 }
extern struct ExternI64 { x: i64, y: i64 }

test "extern struct layout" {
    @assertEq(@sizeOf(CHeader), 8)
}

test "extern struct mixed alignment" {
    @assertEq(@sizeOf(MixedExtern), 12)
}

test "extern struct i64 field access" {
    var h = ExternI64 { .x = 42, .y = 100 }
    @assertEq(h.x, 42)
    @assertEq(h.y, 100)
}

// ============================================================================
// Packed structs (Tier 1.9)
// ============================================================================

packed struct PackedSmall { a: u8, b: u32, c: u8 }
packed struct PackedTwo { x: i64, y: i64 }

test "packed struct size" {
    @assertEq(@sizeOf(PackedSmall), 6)
}

test "packed struct i64 field access" {
    var p = PackedTwo { .x = 10, .y = 20 }
    @assertEq(p.x, 10)
    @assertEq(p.y, 20)
}

// ============================================================================
// Nested type namespaces (Tier 1.6)
// ============================================================================

struct Lexer {
    const Error = error { UnexpectedToken, EndOfInput }
    pos: i64
}

fn lexerMayFail(x: i64) Lexer.Error!i64 {
    if (x < 0) {
        return error.UnexpectedToken
    }
    return x * 2
}

test "nested error set error value" {
    var e = lexerMayFail(-1) catch 99
    @assertEq(e, 99)
}

test "nested error set success" {
    var e = lexerMayFail(5) catch 0
    @assertEq(e, 10)
}

test "nested type with struct field" {
    var l = Lexer { .pos = 42 }
    @assertEq(l.pos, 42)
}

// ============================================================================
// Chained pointer field access (regression: lowerer must dereference pointer fields)
// ============================================================================

struct InnerState { pos: int, ch: int }
struct OuterState { scanner: *InnerState, value: int }

test "chained pointer field read" {
    var inner = InnerState { .pos = 42, .ch = 65 }
    var outer = OuterState { .scanner = &inner, .value = 99 }
    @assertEq(outer.scanner.pos, 42)
    @assertEq(outer.scanner.ch, 65)
    @assertEq(outer.value, 99)
}

test "chained pointer field write" {
    var inner = InnerState { .pos = 42, .ch = 65 }
    var outer = OuterState { .scanner = &inner, .value = 99 }
    outer.scanner.pos = 100
    @assertEq(outer.scanner.pos, 100)
    @assertEq(inner.pos, 100)
}

test "chained pointer field save restore" {
    var inner = InnerState { .pos = 42, .ch = 65 }
    var outer = OuterState { .scanner = &inner, .value = 99 }
    const saved_pos = outer.scanner.pos
    const saved_ch = outer.scanner.ch
    outer.scanner.pos = 999
    outer.scanner.ch = 90
    @assertEq(outer.scanner.pos, 999)
    outer.scanner.pos = saved_pos
    outer.scanner.ch = saved_ch
    @assertEq(outer.scanner.pos, 42)
    @assertEq(outer.scanner.ch, 65)
}

test "double pointer chain field access" {
    var inner = InnerState { .pos = 42, .ch = 65 }
    var outer = OuterState { .scanner = &inner, .value = 99 }
    const p: *OuterState = &outer
    @assertEq(p.scanner.pos, 42)
    p.scanner.pos = 200
    @assertEq(p.scanner.pos, 200)
    @assertEq(inner.pos, 200)
}

// ============================================================================
// Anonymous struct literals (Tier 1.7)
// ============================================================================

struct AnonPoint { x: i64, y: i64 }

fn makeOrigin() AnonPoint {
    return .{ .x = 0, .y = 0 }
}

test "anonymous struct var init" {
    var p: AnonPoint = .{ .x = 10, .y = 20 }
    @assertEq(p.x, 10)
    @assertEq(p.y, 20)
}

test "anonymous struct return" {
    var p = makeOrigin()
    @assertEq(p.x, 0)
    @assertEq(p.y, 0)
}

// ============================================================================
// Tier 2 Builtins: Self-hosting intrinsics (Zig Sema.zig ports)
// ============================================================================

// --- @intFromEnum / @enumFromInt (Zig Sema.zig:8420) ---

const BuiltinColor = enum { red, green, blue }

test "@intFromEnum" {
    var c = BuiltinColor.green
    @assertEq(@intFromEnum(c), 1)
    @assertEq(@intFromEnum(BuiltinColor.red), 0)
    @assertEq(@intFromEnum(BuiltinColor.blue), 2)
}

test "@enumFromInt" {
    var val = @enumFromInt(BuiltinColor, 2)
    @assertEq(@intFromEnum(val), 2)
}

test "@enumFromInt single-arg with @as" {
    var val = @as(BuiltinColor, @enumFromInt(1))
    @assertEq(@intFromEnum(val), 1)
    @assertEq(@tagName(val), "green")
}

test "@enumFromInt single-arg in expression" {
    var idx: i64 = 0
    var c = @as(BuiltinColor, @enumFromInt(idx))
    @assertEq(@tagName(c), "red")
}

fn acceptColor(c: BuiltinColor) i64 {
    return @intFromEnum(c)
}

fn getBlue() BuiltinColor {
    return @enumFromInt(2)
}

test "@enumFromInt single-arg in function arg" {
    @assertEq(acceptColor(@enumFromInt(2)), 2)
}

test "@enumFromInt single-arg from var type" {
    var c: BuiltinColor = @enumFromInt(0)
    @assertEq(@tagName(c), "red")
}

test "@enumFromInt single-arg from return type" {
    @assertEq(@tagName(getBlue()), "blue")
}

// --- @tagName (Zig Sema.zig:20487) ---

test "@tagName enum" {
    var c = BuiltinColor.green
    @assertEq(@tagName(c), "green")
    @assertEq(@tagName(BuiltinColor.red), "red")
    @assertEq(@tagName(BuiltinColor.blue), "blue")
}

// --- @intFromBool (Zig Sema.zig:20341) ---

test "@intFromBool" {
    @assertEq(@intFromBool(true), 1)
    @assertEq(@intFromBool(false), 0)
    var b = true
    @assertEq(@intFromBool(b), 1)
}

// --- @truncate (Zig Sema.zig:22882) ---

test "@truncate u8" {
    var big: i64 = 258
    var small = @truncate(u8, big)
    @assertEq(small, 2)
}

test "@truncate u16" {
    var big: i64 = 65538
    var small = @truncate(u16, big)
    @assertEq(small, 2)
}

// --- @as (Zig Sema.zig:9659) ---

test "@as explicit coercion" {
    var x = @as(i64, 42)
    @assertEq(x, 42)
}

// --- @offsetOf (Zig Sema.zig:23060) ---

struct OffsetTest { a: i64, b: i64, c: i64 }

test "@offsetOf" {
    @assertEq(@offsetOf(OffsetTest, "a"), 0)
    @assertEq(@offsetOf(OffsetTest, "b"), 8)
    @assertEq(@offsetOf(OffsetTest, "c"), 16)
}

// --- @min / @max (Zig Sema.zig:24678) ---

test "@min" {
    @assertEq(@min(3, 7), 3)
    @assertEq(@min(10, 2), 2)
    @assertEq(@min(5, 5), 5)
}

test "@max" {
    @assertEq(@max(3, 7), 7)
    @assertEq(@max(10, 2), 10)
    @assertEq(@max(5, 5), 5)
}

test "@min @max comptime" {
    const a = @min(10, 20)
    const b = @max(10, 20)
    @assertEq(a, 10)
    @assertEq(b, 20)
}

// --- @constCast / @alignCast (identity ops) ---

test "@constCast identity" {
    var ptr: i64 = 12345
    var result = @constCast(ptr)
    @assertEq(result, 12345)
}

// --- @bitCast (Zig Sema.zig:30554) — integer identity ---

test "@bitCast same-size identity" {
    var x: i64 = 42
    var y = @bitCast(i64, x)
    @assertEq(y, 42)
}

// ============================================================================
// Integer type promotion (Tier 4.1)
// Reference: Zig Sema.zig peerType — wider type wins, untyped materializes
// ============================================================================

test "type promotion: u8 + i64 = i64" {
    var a: u8 = 100
    var b: i64 = 200
    var c = a + b
    @assertEq(c, 300)
}

test "type promotion: u16 + u32 = u32" {
    var a: u16 = 1000
    var b: u32 = 2000
    var c = a + b
    @assertEq(c, 3000)
}

test "type promotion: untyped + u8 = u8" {
    var a: u8 = 10
    var c = a + 5
    @assertEq(c, 15)
}

test "type promotion: i32 * i64 = i64" {
    var a: i32 = 100
    var b: i64 = 200
    var c = a * b
    @assertEq(c, 20000)
}

test "type promotion: u8 - u8 = u8" {
    var a: u8 = 50
    var b: u8 = 30
    var c = a - b
    @assertEq(c, 20)
}

// --- Overflow detection (debug mode, narrow types) ---
// Reference: Zig Sema.zig analyzeArithmetic — add_safe/mul_safe emit
// runtime overflow checks in debug mode. Tests verify valid ops don't trap.

test "overflow: u8 add no overflow" {
    var a: u8 = 100
    var b: u8 = 155
    @assertEq(a + b, 255)
}

test "overflow: u8 sub no overflow" {
    var a: u8 = 200
    var b: u8 = 100
    @assertEq(a - b, 100)
}

test "overflow: u8 mul no overflow" {
    var a: u8 = 15
    var b: u8 = 17
    @assertEq(a * b, 255)
}

test "overflow: u16 add no overflow" {
    var a: u16 = 60000
    var b: u16 = 5535
    @assertEq(a + b, 65535)
}

test "overflow: u32 add no overflow" {
    var a: u32 = 2000000000
    var b: u32 = 1000000000
    @assertEq(a + b, 3000000000)
}

test "overflow: u32 mul no overflow" {
    var a: u32 = 65536
    var b: u32 = 65535
    @assertEq(a * b, 4294901760)
}

// ============================================================================
// Concat operator ++
// ============================================================================

test "string concat ++" {
    var s = "hello" ++ " world"
    @assertEq(s, "hello world")
}

test "array concat ++" {
    var a = [1, 2, 3]
    var b = [4, 5]
    var c = a ++ b
    @assertEq(c[0], 1)
    @assertEq(c[2], 3)
    @assertEq(c[3], 4)
    @assertEq(c[4], 5)
}

// ============================================================================
// String slicing
// ============================================================================

test "string slice basic" {
    var s = "hello world"
    var sub = s[0:5]
    @assertEq(sub, "hello")
}

test "string slice middle" {
    var s = "hello world"
    var sub = s[6:11]
    @assertEq(sub, "world")
}

test "string slice to end" {
    var s = "hello world"
    var sub = s[6:]
    @assertEq(sub, "world")
}

test "string slice from start" {
    var s = "hello world"
    var sub = s[:5]
    @assertEq(sub, "hello")
}

test "string slice full" {
    var s = "hello"
    var sub = s[:]
    @assertEq(sub, "hello")
}

test "string slice length" {
    var s = "hello world"
    var sub = s[0:5]
    @assertEq(@lenOf(sub), 5)
}

// ============================================================================
// Bit manipulation builtins
// ============================================================================

test "ctz basic" {
    @assertEq(@ctz(8), 3)
}

test "ctz power of 2" {
    @assertEq(@ctz(16), 4)
}

test "ctz zero" {
    @assertEq(@ctz(0), 64)
}

test "clz basic" {
    @assertEq(@clz(1), 63)
}

test "clz larger" {
    // 0x8000000000000000 = 1 << 63, clz = 0
    var x: i64 = 1 << 63
    @assertEq(@clz(x), 0)
}

test "clz zero" {
    @assertEq(@clz(0), 64)
}

test "popCount basic" {
    @assertEq(@popCount(7), 3)
}

test "popCount single bit" {
    @assertEq(@popCount(1), 1)
}

test "popCount zero" {
    @assertEq(@popCount(0), 0)
}

test "popCount all bits" {
    // 0xFF = 255, 8 bits set
    @assertEq(@popCount(255), 8)
}

// ============================================================================
// memset_zero function
// ============================================================================

test "memset zeros memory" {
    var buf = alloc(0, 16)
    memset_zero(buf, 16)
    @assertEq(1, 1)
}

// ============================================================================
// isatty function
// ============================================================================

test "isatty on non-tty fd" {
    // fd 99 is not open, so not a tty
    @assertEq(isatty(99), 0)
}

// ============================================================================
// Optional comparison (?T == value)
// ============================================================================

test "optional eq value" {
    var x: ?i64 = 42
    if (x == 42) {
        @assertEq(1, 1)
    } else {
        @assertEq(1, 0)
    }
}

test "optional eq null" {
    var x: ?i64 = null
    if (x == null) {
        @assertEq(1, 1)
    } else {
        @assertEq(1, 0)
    }
}

test "optional neq value" {
    var x: ?i64 = 42
    if (x != 99) {
        @assertEq(1, 1)
    } else {
        @assertEq(1, 0)
    }
}

// ============================================================================
// @floatCast builtin
// ============================================================================

test "floatCast f64 to f32" {
    var x: f64 = 3.14
    var y: f32 = @floatCast(f32, x)
    @assertEq(1, 1)
}

test "floatCast f32 to f64" {
    var x: f32 = 2.5
    var y: f64 = @floatCast(f64, x)
    @assertEq(1, 1)
}

test "floatCast identity f64" {
    var x: f64 = 1.0
    var y: f64 = @floatCast(f64, x)
    @assertEq(1, 1)
}

// ============================================================================
// @intFromFloat — convert float to integer (truncate toward zero)
// ============================================================================

test "intFromFloat positive" {
    var x: f64 = 3.7
    var y = @intFromFloat(x)
    @assertEq(y, 3)
}

test "intFromFloat negative" {
    var x: f64 = -2.9
    var y = @intFromFloat(x)
    @assertEq(y, -2)
}

test "intFromFloat zero" {
    var x: f64 = 0.0
    var y = @intFromFloat(x)
    @assertEq(y, 0)
}

test "intFromFloat whole number" {
    var x: f64 = 42.0
    var y = @intFromFloat(x)
    @assertEq(y, 42)
}

// ============================================================================
// parseInt with radix prefixes (0x, 0b, 0o)
// ============================================================================

test "parseInt hex" {
    @assertEq(parseInt("0xFF"), 255)
}

test "parseInt hex uppercase" {
    @assertEq(parseInt("0XAB"), 171)
}

test "parseInt binary" {
    @assertEq(parseInt("0b1010"), 10)
}

test "parseInt octal" {
    @assertEq(parseInt("0o17"), 15)
}

test "parseInt negative hex" {
    @assertEq(parseInt("-0xFF"), -255)
}

test "parseInt decimal unchanged" {
    @assertEq(parseInt("12345"), 12345)
}

// ============================================================================
// parseFloat — string to f64 conversion
// ============================================================================

test "parseFloat integer" {
    var x = parseFloat("42")
    @assertEq(@intFromFloat(x), 42)
}

test "parseFloat decimal" {
    var x = parseFloat("3.14")
    // 3.14 truncates to 3
    @assertEq(@intFromFloat(x), 3)
}

test "parseFloat negative" {
    var x = parseFloat("-2.5")
    @assertEq(@intFromFloat(x), -2)
}

test "parseFloat exponent" {
    var x = parseFloat("1e3")
    @assertEq(@intFromFloat(x), 1000)
}

// ============================================================================
// parseInt with underscores (scanner stores "1_000" as literal text)
// ============================================================================

test "parseInt underscore decimal" {
    @assertEq(parseInt("1_000_000"), 1000000)
}

test "parseInt underscore hex" {
    @assertEq(parseInt("0xFF_FF"), 65535)
}

test "parseInt underscore binary" {
    @assertEq(parseInt("0b1010_0011"), 163)
}

// ============================================================================
// parseIntOrNull — optional-returning parseInt
// ============================================================================

test "parseIntOrNull valid" {
    if (parseIntOrNull("42")) |val| {
        @assertEq(val, 42)
    } else {
        @assert(false)
    }
}

test "parseIntOrNull zero" {
    if (parseIntOrNull("0")) |val| {
        @assertEq(val, 0)
    } else {
        @assert(false)
    }
}

test "parseIntOrNull invalid" {
    var result = parseIntOrNull("abc")
    @assertEq(result == null, true)
}

test "parseIntOrNull empty" {
    var result = parseIntOrNull("")
    @assertEq(result == null, true)
}

test "parseIntOrNull hex" {
    if (parseIntOrNull("0xFF")) |val| {
        @assertEq(val, 255)
    } else {
        @assert(false)
    }
}

test "parseIntOrNull underscore" {
    if (parseIntOrNull("1_000")) |val| {
        @assertEq(val, 1000)
    } else {
        @assert(false)
    }
}

test "parseIntOrNull negative" {
    if (parseIntOrNull("-42")) |val| {
        @assertEq(val, -42)
    } else {
        @assert(false)
    }
}

// ============================================================================
// Optional compound: tag+payload representation (zero is NOT null)
// ============================================================================

test "optional local zero" {
    var x: ?i64 = 0
    @assert(x != null)
    if (x) |val| {
        @assertEq(val, 0)
    } else {
        @assert(false)
    }
}

test "optional local null" {
    var x: ?i64 = null
    @assertEq(x == null, true)
}

test "optional assign zero" {
    var x: ?i64 = null
    x = 0
    @assert(x != null)
    if (x) |val| {
        @assertEq(val, 0)
    } else {
        @assert(false)
    }
}

test "optional assign null" {
    var x: ?i64 = 42
    @assert(x != null)
    x = null
    @assertEq(x == null, true)
}

test "optional orelse zero" {
    var x: ?i64 = 0
    const val = x orelse 99
    @assertEq(val, 0)
}

test "optional orelse null" {
    var x: ?i64 = null
    @assert((x orelse 99) == 99)
}

// ============================================================================
// @enumLen(T) — comptime enum variant count
// ============================================================================

test "enumLen basic" {
    @assertEq(@enumLen(Color), 3)
}

test "enumLen iterate with enumFromInt" {
    var i: i64 = 0
    var count: i64 = 0
    while (i < @enumLen(Color)) {
        count += 1
        i += 1
    }
    @assertEq(count, 3)
}

// ============================================================================
// Enum shorthand .variant in switch
// ============================================================================

test "enum shorthand in switch" {
    var c = Color.Green
    var result = switch (c) {
        .Red => 1,
        .Green => 2,
        .Blue => 3,
    }
    @assertEq(result, 2)
}

test "enum shorthand multi-pattern" {
    var c = Color.Red
    var result = switch (c) {
        .Red, .Blue => 1,
        .Green => 2,
    }
    @assertEq(result, 1)
}

test "enum shorthand with else" {
    var c = Color.Blue
    var result = switch (c) {
        .Red => 1,
        else => 0,
    }
    @assertEq(result, 0)
}

test "enum shorthand with custom values" {
    var s = Status.Warning
    var result = switch (s) {
        .Ok => 0,
        .Warning => 1,
        .Error => 2,
    }
    @assertEq(result, 1)
}

test "enum shorthand statement form" {
    var c = Color.Blue
    var x: i64 = 0
    switch (c) {
        .Red => { x = 10 },
        .Green => { x = 20 },
        .Blue => { x = 30 },
    }
    @assertEq(x, 30)
}

// ============================================================================
// comptime blocks with statements (Phase 2)
// ============================================================================

test "comptime block with var" {
    const x = comptime {
        var a: i64 = 10
        a = a + 5
        a
    }
    @assertEq(x, 15)
}

test "comptime block multiple vars" {
    const result = comptime {
        var a: i64 = 3
        var b: i64 = 7
        a * b
    }
    @assertEq(result, 21)
}

test "comptime block compound assign" {
    const x = comptime {
        var a: i64 = 10
        a += 5
        a *= 2
        a
    }
    @assertEq(x, 30)
}

// ============================================================================
// @typeName (Phase 3)
// ============================================================================

test "typeName basic types" {
    @assertEq(@typeName(i64), "i64")
    @assertEq(@typeName(bool), "bool")
    @assertEq(@typeName(string), "string")
}

test "typeName enum" {
    @assertEq(@typeName(Color), "Color")
}

// ============================================================================
// @enumName (Phase 3)
// ============================================================================

test "enumName" {
    @assertEq(@enumName(Color, 0), "Red")
    @assertEq(@enumName(Color, 1), "Green")
    @assertEq(@enumName(Color, 2), "Blue")
}

// ============================================================================
// @typeInfo (Phase 4)
// ============================================================================

test "typeInfo enum fields length" {
    const len = @typeInfo(Color).fields.len
    @assertEq(len, 3)
}

test "typeInfo enum name" {
    const name = @typeInfo(Color).name
    @assertEq(name, "Color")
}

test "typeInfo enum field access" {
    @assertEq(@typeInfo(Color).fields[0].name, "Red")
    @assertEq(@typeInfo(Color).fields[0].value, 0)
    @assertEq(@typeInfo(Color).fields[1].name, "Green")
    @assertEq(@typeInfo(Color).fields[2].name, "Blue")
}

// ============================================================================
// inline for over comptime arrays (Phase 5)
// ============================================================================

test "inline for over typeInfo fields count" {
    var count: i64 = 0
    inline for field in @typeInfo(Color).fields {
        count += 1
    }
    @assertEq(count, 3)
}

test "inline for field value sum" {
    var sum: i64 = 0
    inline for field in @typeInfo(Status).fields {
        sum += field.value
    }
    @assertEq(sum, 150)
}

// ============================================================================
// comptime array construction + runtime indexing (Phase 6)
// ============================================================================

test "comptime array inline for construction" {
    const arr = comptime {
        var s: [5]i64 = undefined
        inline for i in 0..5 {
            s[i] = i * i
        }
        s
    }
    @assertEq(arr[0], 0)
    @assertEq(arr[1], 1)
    @assertEq(arr[3], 9)
    @assertEq(arr[4], 16)
}

test "comptime int array dynamic index" {
    const arr = comptime {
        var s: [5]i64 = undefined
        inline for i in 0..5 {
            s[i] = i * i
        }
        s
    }
    var i: i64 = 3
    @assertEq(arr[i], 9)
    i = 4
    @assertEq(arr[i], 16)
}

test "comptime string array from typeInfo" {
    const names = comptime {
        var s: [3]string = undefined
        inline for field in @typeInfo(Color).fields {
            s[field.value] = field.name
        }
        s
    }
    @assertEq(names[0], "Red")
    @assertEq(names[1], "Green")
    @assertEq(names[2], "Blue")
}

// ============================================================================
// Quoted identifiers (@"keyword")
// ============================================================================

const QuotedOp = enum { @"and", @"or", @"not", add }

test "quoted identifier enum variant" {
    @assertEq(@intFromEnum(QuotedOp.@"and"), 0)
    @assertEq(@intFromEnum(QuotedOp.@"or"), 1)
    @assertEq(@intFromEnum(QuotedOp.@"not"), 2)
    @assertEq(@intFromEnum(QuotedOp.add), 3)
}

test "quoted ident in switch" {
    var op = QuotedOp.@"and"
    var result = switch (op) {
        .@"and" => 10,
        .@"or" => 20,
        .@"not" => 30,
        .add => 40,
        else => 0,
    }
    @assertEq(result, 10)
}

test "quoted ident typeInfo name" {
    @assertEq(@typeInfo(QuotedOp).fields[0].name, "and")
    @assertEq(@typeInfo(QuotedOp).fields[1].name, "or")
    @assertEq(@typeInfo(QuotedOp).fields[2].name, "not")
}

// ============================================================================
// Enum backing type — enum(u8) syntax
// ============================================================================

const BackedColor = enum(u8) { Red, Green, Blue }
const BackedStatus = enum(u16) { Ok = 200, NotFound = 404 }

test "enum backing type u8" {
    @assertEq(@intFromEnum(BackedColor.Red), 0)
    @assertEq(@intFromEnum(BackedColor.Blue), 2)
}

test "enum backing type with values" {
    @assertEq(@intFromEnum(BackedStatus.Ok), 200)
    @assertEq(@intFromEnum(BackedStatus.NotFound), 404)
}

// ============================================================================
// String switch expression
// ============================================================================

test "string switch expression" {
    const result = switch ("hello") {
        "hello" => 1,
        "world" => 2,
        else => 0,
    }
    @assertEq(result, 1)
}

test "string switch no match" {
    const result = switch ("unknown") {
        "hello" => 1,
        else => 0,
    }
    @assertEq(result, 0)
}

test "string switch statement" {
    var x: i64 = 0
    var name = "fn"
    switch (name) {
        "fn" => { x = 1 },
        "var" => { x = 2 },
        else => { x = 99 },
    }
    @assertEq(x, 1)
}

test "string switch with variable" {
    var s = "world"
    const r = switch (s) {
        "hello" => 10,
        "world" => 20,
        else => 0,
    }
    @assertEq(r, 20)
}

// ============================================================================
// parseFloatOrNull
// ============================================================================

test "parseFloatOrNull valid integer" {
    const v = parseFloatOrNull("42")
    @assert(v != null)
    if (v) |val| { @assertEq(val, @floatFromInt(f64, 42)) }
}

test "parseFloatOrNull valid decimal" {
    const v = parseFloatOrNull("3.14")
    @assert(v != null)
}

test "parseFloatOrNull negative" {
    const v = parseFloatOrNull("-5.0")
    @assert(v != null)
}

test "parseFloatOrNull invalid" {
    const v = parseFloatOrNull("abc")
    @assert(v == null)
}

test "parseFloatOrNull empty" {
    const v = parseFloatOrNull("")
    @assert(v == null)
}

test "parseFloatOrNull zero" {
    const v = parseFloatOrNull("0")
    @assert(v != null)
    if (v) |val| { @assertEq(val, @floatFromInt(f64, 0)) }
}

test "parseFloatOrNull zero point zero" {
    const v = parseFloatOrNull("0.0")
    @assert(v != null)
}

// ============================================================================
// Compound optional if-expression null path
// ============================================================================

test "if-expr comptime fold null to optional" {
    var x: ?i64 = if (false) { 42 } else { null }
    @assert(x == null)
}

test "if-expr comptime fold value to optional" {
    var x: ?i64 = if (true) { 42 } else { null }
    @assert(x != null)
    if (x) |val| { @assertEq(val, 42) }
}

// ============================================================================
// Block-scoped struct and union declarations
// ============================================================================

test "block_scoped_struct" {
    struct Pair { a: i64, b: i64 }
    const p = Pair { .a = 10, .b = 20 }
    @assertEq(p.a, 10)
    @assertEq(p.b, 20)
}

test "block_scoped_struct_var" {
    struct Counter { value: i64 }
    var c = Counter { .value = 0 }
    c.value = 42
    @assertEq(c.value, 42)
}

test "block_scoped_union" {
    union Shape { circle: i64, rect: i64 }
    var s: Shape = Shape.circle(5)
    @assertEq(s.tag, 0)
    @assertEq(s.circle, 5)
}

test "block_scoped_struct_new" {
    struct Node { value: i64 }
    const n = new Node { value: 99 }
    @assertEq(n.value, 99)
}

test "block_scoped_packed_struct" {
    packed struct Flags { a: i8, b: i8 }
    const f = Flags { .a = 1, .b = 2 }
    @assertEq(f.a, 1)
    @assertEq(f.b, 2)
}

// -- Switch expression tests --

fn switch_returns_int(x: int) int { return x + 1 }
fn switch_returns_void(x: int) void { }

fn switch_void_mixed(tag: int) void {
    switch (tag) {
        0 => { switch_returns_int(10) },
        1 => switch_returns_void(20),
        else => {},
    }
}

test "switch_void_mixed_arms" {
    switch_void_mixed(0)
    switch_void_mixed(1)
    switch_void_mixed(2)
}

fn switch_block_trailing(x: int) int {
    return switch (x) {
        0 => {
            const a = 10
            a + 5
        },
        1 => {
            const b = 20
            b * 2
        },
        else => 0,
    }
}

test "switch_expr_block_trailing" {
    @assertEq(switch_block_trailing(0), 15)
    @assertEq(switch_block_trailing(1), 40)
    @assertEq(switch_block_trailing(2), 0)
}
