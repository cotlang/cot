// Combined native E2E test program — inline test format.
// Each `test "name" { ... }` block runs independently.

import "std/list"

// ============================================================================
// Shared type declarations
// ============================================================================

struct Foo { x: i64 }
struct Bar { y: i64 }
struct Point { x: i64, y: i64 }
type Coord = Point;

enum Color { Red, Green, Blue }
enum Status { Ok = 0, Warning = 50, Error = 100 }
enum Level { Low = 10, Medium = 50, High = 100 }

union State { Init, Running, Done }
union Result { Ok: i64, Err: i32 }
union Event { Click: i64, Hover, KeyPress: i64 }

const MyError = error { Fail, NotFound }

// DFoo: Foo variant with deinit (deinit tests need Foo_deinit but ARC tests must NOT have it)
struct DFoo { x: i64 }
fn DFoo_deinit(self: *DFoo) void { return }

// ============================================================================
// Shared helper functions
// ============================================================================

fn double(x: i64) i64 { return x + x }

fn createFoo(val: i64) *Foo {
    return new Foo { x: val }
}

fn makeFoo(v: i64) *Foo {
    return new Foo { x: v }
}

fn add(a: i64, b: i64) i64 { return a + b }

fn dbl(x: i64) i64 { return x * 2 }

fn apply_fn(f: fn(i64) -> i64, x: i64) i64 {
    return f(x)
}

fn inc(x: i64) i64 { return x + 1 }
fn dec(x: i64) i64 { return x - 1 }

fn mayFail(x: i64) MyError!i64 {
    if x < 0 { return error.Fail }
    return x * 2
}

fn inner() MyError!i64 {
    return error.Fail
}

fn outer() MyError!i64 {
    var x = try inner()
    return x + 1
}

fn createDFoo(val: i64) *DFoo {
    return new DFoo { x: val }
}

// ============================================================================
// Generic type declarations
// ============================================================================

struct Pair(T, U) { first: T, second: U }
struct Box(T) { value: T }
struct BoxC(T) { value: T, count: i64 }
struct Counter(T) { value: T }
struct CounterM(T) { value: T, count: i64 }

// List(T) imported from std/list

// ============================================================================
// Generic helper functions (free function pattern)
// ============================================================================

fn max(T)(a: T, b: T) T {
    if a > b { return a }
    return b
}

fn generic_add(T)(a: T, b: T) T {
    return a + b
}

fn Box_getValue(T)(self: *Box(T)) T {
    return self.value
}

fn getSize(T)() i64 {
    return @sizeOf(T)
}

fn allocOne(T)(value: T) *T {
    var ptr = @intToPtr(*T, @alloc(@sizeOf(T)))
    ptr.* = value
    return ptr
}

fn CounterM_increment(T)(self: *CounterM(T)) void {
    self.count = self.count + 1
}

// List free functions
fn List_ensureCapacity(T)(self: *List(T), needed: i64) void {
    if self.capacity >= needed { return }
    var new_cap: i64 = 8
    if self.capacity > 0 { new_cap = self.capacity * 2 }
    var bytes = new_cap * @sizeOf(T)
    if self.capacity == 0 {
        self.items = @alloc(bytes)
    } else {
        self.items = @realloc(self.items, bytes)
    }
    self.capacity = new_cap
}

fn List_append(T)(self: *List(T), value: T) void {
    List_ensureCapacity(T)(self, self.count + 1)
    var ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
    ptr.* = value
    self.count = self.count + 1
}

fn List_get(T)(self: *List(T), index: i64) T {
    var ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
    return ptr.*
}

fn List_set(T)(self: *List(T), index: i64, value: T) void {
    var ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
    ptr.* = value
}

fn List_pop(T)(self: *List(T)) T {
    self.count = self.count - 1
    var ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
    return ptr.*
}

// ============================================================================
// Generic impl blocks
// ============================================================================

impl Counter(T) {
    fn get(self: *Counter(T)) T {
        return self.value
    }
}

impl BoxC(T) {
    fn getCount(self: *BoxC(T)) i64 {
        return self.count
    }
    fn increment(self: *BoxC(T)) void {
        self.count = self.getCount() + 1
    }
}

impl Box(T) {
    fn get(self: *Box(T)) T {
        return self.value
    }
}

impl Pair(T, U) {
    fn sum(self: *Pair(T, U)) i64 {
        return self.first + self.second
    }
}

// List(T) impl imported from std/list

// ============================================================================
// Tests: Baseline
// ============================================================================

test "baseline" {
    // Constants
    @assert_eq(42, 42)
    @assert_eq(10 + 5, 15)
    @assert_eq(20 - 8, 12)
    @assert_eq(6 * 7, 42)
    @assert_eq(2 + 3 * 4, 14)

    // Variables
    var x = 10
    var y = 5
    @assert_eq(x + y, 15)

    // If/else
    if 10 > 5 {
        var ok = 1
        @assert_eq(ok, 1)
    } else {
        @assert(1 == 0)
    }

    // While loop
    var sum: i64 = 0
    var i: i64 = 1
    while i <= 10 {
        sum = sum + i
        i = i + 1
    }
    @assert_eq(sum, 55)
}

// ============================================================================
// Tests: Phase 3 language features
// ============================================================================

test "phase3" {
    // Char literals
    var c1 = 'A'
    @assert_eq(c1, 65)
    var c2 = '\n'
    @assert_eq(c2, 10)

    // Type alias + struct
    var coord: Coord = Coord { .x = 10, .y = 20 }
    @assert_eq(coord.x + coord.y, 30)

    // Builtins
    @assert_eq(@sizeOf(i64), 8)
    @assert_eq(@sizeOf(Point), 16)
    @assert_eq(@alignOf(i64), 8)
    var big: i64 = 42
    var small = @intCast(i32, big)
    @assert_eq(small, 42)

    // Enums
    var color: i64 = Color.Green
    @assert_eq(color, 1)
    var status: i64 = Status.Error
    @assert_eq(status, 100)

    // Union
    var state: i64 = State.Running
    @assert_eq(state, 1)

    // Bitwise ops
    var a = 255
    var b = 15
    @assert_eq(a & b, 15)
    @assert_eq((240 | 15) - 200, 55)
    @assert_eq((a ^ b) & 255, 240)
    @assert_eq((~0) & 255, 255)
    @assert_eq(1 << 4, 16)
    @assert_eq(64 >> 2, 16)

    // Compound assignment
    var x = 10
    x += 5
    @assert_eq(x, 15)
    x -= 3
    @assert_eq(x, 12)
    x *= 2
    @assert_eq(x, 24)
    var y = 255
    y &= 15
    @assert_eq(y, 15)

    // Optional types
    var opt1: ?i64 = 42
    @assert_eq(opt1.?, 42)
    var opt2: ?i64 = null
    @assert_eq(opt2 ?? 99, 99)
    var opt3: ?i64 = 42
    @assert_eq(opt3 ?? 99, 42)

    // Switch
    var sw1 = switch 2 {
        1 => 10,
        2 => 20,
        3 => 30,
        else => 0,
    }
    @assert_eq(sw1, 20)

    var level = Level.Medium
    var sw2 = switch level {
        Level.Low => 1,
        Level.Medium => 50,
        Level.High => 99,
        else => 0,
    }
    @assert_eq(sw2, 50)
}

// ============================================================================
// Tests: Function call + float
// ============================================================================

test "func_call" {
    @assert_eq(double(10), 20)
}

test "float_locals" {
    var x: f64 = 3.14
    var y: f64 = 0.0
}

// ============================================================================
// Tests: Union payloads
// ============================================================================

test "union_payload" {
    var r: Result = Result.Ok(42)
    @assert_eq(r.tag, 0)
    var val = r.Ok
    @assert_eq(val, 42)
    var e: Result = Result.Err(99)
    @assert_eq(e.tag, 1)
}

test "union_mixed" {
    var e1: Event = Event.Hover
    @assert_eq(e1.tag, 1)
    var e2: Event = Event.Click(100)
    @assert_eq(e2.tag, 0)
    var clicks = e2.Click
    @assert_eq(clicks, 100)
}

test "union_switch_no_capture" {
    var r: Result = Result.Ok(42)
    var matched: i64 = 0
    switch r {
        Result.Ok => { matched = 1 },
        Result.Err => { matched = 2 },
    }
    @assert_eq(matched, 1)
}

test "union_switch_capture" {
    var r: Result = Result.Ok(42)
    var matched: i64 = 0
    var captured: i64 = 0
    switch r {
        Result.Ok |val| => {
            matched = 1
            captured = val
        },
        Result.Err |e| => { matched = 2 },
    }
    @assert_eq(matched, 1)
    @assert_eq(captured, 42)
}

// ============================================================================
// Tests: Error unions
// ============================================================================

test "error_union_catch" {
    var result = mayFail(-1) catch 99
    @assert_eq(result, 99)
    var success = mayFail(5) catch 99
    @assert_eq(success, 10)
}

test "error_union_try" {
    var result = outer() catch 42
    @assert_eq(result, 42)
}

// ============================================================================
// Tests: Defer
// ============================================================================

test "defer_basic" {
    var x: i64 = 10
    defer x = 99
    @assert_eq(x, 10)
}

test "defer_loop_break" {
    var sum: i64 = 0
    var i: i64 = 0
    while i < 5 {
        defer sum = sum + 1
        i = i + 1
        if i == 3 { break }
    }
    @assert_eq(sum, 3)
}

test "defer_lifo" {
    var x: i64 = 2
    defer x = x + 1
    defer x = x * 10
    @assert_eq(x, 2)
}

// ============================================================================
// Tests: ARC
// ============================================================================

test "arc_func_return_new" {
    var p = createFoo(42)
    @assert_eq(p.x, 42)
}

test "arc_copy_local" {
    var p = new Foo { x: 10 }
    var q = p
    @assert_eq(q.x, 10)
}

test "arc_reassignment" {
    var p = new Foo { x: 1 }
    var q = new Foo { x: 2 }
    p = q
    @assert_eq(p.x, 2)
}

test "arc_return_forward" {
    var f = makeFoo(77)
    @assert_eq(f.x, 77)
}

test "arc_dealloc_basic" {
    var p = new Foo { x: 42 }
    @assert_eq(p.x, 42)
}

test "arc_dealloc_multi" {
    var a = makeFoo(10)
    var b = makeFoo(20)
    var c = makeFoo(12)
    @assert_eq(a.x + b.x + c.x, 42)
}

// ============================================================================
// Tests: Builtins (@alloc, @dealloc, @realloc)
// ============================================================================

test "builtin_alloc_dealloc" {
    var ptr = @alloc(8)
    @dealloc(ptr)
}

test "builtin_realloc" {
    var ptr = @alloc(8)
    var ptr2 = @realloc(ptr, 16)
    @dealloc(ptr2)
}

test "freelist_reuse" {
    var p1 = @alloc(8)
    @dealloc(p1)
    var p2 = @alloc(8)
    @dealloc(p2)
    var p3 = @alloc(8)
    @dealloc(p3)
}

// ============================================================================
// Tests: Deinit (uses DFoo with DFoo_deinit)
// ============================================================================

test "deinit_basic" {
    var p = new DFoo { x: 42 }
    @assert_eq(p.x, 42)
}

test "deinit_no_use" {
    var p = new DFoo { x: 42 }
}

test "deinit_mixed" {
    var f = new DFoo { x: 10 }
    var b = new Bar { y: 20 }
    @assert_eq(f.x + b.y, 30)
}

test "deinit_alloc_reuse" {
    var p1 = createDFoo(10)
    var v1 = p1.x
    var p2 = createDFoo(20)
    @assert_eq(v1 + p2.x, 30)
}

// ============================================================================
// Tests: Function pointers
// ============================================================================

test "fnptr_basic" {
    var f = add
    @assert_eq(f(3, 4), 7)
}

test "fnptr_param" {
    @assert_eq(apply_fn(dbl, 5), 10)
}

test "fnptr_reassign" {
    var f = inc
    var a = f(10)
    f = dec
    var b = f(10)
    @assert_eq(a + b, 20)
}

// ============================================================================
// Tests: Closures
// ============================================================================

test "closure_no_capture" {
    var f = fn(x: i64) i64 { return x * 2 }
    @assert_eq(f(21), 42)
}

test "closure_capture" {
    var x: i64 = 10
    var f = fn(y: i64) i64 { return x + y }
    @assert_eq(f(5), 15)
}

test "closure_multi_capture" {
    var a: i64 = 3
    var b: i64 = 7
    var f = fn(x: i64) i64 { return a + b + x }
    @assert_eq(f(10), 20)
}

test "closure_passed" {
    var offset: i64 = 100
    var g = fn(x: i64) i64 { return x + offset }
    @assert_eq(apply_fn(g, 5), 105)
}

// ============================================================================
// Tests: Generics (plain functions)
// ============================================================================

test "generic_fn_basic" {
    @assert_eq(max(i64)(3, 7), 7)
}

test "generic_struct_basic" {
    var p: Pair(i64, i64) = undefined
    p.first = 10
    p.second = 20
    @assert_eq(p.first + p.second, 30)
}

test "generic_fn_multi_inst" {
    var x: i64 = generic_add(i64)(10, 20)
    var y: i32 = generic_add(i32)(3, 4)
    @assert_eq(x + y, 37)
}

test "generic_struct_param" {
    var b: Box(i64) = undefined
    b.value = 42
    @assert_eq(Box_getValue(i64)(&b), 42)
}

test "sizeof_generic" {
    @assert_eq(getSize(i64)(), 8)
}

test "alloc_inttoptr_generic" {
    var p = allocOne(i64)(42)
    var result = p.*
    @dealloc(@ptrToInt(p))
    @assert_eq(result, 42)
}

test "generic_field_mutation" {
    var c: CounterM(i64) = undefined
    c.value = 10
    c.count = 0
    CounterM_increment(i64)(&c)
    CounterM_increment(i64)(&c)
    @assert_eq(c.count, 2)
}

// ============================================================================
// Tests: List(T) free function pattern
// ============================================================================

test "list_basic" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    List_append(i64)(&list, 10)
    List_append(i64)(&list, 20)
    List_append(i64)(&list, 30)
    var a = List_get(i64)(&list, 0)
    var b = List_get(i64)(&list, 1)
    var c = List_get(i64)(&list, 2)
    @assert_eq(a + b + c, 60)
}

test "list_growth" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    var i: i64 = 0
    while i < 20 {
        List_append(i64)(&list, i)
        i = i + 1
    }
    var first = List_get(i64)(&list, 0)
    var last = List_get(i64)(&list, 19)
    @assert_eq(first + last + list.count, 39)
}

test "list_pop" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    List_append(i64)(&list, 10)
    List_append(i64)(&list, 20)
    List_append(i64)(&list, 30)
    var popped = List_pop(i64)(&list)
    @assert_eq(popped + list.count, 32)
}

test "list_set" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    List_append(i64)(&list, 10)
    List_append(i64)(&list, 20)
    List_append(i64)(&list, 30)
    List_set(i64)(&list, 1, 50)
    @assert_eq(List_get(i64)(&list, 0) + List_get(i64)(&list, 1) + List_get(i64)(&list, 2), 90)
}

test "list_multi_type" {
    var a: List(i64) = undefined
    a.items = 0
    a.count = 0
    a.capacity = 0
    var b: List(i32) = undefined
    b.items = 0
    b.count = 0
    b.capacity = 0
    List_append(i64)(&a, 100)
    List_append(i32)(&b, 5)
    var x = List_get(i64)(&a, 0)
    var y: i64 = List_get(i32)(&b, 0)
    @assert_eq(x + y, 105)
}

// ============================================================================
// Tests: List(T) impl pattern (dot-call syntax)
// ============================================================================

test "list_impl_basic" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    list.append(10)
    list.append(20)
    list.append(30)
    var a = list.get(0)
    var b = list.get(1)
    var c = list.get(2)
    @assert_eq(a + b + c, 60)
}

test "list_impl_growth" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    var i: i64 = 0
    while i < 20 {
        list.append(i)
        i = i + 1
    }
    var first = list.get(0)
    var last = list.get(19)
    @assert_eq(first + last + list.count, 39)
}

test "list_impl_pop" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    list.append(10)
    list.append(20)
    list.append(30)
    var popped = list.pop()
    @assert_eq(popped + list.count, 32)
}

test "list_impl_set" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    list.append(10)
    list.append(20)
    list.append(30)
    list.set(1, 50)
    @assert_eq(list.get(0) + list.get(1) + list.get(2), 90)
}

test "list_impl_multi_type" {
    var a: List(i64) = undefined
    a.items = 0
    a.count = 0
    a.capacity = 0
    var b: List(i32) = undefined
    b.items = 0
    b.count = 0
    b.capacity = 0
    a.append(100)
    b.append(5)
    var x = a.get(0)
    var y: i64 = b.get(0)
    @assert_eq(x + y, 105)
}

// ============================================================================
// Tests: Generic impl blocks
// ============================================================================

test "generic_impl_basic" {
    var c: Counter(i64) = undefined
    c.value = 42
    @assert_eq(c.get(), 42)
}

test "generic_impl_self_call" {
    var b: BoxC(i64) = undefined
    b.value = 10
    b.count = 0
    b.increment()
    b.increment()
    b.increment()
    @assert_eq(b.count + b.value, 13)
}

test "generic_impl_multi_inst" {
    var a: Box(i64) = undefined
    a.value = 30
    var b: Box(i32) = undefined
    b.value = 12
    var x: i64 = a.get()
    var y: i64 = b.get()
    @assert_eq(x + y, 42)
}

test "generic_impl_forward_ref" {
    var b: BoxC(i64) = undefined
    b.value = 10
    b.count = 0
    b.increment()
    b.increment()
    @assert_eq(b.count + b.value, 12)
}

test "generic_impl_two_params" {
    var p: Pair(i64, i64) = undefined
    p.first = 30
    p.second = 12
    @assert_eq(p.sum(), 42)
}

// ============================================================================
// Tests: Struct literals, zero init, new for generics
// ============================================================================

test "generic_struct_literal" {
    var p = Pair(i64, i64) { .first = 10, .second = 32 }
    @assert_eq(p.first + p.second, 42)
}

test "generic_struct_literal_methods" {
    var p = Pair(i64, i64) { .first = 30, .second = 12 }
    @assert_eq(p.sum(), 42)
}

test "zero_init_basic" {
    var p: Point = .{}
    @assert_eq(p.x + p.y, 0)
}

test "zero_init_generic" {
    var p: Pair(i64, i64) = .{}
    @assert_eq(p.first + p.second, 0)
}

test "new_generic" {
    var p = new Pair(i64, i64) { first: 30, second: 12 }
    @assert_eq(p.first + p.second, 42)
}

// ============================================================================
// @memcpy builtin
// ============================================================================

test "memcpy_basic" {
    var src = @alloc(24)
    var dst = @alloc(24)
    var p0 = @intToPtr(*i64, src)
    p0.* = 10
    var p1 = @intToPtr(*i64, src + 8)
    p1.* = 20
    var p2 = @intToPtr(*i64, src + 16)
    p2.* = 30
    @memcpy(dst, src, 24)
    var d0 = @intToPtr(*i64, dst)
    var d1 = @intToPtr(*i64, dst + 8)
    var d2 = @intToPtr(*i64, dst + 16)
    @assert_eq(d0.*, 10)
    @assert_eq(d1.*, 20)
    @assert_eq(d2.*, 30)
    @dealloc(src)
    @dealloc(dst)
}

test "memcpy_zero_length" {
    var buf = @alloc(8)
    @intToPtr(*i64, buf).* = 42
    @memcpy(buf, buf, 0)
    @assert_eq(@intToPtr(*i64, buf).*, 42)
    @dealloc(buf)
}

// ============================================================================
// @trap builtin
// ============================================================================

test "trap_not_reached" {
    var x: i64 = 42
    if x == 0 { @trap() }
}

// ============================================================================
// Slice parameter passing
// ============================================================================

fn get_slice_len(items: []i64) i64 {
    return items.len
}

fn slice_sum(items: []i64) i64 {
    var total: i64 = 0
    var i: i64 = 0
    while i < items.len {
        total = total + items[i]
        i = i + 1
    }
    return total
}

test "slice_param_basic" {
    var arr = [10, 20, 30]
    var s = arr[0:3]
    @assert_eq(get_slice_len(s), 3)
}

test "slice_param_iteration" {
    var arr = [10, 20, 30, 40, 50]
    var s = arr[1:4]
    @assert_eq(slice_sum(s), 90)
}

// ============================================================================
// Traits
// ============================================================================

trait Greetable {
    fn greet(self: *Self) i64
}

struct TraitDog { age: i64 }

impl Greetable for TraitDog {
    fn greet(self: *TraitDog) i64 {
        return self.age
    }
}

test "trait_basic" {
    var d = TraitDog { .age = 42 }
    @assert_eq(d.greet(), 42)
}

trait Doubled {
    fn doubled(self: *Self) i64
}

impl Doubled for i64 {
    fn doubled(self: *i64) i64 {
        return self.* * 2
    }
}

test "trait_primitive" {
    var x: i64 = 21
    @assert_eq(x.doubled(), 42)
}

trait HasValue {
    fn value(self: *Self) i64
}

struct TraitCat { lives: i64 }

impl HasValue for TraitCat {
    fn value(self: *TraitCat) i64 {
        return self.lives
    }
}

impl HasValue for TraitDog {
    fn value(self: *TraitDog) i64 {
        return self.age
    }
}

test "trait_multi_impl" {
    var c = TraitCat { .lives = 9 }
    var d = TraitDog { .age = 3 }
    @assert_eq(c.value() + d.value(), 12)
}

fn extractValue(T)(item: *T) i64 {
    return item.value()
}

test "trait_generic_usage" {
    var b = TraitCat { .lives = 99 }
    @assert_eq(extractValue(TraitCat)(&b), 99)
}

trait TraitEq {
    fn eq(self: *Self, other: *Self) i64
}

struct TraitPoint { x: i64, y: i64 }

impl TraitEq for TraitPoint {
    fn eq(self: *TraitPoint, other: *TraitPoint) i64 {
        if self.x == other.x {
            if self.y == other.y {
                return 1
            }
        }
        return 0
    }
}

test "trait_self_type" {
    var a = TraitPoint { .x = 3, .y = 4 }
    var b = TraitPoint { .x = 3, .y = 4 }
    var c = TraitPoint { .x = 1, .y = 2 }
    @assert_eq(a.eq(&b), 1)
    @assert_eq(a.eq(&c), 0)
}

// ============================================================================
// Wave 2: Const evaluation
// ============================================================================

const CE_SIZE: i64 = 8
const CE_DOUBLE: i64 = CE_SIZE * 2
const CE_TRIPLE: i64 = CE_SIZE + CE_SIZE + CE_SIZE

test "const_eval_arithmetic" {
    // Go: cmd/compile/internal/ir/const.go — const folding chains
    @assert_eq(CE_DOUBLE, 16)
    @assert_eq(CE_TRIPLE, 24)
    @assert_eq(CE_DOUBLE + CE_TRIPLE, 40)
}

struct CEPoint { x: i64, y: i64 }
const CE_POINT_SIZE: i64 = @sizeOf(CEPoint)
const CE_I64_SIZE: i64 = @sizeOf(i64)

test "const_eval_sizeof" {
    // Zig: @sizeOf resolved at comptime. Go: unsafe.Sizeof is const-foldable.
    @assert_eq(CE_I64_SIZE, 8)
    @assert_eq(CE_POINT_SIZE, 16)
    @assert_eq(CE_POINT_SIZE + CE_I64_SIZE, 24)
}

// ============================================================================
// Wave 2: Trait bounds
// ============================================================================

trait BComparable {
    fn bcmp(self: *Self, other: *Self) i64
}

impl BComparable for i64 {
    fn bcmp(self: *i64, other: *i64) i64 {
        if self.* > other.* { return 1 }
        if self.* < other.* { return 0 - 1 }
        return 0
    }
}

fn bounded_max(T)(a: T, b: T) T where T: BComparable {
    var x = a
    var y = b
    if x.bcmp(&y) > 0 { return a }
    return b
}

test "trait_bound_basic" {
    // Rust: fn max<T: Ord>(a: T, b: T) -> T
    // Go 1.18: func Max[T constraints.Ordered](a, b T) T
    @assert_eq(bounded_max(i64)(10, 20), 20)
    @assert_eq(bounded_max(i64)(30, 5), 30)
}

trait BAddable {
    fn bval(self: *Self) i64
}

impl BAddable for i64 {
    fn bval(self: *i64) i64 { return self.* }
}

fn bounded_sum(T)(a: T, b: T) i64 where T: BAddable {
    var x = a
    var y = b
    return x.bval() + y.bval()
}

test "trait_bound_multi" {
    @assert_eq(bounded_sum(i64)(10, 32), 42)
}

// ============================================================================
// Wave 2: Match expressions (wildcards, guards, ranges)
// ============================================================================

fn match_classify_wildcard(x: i64) i64 {
    return switch x {
        1 => 10,
        2 => 20,
        _ => 99,
    }
}

test "match_wildcard" {
    // Zig: _ in switch covers all remaining values. Rust: _ in match is catch-all.
    @assert_eq(match_classify_wildcard(1), 10)
    @assert_eq(match_classify_wildcard(2), 20)
    @assert_eq(match_classify_wildcard(42), 99)
    @assert_eq(match_classify_wildcard(0), 99)
}

fn match_classify_guard(x: i64) i64 {
    return switch x {
        1 if x > 0 => 10,
        2 => 20,
        _ => 0,
    }
}

test "match_guard" {
    // Rust: match x { n if n > 10 => "big", _ => "small" }
    @assert_eq(match_classify_guard(1), 10)
    @assert_eq(match_classify_guard(2), 20)
    @assert_eq(match_classify_guard(99), 0)
}

fn match_classify_range(x: i64) i64 {
    return switch x {
        1..5 => 1,
        6..10 => 2,
        _ => 3,
    }
}

test "match_range" {
    // Zig: 1...10 (inclusive). Rust: 1..=10. Cot: 1..10 (inclusive).
    @assert_eq(match_classify_range(1), 1)
    @assert_eq(match_classify_range(3), 1)
    @assert_eq(match_classify_range(5), 1)
    @assert_eq(match_classify_range(6), 2)
    @assert_eq(match_classify_range(10), 2)
    @assert_eq(match_classify_range(0), 3)
    @assert_eq(match_classify_range(11), 3)
}

// ============================================================================
// Wave 2: Tuple types
// ============================================================================

test "tuple_basic" {
    var t = (10, 20)
    @assert_eq(t.0, 10)
    @assert_eq(t.1, 20)
    @assert_eq(t.0 + t.1, 30)
}

test "tuple_nested" {
    var a = (1, 2)
    var b = (3, 4)
    @assert_eq(a.0 + a.1 + b.0 + b.1, 10)
}

test "tuple_three" {
    var t = (100, 200, 300)
    @assert_eq(t.0 + t.1 + t.2, 600)
}

// ============================================================================
// SRET: Function returns for multi-word types
// ============================================================================

fn make_pair() (i64, i64) {
    return (10, 20)
}

test "sret_tuple_return" {
    var p = make_pair()
    @assert_eq(p.0, 10)
    @assert_eq(p.1, 20)
    @assert_eq(p.0 + p.1, 30)
}

fn make_point() Point {
    return Point { .x = 10, .y = 20 }
}

test "sret_struct_return" {
    var p = make_point()
    @assert_eq(p.x, 10)
    @assert_eq(p.y, 20)
    @assert_eq(p.x + p.y, 30)
}

fn double_pair() (i64, i64) {
    var p = make_pair()
    return (p.0 * 2, p.1 * 2)
}

test "sret_chain" {
    var d = double_pair()
    @assert_eq(d.0, 20)
    @assert_eq(d.1, 40)
    @assert_eq(d.0 + d.1, 60)
}

// ============================================================================
// Tests: Production List(T) — bounds, growth, deinit, insert, remove
// ============================================================================

test "list_bounds_get" {
    // Verify valid boundary indices work (can't test traps from within same program)
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    // get(0) and get(count-1) must succeed
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(2), 30)
    // set boundary
    list.set(0, 99)
    @assert_eq(list.get(0), 99)
    list.set(2, 88)
    @assert_eq(list.get(2), 88)
    list.free()
}

test "list_growth_go" {
    // Go's nextslicecap: 2x for cap<256, ~1.25x for larger
    var list: List(i64) = .{}
    var i: i64 = 0
    while i < 300 {
        list.append(i)
        i = i + 1
    }
    @assert_eq(list.len(), 300)
    // Verify first and last elements survive growth
    @assert_eq(list.get(0), 0)
    @assert_eq(list.get(299), 299)
    // After 256 elements, growth should be ~1.25x, so capacity < 512 (which 2x would give)
    // With Go's formula: after 256, next cap = 256 + (256+768)/4 = 256 + 256 = 512
    // Then 512 is enough for 300, so cap should be 512
    // But the key test: capacity >= 300 and the data is correct
    @assert(list.cap() >= 300)
    list.free()
}

test "list_free" {
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.free()
    @assert_eq(list.count, 0)
    @assert_eq(list.capacity, 0)
    @assert_eq(list.items, 0)
}

test "list_clear" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    var cap_before = list.cap()
    list.clear()
    @assert_eq(list.len(), 0)
    // Capacity retained after clear
    @assert_eq(list.cap(), cap_before)
    // Can reuse after clear
    list.append(99)
    @assert_eq(list.get(0), 99)
    list.free()
}

test "list_insert" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(30)
    list.append(40)
    // Insert at beginning
    list.insert(0, 5)
    // Insert in middle (between 10 and 30)
    list.insert(2, 20)
    // Insert at end
    list.insert(5, 50)
    // Expected: [5, 10, 20, 30, 40, 50]
    @assert_eq(list.len(), 6)
    @assert_eq(list.get(0), 5)
    @assert_eq(list.get(1), 10)
    @assert_eq(list.get(2), 20)
    @assert_eq(list.get(3), 30)
    @assert_eq(list.get(4), 40)
    @assert_eq(list.get(5), 50)
    list.free()
}

test "list_ordered_remove" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(40)
    list.append(50)
    // Remove from beginning
    var first = list.orderedRemove(0)
    @assert_eq(first, 10)
    // Now: [20, 30, 40, 50]
    @assert_eq(list.len(), 4)
    @assert_eq(list.get(0), 20)
    // Remove from middle
    var mid = list.orderedRemove(1)
    @assert_eq(mid, 30)
    // Now: [20, 40, 50]
    @assert_eq(list.len(), 3)
    @assert_eq(list.get(0), 20)
    @assert_eq(list.get(1), 40)
    @assert_eq(list.get(2), 50)
    list.free()
}

test "list_swap_remove" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(40)
    // SwapRemove index 1 (value 20): last element (40) moves to index 1
    var removed = list.swapRemove(1)
    @assert_eq(removed, 20)
    // Now: [10, 40, 30]
    @assert_eq(list.len(), 3)
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(1), 40)
    @assert_eq(list.get(2), 30)
    // SwapRemove last element (no swap needed)
    var last = list.swapRemove(2)
    @assert_eq(last, 30)
    @assert_eq(list.len(), 2)
    list.free()
}

test "list_reverse" {
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.append(4)
    list.append(5)
    list.reverse()
    @assert_eq(list.get(0), 5)
    @assert_eq(list.get(1), 4)
    @assert_eq(list.get(2), 3)
    @assert_eq(list.get(3), 2)
    @assert_eq(list.get(4), 1)
    list.free()
}

test "list_clone" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    var copy = list.clone()
    // Verify clone has same data
    @assert_eq(copy.len(), 3)
    @assert_eq(copy.get(0), 10)
    @assert_eq(copy.get(1), 20)
    @assert_eq(copy.get(2), 30)
    // Mutate original, verify clone unaffected
    list.set(0, 99)
    @assert_eq(copy.get(0), 10)
    list.free()
    copy.free()
}

test "list_last" {
    var list: List(i64) = .{}
    list.append(10)
    @assert_eq(list.last(), 10)
    list.append(20)
    @assert_eq(list.last(), 20)
    list.append(30)
    @assert_eq(list.last(), 30)
    var popped = list.pop()
    @assert_eq(list.last(), 20)
    list.free()
}

test "memcpy_overlap" {
    // Test overlapping @memcpy (memmove semantics) — used by insert/orderedRemove
    var buf = @alloc(40)
    // Write [10, 20, 30, 40, 50] at positions 0-4
    @intToPtr(*i64, buf).* = 10
    @intToPtr(*i64, buf + 8).* = 20
    @intToPtr(*i64, buf + 16).* = 30
    @intToPtr(*i64, buf + 24).* = 40
    @intToPtr(*i64, buf + 32).* = 0
    // Shift right: copy [0..3] to [1..4] (dst > src, backward copy path)
    @memcpy(buf + 8, buf, 32)
    // Expected: [10, 10, 20, 30, 40]
    @assert_eq(@intToPtr(*i64, buf).*, 10)
    @assert_eq(@intToPtr(*i64, buf + 8).*, 10)
    @assert_eq(@intToPtr(*i64, buf + 16).*, 20)
    @assert_eq(@intToPtr(*i64, buf + 24).*, 30)
    @assert_eq(@intToPtr(*i64, buf + 32).*, 40)
    @dealloc(buf)
}

// ============================================================================
// Tests: List(T) Tier 1+2 — search, resize, bulk ops, compact
// ============================================================================

test "list_contains" {
    // Go: slices.Contains — linear scan
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    @assert_eq(list.contains(20), 1)
    @assert_eq(list.contains(99), 0)
    @assert_eq(list.contains(10), 1)
    @assert_eq(list.contains(30), 1)
    list.free()
}

test "list_index_of" {
    // Go: slices.Index — return index or -1
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(20)
    @assert_eq(list.indexOf(10), 0)
    @assert_eq(list.indexOf(20), 1)
    @assert_eq(list.indexOf(30), 2)
    @assert_eq(list.indexOf(99), 0 - 1)
    list.free()
}

test "list_equal" {
    // Go: slices.Equal — element-wise comparison
    var a: List(i64) = .{}
    a.append(1)
    a.append(2)
    a.append(3)
    var b: List(i64) = .{}
    b.append(1)
    b.append(2)
    b.append(3)
    @assert_eq(a.equal(&b), 1)
    // Different length
    b.append(4)
    @assert_eq(a.equal(&b), 0)
    // Same length, different content
    var c: List(i64) = .{}
    c.append(1)
    c.append(99)
    c.append(3)
    @assert_eq(a.equal(&c), 0)
    a.free()
    b.free()
    c.free()
}

test "list_first" {
    var list: List(i64) = .{}
    list.append(42)
    list.append(99)
    @assert_eq(list.first(), 42)
    list.insert(0, 7)
    @assert_eq(list.first(), 7)
    list.free()
}

test "list_resize" {
    // Zig: resize — grow (undefined elements) or shrink
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    // Shrink
    list.resize(2)
    @assert_eq(list.len(), 2)
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(1), 20)
    // Grow (new elements undefined, but count changes)
    list.resize(5)
    @assert_eq(list.len(), 5)
    // Original elements preserved
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(1), 20)
    // Can write to new slots
    list.set(2, 30)
    list.set(3, 40)
    list.set(4, 50)
    @assert_eq(list.get(4), 50)
    list.free()
}

test "list_append_n_times" {
    // Zig: appendNTimes — fill with value
    var list: List(i64) = .{}
    list.appendNTimes(42, 5)
    @assert_eq(list.len(), 5)
    @assert_eq(list.get(0), 42)
    @assert_eq(list.get(4), 42)
    // Append more
    list.appendNTimes(0, 3)
    @assert_eq(list.len(), 8)
    @assert_eq(list.get(5), 0)
    @assert_eq(list.get(7), 0)
    list.free()
}

test "list_insert_slice" {
    // Zig: insertSlice — bulk insert at position
    var list: List(i64) = .{}
    list.append(1)
    list.append(5)
    // Prepare source buffer [2, 3, 4]
    var src = @alloc(24)
    @intToPtr(*i64, src).* = 2
    @intToPtr(*i64, src + 8).* = 3
    @intToPtr(*i64, src + 16).* = 4
    // Insert at index 1: [1, 2, 3, 4, 5]
    list.insertSlice(1, src, 3)
    @dealloc(src)
    @assert_eq(list.len(), 5)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 2)
    @assert_eq(list.get(2), 3)
    @assert_eq(list.get(3), 4)
    @assert_eq(list.get(4), 5)
    list.free()
}

test "list_replace_range" {
    // Zig: replaceRange / Go: slices.Replace
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.append(4)
    list.append(5)
    // Replace [1..3) (elements 2,3) with [20, 30, 40] — growing
    var src1 = @alloc(24)
    @intToPtr(*i64, src1).* = 20
    @intToPtr(*i64, src1 + 8).* = 30
    @intToPtr(*i64, src1 + 16).* = 40
    list.replaceRange(1, 2, src1, 3)
    @dealloc(src1)
    // Expected: [1, 20, 30, 40, 4, 5]
    @assert_eq(list.len(), 6)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 20)
    @assert_eq(list.get(2), 30)
    @assert_eq(list.get(3), 40)
    @assert_eq(list.get(4), 4)
    @assert_eq(list.get(5), 5)
    // Replace [1..4) (elements 20,30,40) with [99] — shrinking
    var src2 = @alloc(8)
    @intToPtr(*i64, src2).* = 99
    list.replaceRange(1, 3, src2, 1)
    @dealloc(src2)
    // Expected: [1, 99, 4, 5]
    @assert_eq(list.len(), 4)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 99)
    @assert_eq(list.get(2), 4)
    @assert_eq(list.get(3), 5)
    list.free()
}

test "list_shrink_and_free" {
    // Zig: shrinkAndFree — reduce length and realloc
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(40)
    list.append(50)
    var old_cap = list.cap()
    list.shrinkAndFree(3)
    @assert_eq(list.len(), 3)
    @assert_eq(list.cap(), 3)
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(1), 20)
    @assert_eq(list.get(2), 30)
    // Shrink to 0 frees everything
    list.shrinkAndFree(0)
    @assert_eq(list.count, 0)
    @assert_eq(list.capacity, 0)
}

test "list_delete_range" {
    // Go: slices.Delete(s, i, j) — remove [start, end)
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.append(4)
    list.append(5)
    // Delete [1, 3) — remove elements 2, 3
    list.deleteRange(1, 3)
    // Expected: [1, 4, 5]
    @assert_eq(list.len(), 3)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 4)
    @assert_eq(list.get(2), 5)
    // Delete [0, 1) — remove first element
    list.deleteRange(0, 1)
    // Expected: [4, 5]
    @assert_eq(list.len(), 2)
    @assert_eq(list.get(0), 4)
    list.free()
}

test "list_ensure_unused" {
    // Zig: ensureUnusedCapacity
    var list: List(i64) = .{}
    list.append(1)
    list.ensureUnusedCapacity(100)
    @assert(list.cap() >= 101)
    @assert_eq(list.len(), 1)
    @assert_eq(list.get(0), 1)
    list.free()
}

test "list_is_empty" {
    var list: List(i64) = .{}
    @assert_eq(list.isEmpty(), 1)
    list.append(42)
    @assert_eq(list.isEmpty(), 0)
    list.pop()
    @assert_eq(list.isEmpty(), 1)
}

test "list_compact" {
    // Go: slices.Compact — remove consecutive duplicates
    var list: List(i64) = .{}
    list.append(1)
    list.append(1)
    list.append(2)
    list.append(2)
    list.append(2)
    list.append(3)
    list.append(1)
    list.append(1)
    list.compact()
    // Expected: [1, 2, 3, 1]
    @assert_eq(list.len(), 4)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 2)
    @assert_eq(list.get(2), 3)
    @assert_eq(list.get(3), 1)
    list.free()
}

// ============================================================================
// Comptime target builtins
// ============================================================================

test "target_os returns string" {
    var os = @target_os()
    var len = @lenOf(os)
    @assert(len > 0)
}

test "target_arch returns string" {
    var arch = @target_arch()
    var len = @lenOf(arch)
    @assert(len > 0)
}

test "target returns string" {
    var t = @target()
    var len = @lenOf(t)
    @assert(len > 0)
}

test "comptime if folds integer" {
    const val: i64 = if 1 == 1 { 42 } else { 99 }
    @assert_eq(val, 42)
}

test "comptime if folds else branch" {
    const val: i64 = if 1 == 2 { 42 } else { 99 }
    @assert_eq(val, 99)
}

test "comptime if target_os string compare" {
    const flag: i64 = if @target_os() == "linux" { 64 } else { 512 }
    // On macOS this should be 512, on linux 64
    @assert(flag > 0)
}

test "comptime if target_os neq" {
    const flag: i64 = if @target_os() != "nonexistent_os" { 1 } else { 0 }
    @assert_eq(flag, 1)
}

// ============================================================================
// Tests: @string builtin — construct string from raw (ptr, len)
// ============================================================================

test "string builtin constructs from ptr and len" {
    var s = "hello"
    var ptr = @ptrOf(s)
    var len = @lenOf(s)
    var s2 = @string(ptr, len)
    @assert_eq(@lenOf(s2), 5)
}

test "string builtin roundtrip" {
    var s = "world"
    var s2 = @string(@ptrOf(s), @lenOf(s))
    @assert(s == s2)
}

// ============================================================
// comptime blocks and @compileError
// ============================================================

test "comptime block evaluates simple expression" {
    const x = comptime { 40 + 2 }
    @assert_eq(x, 42)
}

test "comptime block with nested arithmetic" {
    const y = comptime { 10 * 3 + 7 }
    @assert_eq(y, 37)
}

test "comptime block used in expression" {
    var a = 10 + comptime { 5 * 6 }
    @assert_eq(a, 40)
}

test "compileError in dead branch is not triggered" {
    const mode = 1
    if mode == 1 {
        @assert(true)
    } else {
        @compileError("this should never be reached")
    }
}

test "compileError in dead else with target check" {
    if @target_os() == "macos" {
        @assert(true)
    } else if @target_os() == "linux" {
        @assert(true)
    } else if @target_os() == "freestanding" {
        @assert(true)
    } else if @target_os() == "wasi" {
        @assert(true)
    } else {
        @compileError("unsupported OS")
    }
}

// ============================================================================
// Auto-deref (pointer.field auto-inserts pointer.*.field)
// ============================================================================

test "auto-deref struct field read" {
    var p = new Point { x: 10, y: 20 }
    @assert_eq(p.x, 10)
    @assert_eq(p.y, 20)
}

test "auto-deref struct field write" {
    var p = new Point { x: 0, y: 0 }
    p.x = 42
    p.y = 99
    @assert_eq(p.x, 42)
    @assert_eq(p.y, 99)
}

test "auto-deref method call" {
    var b = new Box(i64) { value: 77 }
    @assert_eq(b.get(), 77)
}

test "auto-deref explicit deref still works" {
    var p = new Foo { x: 5 }
    @assert_eq(p.*.x, 5)
    @assert_eq(p.x, 5)
}

test "auto-deref compound assignment" {
    var p = new Point { x: 10, y: 20 }
    p.x = p.x + 5
    @assert_eq(p.x, 15)
}

test "auto-deref returned pointer" {
    var f = createFoo(33)
    @assert_eq(f.x, 33)
}

// --- String compound reassignment ---

fn getGreeting() string {
    return "hello world"
}

test "string reassignment from function call" {
    var s = ""
    s = getGreeting()
    @assert_eq(@lenOf(s), 11)
    @assert_eq(s, "hello world")
}

test "string reassignment preserves length" {
    var s = "short"
    @assert_eq(@lenOf(s), 5)
    s = "a longer string"
    @assert_eq(@lenOf(s), 15)
    @assert_eq(s, "a longer string")
}

test "string conditional reassignment" {
    var s = ""
    var flag: i64 = 1
    if flag == 1 {
        s = "yes"
    }
    @assert_eq(s, "yes")
    @assert_eq(@lenOf(s), 3)
}

test "while not done" {
    var done = false
    var count: i64 = 0
    while not done {
        count = count + 1
        if count == 5 {
            done = true
        }
    }
    @assert_eq(count, 5)
}

test "not operator on bool" {
    var x = true
    var y = not x
    @assert_eq(y, 0)
    var z = not false
    @assert_eq(z, 1)
}
