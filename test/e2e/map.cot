// Map(K, V) end-to-end tests.
// Tests hash map operations: set, get, delete, has, grow, tombstones, keys/values.

import "std/map"
import "std/list"

test "map_set_and_get" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    @assertEq(m.get(1), 100)
    m.free()
}

test "map_update_existing" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    m.set(1, 200)
    @assertEq(m.get(1), 200)
    @assertEq(m.len(), 1)
    m.free()
}

test "map_has" {
    var m: Map(i64, i64) = .{}
    m.set(42, 99)
    @assertEq(m.has(42), 1)
    @assertEq(m.has(99), 0)
    m.free()
}

test "map_delete" {
    var m: Map(i64, i64) = .{}
    m.set(1, 10)
    m.set(2, 20)
    m.delete(1)
    @assertEq(m.has(1), 0)
    @assertEq(m.has(2), 1)
    @assertEq(m.get(2), 20)
    @assertEq(m.len(), 1)
    m.free()
}

test "map_get_or_default" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    @assertEq(m.getOrDefault(1, 0), 100)
    @assertEq(m.getOrDefault(999, 42), 42)
    m.free()
}

test "map_multiple_entries" {
    var m: Map(i64, i64) = .{}
    var i: i64 = 0
    while (i < 10) {
        m.set(i, i * 10)
        i = i + 1
    }
    @assertEq(m.len(), 10)
    i = 0
    while (i < 10) {
        @assertEq(m.get(i), i * 10)
        i = i + 1
    }
    m.free()
}

test "map_collision_handling" {
    // Keys 0 and 8 both hash to same bucket in capacity-8 table
    // (hash(0)&7 and hash(8)&7 may differ, but with enough keys collisions happen)
    var m: Map(i64, i64) = .{}
    m.set(0, 100)
    m.set(8, 200)
    m.set(16, 300)
    @assertEq(m.get(0), 100)
    @assertEq(m.get(8), 200)
    @assertEq(m.get(16), 300)
    m.free()
}

test "map_grow" {
    // Initial capacity is 8, 75% load = 6. Insert 7+ to trigger growth.
    var m: Map(i64, i64) = .{}
    var i: i64 = 0
    while (i < 20) {
        m.set(i, i * 100)
        i = i + 1
    }
    @assertEq(m.len(), 20)
    i = 0
    while (i < 20) {
        @assertEq(m.get(i), i * 100)
        i = i + 1
    }
    m.free()
}

test "map_delete_and_reinsert" {
    var m: Map(i64, i64) = .{}
    m.set(5, 50)
    m.delete(5)
    @assertEq(m.has(5), 0)
    m.set(5, 500)
    @assertEq(m.has(5), 1)
    @assertEq(m.get(5), 500)
    @assertEq(m.len(), 1)
    m.free()
}

test "map_tombstone_reuse" {
    var m: Map(i64, i64) = .{}
    m.set(1, 10)
    m.set(2, 20)
    m.set(3, 30)
    m.delete(2)
    // Insert new key â€” should work correctly even with tombstone in probe chain
    m.set(4, 40)
    @assertEq(m.has(1), 1)
    @assertEq(m.has(2), 0)
    @assertEq(m.has(3), 1)
    @assertEq(m.has(4), 1)
    @assertEq(m.get(1), 10)
    @assertEq(m.get(3), 30)
    @assertEq(m.get(4), 40)
    m.free()
}

test "map_clear" {
    var m: Map(i64, i64) = .{}
    m.set(1, 10)
    m.set(2, 20)
    m.set(3, 30)
    m.clear()
    @assertEq(m.len(), 0)
    @assertEq(m.has(1), 0)
    @assertEq(m.has(2), 0)
    // Can reuse after clear
    m.set(4, 40)
    @assertEq(m.get(4), 40)
    @assertEq(m.len(), 1)
    m.free()
}

test "map_keys_and_values" {
    var m: Map(i64, i64) = .{}
    m.set(10, 100)
    m.set(20, 200)
    m.set(30, 300)
    var k = m.keys()
    var v = m.values()
    @assertEq(k.len(), 3)
    @assertEq(v.len(), 3)
    // Keys and values are in hash table order, so check all 3 are present
    @assertEq(k.contains(10), 1)
    @assertEq(k.contains(20), 1)
    @assertEq(k.contains(30), 1)
    @assertEq(v.contains(100), 1)
    @assertEq(v.contains(200), 1)
    @assertEq(v.contains(300), 1)
    k.free()
    v.free()
    m.free()
}

test "map_empty" {
    var m: Map(i64, i64) = .{}
    @assertEq(m.isEmpty(), 1)
    m.set(1, 10)
    @assertEq(m.isEmpty(), 0)
    m.delete(1)
    @assertEq(m.isEmpty(), 1)
    m.free()
}

test "map_len" {
    var m: Map(i64, i64) = .{}
    @assertEq(m.len(), 0)
    m.set(1, 10)
    @assertEq(m.len(), 1)
    m.set(2, 20)
    @assertEq(m.len(), 2)
    m.set(1, 99)
    @assertEq(m.len(), 2)
    m.delete(1)
    @assertEq(m.len(), 1)
    m.free()
}

test "map_large" {
    var m: Map(i64, i64) = .{}
    var i: i64 = 0
    while (i < 100) {
        m.set(i, i * i)
        i = i + 1
    }
    @assertEq(m.len(), 100)
    i = 0
    while (i < 100) {
        @assertEq(m.get(i), i * i)
        i = i + 1
    }
    m.free()
}

test "map_free" {
    var m: Map(i64, i64) = .{}
    m.set(1, 10)
    m.set(2, 20)
    m.free()
    @assertEq(m.len(), 0)
    @assertEq(m.capacity, 0)
    // Can reinitialize after free
    m.set(3, 30)
    @assertEq(m.get(3), 30)
    m.free()
}

test "map_negative_keys" {
    var m: Map(i64, i64) = .{}
    m.set(0 - 1, 10)
    m.set(0 - 100, 20)
    m.set(0 - 999, 30)
    @assertEq(m.get(0 - 1), 10)
    @assertEq(m.get(0 - 100), 20)
    @assertEq(m.get(0 - 999), 30)
    @assertEq(m.len(), 3)
    m.free()
}

test "map_delete_nonexistent" {
    var m: Map(i64, i64) = .{}
    m.set(1, 10)
    m.delete(999)
    @assertEq(m.len(), 1)
    @assertEq(m.get(1), 10)
    m.free()
}

test "map_delete_empty" {
    var m: Map(i64, i64) = .{}
    m.delete(1)
    @assertEq(m.len(), 0)
    m.free()
}

test "map_mass_delete_then_reinsert" {
    // Insert 5 keys, delete all, insert 5 new keys.
    // Tests tombstone reuse with no growth.
    var m: Map(i64, i64) = .{}
    var i: i64 = 0
    while (i < 5) {
        m.set(i, i * 10)
        i = i + 1
    }
    i = 0
    while (i < 5) {
        m.delete(i)
        i = i + 1
    }
    @assertEq(m.len(), 0)
    // Insert 5 different keys into tombstone-laden table
    i = 100
    while (i < 105) {
        m.set(i, i * 10)
        i = i + 1
    }
    @assertEq(m.len(), 5)
    i = 100
    while (i < 105) {
        @assertEq(m.get(i), i * 10)
        i = i + 1
    }
    // Original keys should be gone
    @assertEq(m.has(0), 0)
    @assertEq(m.has(4), 0)
    m.free()
}

test "map_has_after_all_deleted" {
    // All entries deleted: table is full of tombstones.
    // has() must terminate and return 0 (not loop forever).
    var m: Map(i64, i64) = .{}
    var i: i64 = 0
    while (i < 5) {
        m.set(i, i)
        i = i + 1
    }
    i = 0
    while (i < 5) {
        m.delete(i)
        i = i + 1
    }
    @assertEq(m.len(), 0)
    @assertEq(m.has(0), 0)
    @assertEq(m.has(3), 0)
    @assertEq(m.has(999), 0)
    m.free()
}

test "map_getOrDefault_empty" {
    var m: Map(i64, i64) = .{}
    @assertEq(m.getOrDefault(1, 42), 42)
    m.free()
}

test "map_keys_after_delete" {
    var m: Map(i64, i64) = .{}
    m.set(1, 10)
    m.set(2, 20)
    m.set(3, 30)
    m.delete(2)
    var k = m.keys()
    @assertEq(k.len(), 2)
    @assertEq(k.contains(1), 1)
    @assertEq(k.contains(3), 1)
    @assertEq(k.contains(2), 0)
    k.free()
    m.free()
}

test "map_double_free" {
    var m: Map(i64, i64) = .{}
    m.set(1, 10)
    m.free()
    m.free()
    @assertEq(m.len(), 0)
    @assertEq(m.capacity, 0)
}

test "map_key_zero" {
    var m: Map(i64, i64) = .{}
    m.set(0, 42)
    @assertEq(m.has(0), 1)
    @assertEq(m.get(0), 42)
    m.delete(0)
    @assertEq(m.has(0), 0)
    m.free()
}

test "map_keyAt_valueAt" {
    var m: Map(i64, i64) = .{}
    m.set(10, 100)
    m.set(20, 200)
    m.set(30, 300)
    // Iterate using indexed access
    var sum_keys: i64 = 0
    var sum_vals: i64 = 0
    var i: i64 = 0
    while (i < m.len()) {
        sum_keys += m.keyAt(i)
        sum_vals += m.valueAt(i)
        i += 1
    }
    @assertEq(sum_keys, 60)
    @assertEq(sum_vals, 600)
    m.free()
}

test "map_clone" {
    var m: Map(i64, i64) = .{}
    m.set(1, 10)
    m.set(2, 20)
    m.set(3, 30)
    var m2 = m.clone()
    @assertEq(m2.len(), 3)
    @assertEq(m2.get(1), 10)
    @assertEq(m2.get(2), 20)
    @assertEq(m2.get(3), 30)
    // Modifying clone doesn't affect original
    m2.set(1, 999)
    @assertEq(m.get(1), 10)
    @assertEq(m2.get(1), 999)
    m.free()
    m2.free()
}

test "map_clone_empty" {
    var m: Map(i64, i64) = .{}
    var m2 = m.clone()
    @assertEq(m2.len(), 0)
    m.free()
    m2.free()
}

test "map_putAll" {
    var m1: Map(i64, i64) = .{}
    m1.set(1, 10)
    m1.set(2, 20)
    var m2: Map(i64, i64) = .{}
    m2.set(3, 30)
    m2.set(4, 40)
    m1.putAll(&m2)
    @assertEq(m1.len(), 4)
    @assertEq(m1.get(1), 10)
    @assertEq(m1.get(3), 30)
    @assertEq(m1.get(4), 40)
    m1.free()
    m2.free()
}

test "map_putAll_overwrite" {
    var m1: Map(i64, i64) = .{}
    m1.set(1, 10)
    m1.set(2, 20)
    var m2: Map(i64, i64) = .{}
    m2.set(2, 200)
    m2.set(3, 300)
    m1.putAll(&m2)
    @assertEq(m1.len(), 3)
    @assertEq(m1.get(2), 200)
    @assertEq(m1.get(3), 300)
    m1.free()
    m2.free()
}

// ===== getOrNull =====

test "map_getOrNull_existing" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    m.set(2, 200)
    if (m.getOrNull(1)) |val| {
        @assertEq(val, 100)
    } else {
        @assert(false)
    }
    if (m.getOrNull(2)) |val| {
        @assertEq(val, 200)
    } else {
        @assert(false)
    }
    m.free()
}

test "map_getOrNull_missing" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    var result = m.getOrNull(999)
    @assertEq(result == null, true)
    m.free()
}

test "map_getOrNull_empty" {
    var m: Map(i64, i64) = .{}
    var result = m.getOrNull(1)
    @assertEq(result == null, true)
    m.free()
}

test "map_getOrNull_after_delete" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    m.set(2, 200)
    m.delete(1)
    var result = m.getOrNull(1)
    @assertEq(result == null, true)
    if (m.getOrNull(2)) |val| {
        @assertEq(val, 200)
    } else {
        @assert(false)
    }
    m.free()
}

// ===== remove =====

test "map_remove_existing" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    m.set(2, 200)
    if (m.remove(1)) |val| {
        @assertEq(val, 100)
    } else {
        @assert(false)
    }
    @assertEq(m.len(), 1)
    @assertEq(m.has(1), 0)
    @assertEq(m.get(2), 200)
    m.free()
}

test "map_remove_missing" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    var result = m.remove(999)
    @assertEq(result == null, true)
    @assertEq(m.len(), 1)
    m.free()
}

test "map_remove_empty" {
    var m: Map(i64, i64) = .{}
    var result = m.remove(1)
    @assertEq(result == null, true)
    @assertEq(m.len(), 0)
    m.free()
}

test "map_remove_reinsert" {
    var m: Map(i64, i64) = .{}
    m.set(1, 100)
    var old = m.remove(1)
    @assertEq(old == null, false)
    m.set(1, 999)
    @assertEq(m.get(1), 999)
    @assertEq(m.len(), 1)
    m.free()
}

// ===== ensureTotalCapacity =====

test "map_ensureTotalCapacity" {
    var m: Map(i64, i64) = .{}
    m.ensureTotalCapacity(100)
    // Should have pre-allocated enough capacity
    @assert(m.capacity >= 100)
    // Data operations still work
    var i: i64 = 0
    while (i < 50) {
        m.set(i, i * 10)
        i += 1
    }
    @assertEq(m.len(), 50)
    @assertEq(m.get(25), 250)
    m.free()
}

test "map_ensureTotalCapacity_zero" {
    var m: Map(i64, i64) = .{}
    m.ensureTotalCapacity(0)
    @assertEq(m.capacity, 0)
    m.free()
}

// ===== contains =====

test "map_contains_bool" {
    var m: Map(i64, i64) = .{}
    m.set(42, 99)
    @assertEq(m.contains(42), true)
    @assertEq(m.contains(99), false)
    m.free()
}

test "map_contains_empty" {
    var m: Map(i64, i64) = .{}
    @assertEq(m.contains(1), false)
    m.free()
}

test "map_contains_after_delete" {
    var m: Map(i64, i64) = .{}
    m.set(1, 10)
    m.set(2, 20)
    m.delete(1)
    @assertEq(m.contains(1), false)
    @assertEq(m.contains(2), true)
    m.free()
}
