// io — Buffered I/O.
//
// Wraps raw fd reads/writes with user-space buffering.
// Reference: Go bufio (bufio.go lines 32-700)
//
// Uses heap-allocated state (like json.cot) to avoid struct decomposition
// issues with methods on large structs + compound params.

import "std/string"

// BufferedReader layout (5 * 8 = 40 bytes):
//   +0:  fd (i64)
//   +8:  buf (i64 — pointer to @alloc'd buffer)
//   +16: rd (i64 — read position)
//   +24: wr (i64 — write position / valid data end)
//   +32: buf_size (i64 — buffer capacity)

fn newBufferedReader(fd: i64) i64 {
    return newBufferedReaderSize(fd, 4096)
}

fn newBufferedReaderSize(fd: i64, size: i64) i64 {
    var p = @alloc(40)
    @intToPtr(*i64, p).* = fd
    @intToPtr(*i64, p + 8).* = @alloc(size)
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = 0
    @intToPtr(*i64, p + 32).* = size
    return p
}

// Go bufio.go:99 — slide unread data to front, then syscall read
fn readerFill(r: i64) void {
    var buf = @intToPtr(*i64, r + 8).*
    var rd = @intToPtr(*i64, r + 16).*
    var wr = @intToPtr(*i64, r + 24).*
    var buf_size = @intToPtr(*i64, r + 32).*

    // Slide unread data to front
    if (rd > 0) {
        var unread = wr - rd
        if (unread > 0) {
            @memcpy(buf, buf + rd, unread)
        }
        wr = unread
        rd = 0
        @intToPtr(*i64, r + 16).* = rd
        @intToPtr(*i64, r + 24).* = wr
    }
    // Buffer full — caller must consume
    if (wr >= buf_size) { return }
    // Read from fd
    var fd = @intToPtr(*i64, r).*
    var n = @fd_read(fd, buf + wr, buf_size - wr)
    if (n > 0) {
        @intToPtr(*i64, r + 24).* = wr + n
    }
}

// Go bufio.go:267 — single byte or -1 for EOF
fn readByte(r: i64) i64 {
    var rd = @intToPtr(*i64, r + 16).*
    var wr = @intToPtr(*i64, r + 24).*
    if (rd >= wr) {
        readerFill(r)
        rd = @intToPtr(*i64, r + 16).*
        wr = @intToPtr(*i64, r + 24).*
        if (rd >= wr) { return 0 - 1 }
    }
    var buf = @intToPtr(*i64, r + 8).*
    var c = @intToPtr(*u8, buf + rd).*
    @intToPtr(*i64, r + 16).* = rd + 1
    return c
}

// Go bufio.go:405 — scan for \n, return line without newline.
// Empty string (len 0) signals EOF.
fn readLine(r: i64) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var have_prefix: i64 = 0

    var searching: i64 = 1
    while (searching == 1) {
        var buf = @intToPtr(*i64, r + 8).*
        var rd = @intToPtr(*i64, r + 16).*
        var wr = @intToPtr(*i64, r + 24).*

        // Scan current buffer for \n
        var i = rd
        while (i < wr) {
            var c = @intToPtr(*u8, buf + i).*
            if (c == 10) {
                // Found \n at position i
                var line_len = i - rd
                if (have_prefix == 1) {
                    if (line_len > 0) {
                        sb.append(@string(buf + rd, line_len))
                    }
                    @intToPtr(*i64, r + 16).* = i + 1
                    var result = sb.toString()
                    return result
                }
                // Simple case: no prefix accumulated
                var line = @string(buf + rd, line_len)
                @intToPtr(*i64, r + 16).* = i + 1
                return line
            }
            i = i + 1
        }

        // No \n found — save what we have and fill more
        var chunk_len = wr - rd
        if (chunk_len > 0) {
            sb.append(@string(buf + rd, chunk_len))
            have_prefix = 1
            @intToPtr(*i64, r + 16).* = wr
        }

        readerFill(r)
        var new_rd = @intToPtr(*i64, r + 16).*
        var new_wr = @intToPtr(*i64, r + 24).*
        if (new_rd >= new_wr) {
            searching = 0
        }
    }

    // EOF: return accumulated data (or empty for true EOF)
    if (have_prefix == 1) {
        var result = sb.toString()
        return result
    }
    return ""
}

// ============================================================================
// BufferedWriter
// ============================================================================

// BufferedWriter layout (4 * 8 = 32 bytes):
//   +0:  fd (i64)
//   +8:  buf (i64 — pointer to @alloc'd buffer)
//   +16: wr (i64 — bytes buffered)
//   +24: buf_size (i64 — buffer capacity)

fn newBufferedWriter(fd: i64) i64 {
    return newBufferedWriterSize(fd, 4096)
}

fn newBufferedWriterSize(fd: i64, size: i64) i64 {
    var p = @alloc(32)
    @intToPtr(*i64, p).* = fd
    @intToPtr(*i64, p + 8).* = @alloc(size)
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = size
    return p
}

// Go bufio.go:635 — write buffered data to fd
fn writerFlush(w: i64) void {
    var wr = @intToPtr(*i64, w + 16).*
    if (wr > 0) {
        var fd = @intToPtr(*i64, w).*
        var buf = @intToPtr(*i64, w + 8).*
        @fd_write(fd, buf, wr)
        @intToPtr(*i64, w + 16).* = 0
    }
}

fn writeByte(w: i64, b: i64) void {
    var wr = @intToPtr(*i64, w + 16).*
    var buf_size = @intToPtr(*i64, w + 24).*
    if (wr >= buf_size) {
        writerFlush(w)
        wr = 0
    }
    var buf = @intToPtr(*i64, w + 8).*
    var p = @intToPtr(*u8, buf + wr)
    p.* = @intCast(u8, b)
    @intToPtr(*i64, w + 16).* = wr + 1
}

// Go bufio.go:672
fn writeString(w: i64, s: string) void {
    var slen = @lenOf(s)
    if (slen == 0) { return }
    var wr = @intToPtr(*i64, w + 16).*
    var buf_size = @intToPtr(*i64, w + 24).*
    var buf = @intToPtr(*i64, w + 8).*
    var avail = buf_size - wr
    if (slen <= avail) {
        @memcpy(buf + wr, @ptrOf(s), slen)
        @intToPtr(*i64, w + 16).* = wr + slen
        return
    }
    // Flush, then write directly if still too big
    writerFlush(w)
    if (slen >= buf_size) {
        var fd = @intToPtr(*i64, w).*
        @fd_write(fd, @ptrOf(s), slen)
        return
    }
    // Now it fits (wr was reset to 0 by flush)
    @memcpy(buf, @ptrOf(s), slen)
    @intToPtr(*i64, w + 16).* = slen
}

fn writeInt(w: i64, val: i64) void {
    writeByte(w, val & 255)
    writeByte(w, (val >> 8) & 255)
    writeByte(w, (val >> 16) & 255)
    writeByte(w, (val >> 24) & 255)
}

fn writerWriteAll(w: i64, ptr: i64, len: i64) void {
    if (len == 0) { return }
    var wr = @intToPtr(*i64, w + 16).*
    var buf_size = @intToPtr(*i64, w + 24).*
    var buf = @intToPtr(*i64, w + 8).*
    var avail = buf_size - wr
    if (len <= avail) {
        @memcpy(buf + wr, ptr, len)
        @intToPtr(*i64, w + 16).* = wr + len
        return
    }
    writerFlush(w)
    if (len >= buf_size) {
        var fd = @intToPtr(*i64, w).*
        @fd_write(fd, ptr, len)
        return
    }
    @memcpy(buf, ptr, len)
    @intToPtr(*i64, w + 16).* = len
}

// ============================================================================
// Writer Trait — Zig std.io.Writer pattern (monomorphized)
// ============================================================================

// Reference: Zig lib/std/Io/Writer.zig
// Writer trait for composable output. Implementations provide write().
// BufferWriter writes to in-memory buffer (for Wasm assembly, codegen).
// FileWriter writes to a file descriptor.

trait Writer {
    fn write(self: *Self, ptr: i64, len: i64) i64
    fn writeByte(self: *Self, b: i64) void
}

// BufferWriter — writes to an in-memory byte buffer.
// Reference: Zig std.io.fixedBufferStream + Writer
struct BufferWriter {
    buf: i64,
    len: i64,
    cap: i64,
}

impl Writer for BufferWriter {
    fn write(self: *BufferWriter, ptr: i64, len: i64) i64 {
        self.ensureCap(self.len + len)
        @memcpy(self.buf + self.len, ptr, len)
        self.len = self.len + len
        return len
    }

    fn writeByte(self: *BufferWriter, b: i64) void {
        self.ensureCap(self.len + 1)
        @intToPtr(*u8, self.buf + self.len).* = @intCast(u8, b)
        self.len = self.len + 1
    }
}

impl BufferWriter {
    fn ensureCap(self: *BufferWriter, needed: i64) void {
        if (self.cap >= needed) { return }
        var new_cap = self.cap
        if (new_cap == 0) { new_cap = 256 }
        while (new_cap < needed) {
            new_cap = new_cap * 2
        }
        if (self.cap == 0) {
            self.buf = @alloc(new_cap)
        } else {
            self.buf = @realloc(self.buf, new_cap)
        }
        self.cap = new_cap
    }

    fn writeString(self: *BufferWriter, s: string) void {
        var slen = @lenOf(s)
        if (slen == 0) { return }
        self.write(@ptrOf(s), slen)
    }

    fn writeU32LE(self: *BufferWriter, val: i64) void {
        self.writeByte(val & 255)
        self.writeByte((val >> 8) & 255)
        self.writeByte((val >> 16) & 255)
        self.writeByte((val >> 24) & 255)
    }

    fn toSlice(self: *BufferWriter) string {
        if (self.len == 0) { return "" }
        return @string(self.buf, self.len)
    }

    fn reset(self: *BufferWriter) void {
        self.len = 0
    }

    fn free(self: *BufferWriter) void {
        if (self.cap > 0) { @dealloc(self.buf) }
        self.buf = 0
        self.len = 0
        self.cap = 0
    }
}

// ============================================================================
// Reader Trait — Zig std.io.Reader pattern (monomorphized)
// ============================================================================

trait Reader {
    fn read(self: *Self, buf: i64, len: i64) i64
}

// BufferReader — reads from an in-memory byte buffer.
struct BufferReader {
    buf: i64,
    len: i64,
    pos: i64,
}

impl Reader for BufferReader {
    fn read(self: *BufferReader, buf: i64, len: i64) i64 {
        var avail = self.len - self.pos
        if (avail <= 0) { return 0 }
        var n = len
        if (n > avail) { n = avail }
        @memcpy(buf, self.buf + self.pos, n)
        self.pos = self.pos + n
        return n
    }
}

impl BufferReader {
    fn readByte(self: *BufferReader) i64 {
        if (self.pos >= self.len) { return 0 - 1 }
        var b = @intToPtr(*u8, self.buf + self.pos).*
        self.pos = self.pos + 1
        return b
    }

    fn remaining(self: *BufferReader) i64 {
        return self.len - self.pos
    }

    fn atEnd(self: *BufferReader) bool {
        return self.pos >= self.len
    }
}
