// url — URL parsing and construction.
//
// Parses URLs into components: scheme, host, port, path, query, fragment.
// Manual scanning (no regex), following Go's net/url pattern.
//
// Uses heap-allocated layout (like json.cot) because Cot doesn't yet
// support returning structs with string fields.
//
// Reference: Go net/url/url.go (Parse, getScheme, parseAuthority)

import "std/string"

// URL layout — heap-allocated (6 string fields × 16 bytes = 96 bytes):
//   offset  0: scheme_ptr  (i64)
//   offset  8: scheme_len  (i64)
//   offset 16: host_ptr    (i64)
//   offset 24: host_len    (i64)
//   offset 32: port_ptr    (i64)
//   offset 40: port_len    (i64)
//   offset 48: path_ptr    (i64)
//   offset 56: path_len    (i64)
//   offset 64: query_ptr   (i64)
//   offset 72: query_len   (i64)
//   offset 80: fragment_ptr(i64)
//   offset 88: fragment_len(i64)

fn urlScheme(url: i64) string {
    var p = @intToPtr(*i64, url).*
    var l = @intToPtr(*i64, url + 8).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn urlHost(url: i64) string {
    var p = @intToPtr(*i64, url + 16).*
    var l = @intToPtr(*i64, url + 24).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn urlPort(url: i64) string {
    var p = @intToPtr(*i64, url + 32).*
    var l = @intToPtr(*i64, url + 40).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn urlPath(url: i64) string {
    var p = @intToPtr(*i64, url + 48).*
    var l = @intToPtr(*i64, url + 56).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn urlQuery(url: i64) string {
    var p = @intToPtr(*i64, url + 64).*
    var l = @intToPtr(*i64, url + 72).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn urlFragment(url: i64) string {
    var p = @intToPtr(*i64, url + 80).*
    var l = @intToPtr(*i64, url + 88).*
    if (l == 0) { return "" }
    return @string(p, l)
}

// Internal: store a string at a given offset in the URL struct
fn urlSetField(url: i64, offset: i64, s: string) void {
    @intToPtr(*i64, url + offset).* = @ptrOf(s)
    @intToPtr(*i64, url + offset + 8).* = @lenOf(s)
}

// Parse a URL string into a heap-allocated URL object.
// Returns an i64 pointer. Access fields via urlScheme(), urlHost(), etc.
//
// Example: parseUrl("http://example.com:8080/path?key=val#frag")
// → scheme="http", host="example.com", port="8080", path="/path",
//   query="key=val", fragment="frag"
fn parseUrl(raw: string) i64 {
    var url = @alloc(96)
    // Zero-init all fields
    var zi: i64 = 0
    while (zi < 96) {
        @intToPtr(*u8, url + zi).* = @intCast(u8, 0)
        zi = zi + 1
    }

    var rest = raw
    var rlen = @lenOf(rest)

    // Step 1: Extract fragment (split on '#')
    var frag_idx = indexOf(rest, "#")
    if (frag_idx >= 0) {
        urlSetField(url, 80, substring(rest, frag_idx + 1, rlen))
        rest = substring(rest, 0, frag_idx)
        rlen = @lenOf(rest)
    }

    // Step 2: Extract query (split on '?')
    var query_idx = indexOf(rest, "?")
    if (query_idx >= 0) {
        urlSetField(url, 64, substring(rest, query_idx + 1, rlen))
        rest = substring(rest, 0, query_idx)
        rlen = @lenOf(rest)
    }

    // Step 3: Extract scheme (scan for "://")
    var scheme_end = indexOf(rest, "://")
    if (scheme_end >= 0) {
        urlSetField(url, 0, substring(rest, 0, scheme_end))
        rest = substring(rest, scheme_end + 3, rlen)
        rlen = @lenOf(rest)
    }

    // Step 4: Extract authority (host[:port]) and path
    if (scheme_end >= 0) {
        var path_start = indexOf(rest, "/")
        var authority = ""
        if (path_start >= 0) {
            authority = substring(rest, 0, path_start)
            urlSetField(url, 48, substring(rest, path_start, rlen))
        } else {
            authority = rest
            urlSetField(url, 48, "/")
        }

        // Split authority into host:port
        var auth_len = @lenOf(authority)
        var bracket = indexOf(authority, "[")
        if (bracket >= 0) {
            // IPv6: [host]:port
            var bracket_end = indexOf(authority, "]")
            if (bracket_end >= 0) {
                urlSetField(url, 16, substring(authority, bracket + 1, bracket_end))
                if (bracket_end + 2 < auth_len) {
                    var after = charAt(authority, bracket_end + 1)
                    if (after == 58) {
                        urlSetField(url, 32, substring(authority, bracket_end + 2, auth_len))
                    }
                }
            } else {
                urlSetField(url, 16, authority)
            }
        } else {
            // Regular: host:port or just host
            var colon = lastIndexOf(authority, ":")
            if (colon >= 0) {
                urlSetField(url, 16, substring(authority, 0, colon))
                urlSetField(url, 32, substring(authority, colon + 1, auth_len))
            } else {
                urlSetField(url, 16, authority)
            }
        }
    } else {
        // No scheme — treat entire rest as path
        urlSetField(url, 48, rest)
    }

    return url
}

// Reconstruct a URL string from its components.
fn urlToString(url: i64) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var scheme = urlScheme(url)
    if (@lenOf(scheme) > 0) {
        sb.append(scheme)
        sb.append("://")
        sb.append(urlHost(url))
        var port = urlPort(url)
        if (@lenOf(port) > 0) {
            sb.appendByte(58)
            sb.append(port)
        }
    }
    sb.append(urlPath(url))
    var query = urlQuery(url)
    if (@lenOf(query) > 0) {
        sb.appendByte(63)
        sb.append(query)
    }
    var fragment = urlFragment(url)
    if (@lenOf(fragment) > 0) {
        sb.appendByte(35)
        sb.append(fragment)
    }
    return sb.toString()
}

// ===== Percent-Encoding (RFC 3986 Section 2.1) =====
// Reference: Go url.PathEscape/PathUnescape

// Check if a byte is in the unreserved set: A-Z, a-z, 0-9, '-', '.', '_', '~'
fn isUnreserved(c: i64) bool {
    if (c >= 65 and c <= 90) { return true }
    if (c >= 97 and c <= 122) { return true }
    if (c >= 48 and c <= 57) { return true }
    if (c == 45 or c == 46 or c == 95 or c == 126) { return true }
    return false
}

fn hexDigit(n: i64) i64 {
    if (n < 10) { return 48 + n }
    return 65 + n - 10
}

fn fromHexDigit(c: i64) i64 {
    if (c >= 48 and c <= 57) { return c - 48 }
    if (c >= 65 and c <= 70) { return c - 65 + 10 }
    if (c >= 97 and c <= 102) { return c - 97 + 10 }
    return 0 - 1
}

// Percent-encode a string. Non-unreserved bytes become %XX.
// Reference: Go url.PathEscape — encode all except unreserved set
fn percentEncode(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var i: i64 = 0
    var slen = @lenOf(s)
    var sptr = @ptrOf(s)
    while (i < slen) {
        var c: i64 = @intToPtr(*u8, sptr + i).*
        if (isUnreserved(c)) {
            sb.appendByte(c)
        } else {
            sb.appendByte(37)
            sb.appendByte(hexDigit((c >> 4) & 15))
            sb.appendByte(hexDigit(c & 15))
        }
        i = i + 1
    }
    return sb.toString()
}

// Percent-decode a string. %XX sequences become the corresponding byte.
// Reference: Go url.PathUnescape
fn percentDecode(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var i: i64 = 0
    var slen = @lenOf(s)
    var sptr = @ptrOf(s)
    while (i < slen) {
        var c: i64 = @intToPtr(*u8, sptr + i).*
        if (c == 37 and i + 2 < slen) {
            var hi = fromHexDigit(@intToPtr(*u8, sptr + i + 1).*)
            var lo = fromHexDigit(@intToPtr(*u8, sptr + i + 2).*)
            if (hi >= 0 and lo >= 0) {
                sb.appendByte(hi * 16 + lo)
                i = i + 3
            } else {
                sb.appendByte(c)
                i = i + 1
            }
        } else {
            sb.appendByte(c)
            i = i + 1
        }
    }
    return sb.toString()
}
