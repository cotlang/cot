// semver â€” Semantic Versioning 2.0.0.
//
// Parse, compare, and check semver version strings.
// Format: MAJOR.MINOR.PATCH[-prerelease][+build]
//
// References:
//   Deno: @std/semver (parse, compare, satisfies)
//   Go: golang.org/x/mod/semver

import "std/string"

// ============================================================================
// Version Struct (heap-allocated)
// ============================================================================

// Layout: [major(i64) @ 0, minor(i64) @ 8, patch(i64) @ 16,
//          prerelease_ptr(i64) @ 24, prerelease_len(i64) @ 32,
//          build_ptr(i64) @ 40, build_len(i64) @ 48]
const VERSION_SIZE: i64 = 56

// Parse a semver string into a heap-allocated version object.
// Returns pointer to version struct, or 0 on parse error.
// Accepts optional "v" prefix (e.g., "v1.2.3").
fn parse(s: string) i64 {
    var slen = @lenOf(s)
    if (slen == 0) { return 0 }

    var pos: i64 = 0
    // Skip optional 'v' prefix
    if (@intToPtr(*u8, @ptrOf(s)).* == 118) {
        pos = 1
    }

    // Parse major: scan digits
    var maj: i64 = 0
    var maj_digits: i64 = 0
    while (pos < slen and @intToPtr(*u8, @ptrOf(s) + pos).* >= 48 and @intToPtr(*u8, @ptrOf(s) + pos).* <= 57) {
        maj = maj * 10 + @intCast(i64, @intToPtr(*u8, @ptrOf(s) + pos).*) - 48
        maj_digits = maj_digits + 1
        pos = pos + 1
    }
    if (maj_digits == 0) { return 0 }

    // Expect '.'
    if (pos >= slen or @intToPtr(*u8, @ptrOf(s) + pos).* != 46) { return 0 }
    pos = pos + 1

    // Parse minor
    var min: i64 = 0
    var min_digits: i64 = 0
    while (pos < slen and @intToPtr(*u8, @ptrOf(s) + pos).* >= 48 and @intToPtr(*u8, @ptrOf(s) + pos).* <= 57) {
        min = min * 10 + @intCast(i64, @intToPtr(*u8, @ptrOf(s) + pos).*) - 48
        min_digits = min_digits + 1
        pos = pos + 1
    }
    if (min_digits == 0) { return 0 }

    // Expect '.'
    if (pos >= slen or @intToPtr(*u8, @ptrOf(s) + pos).* != 46) { return 0 }
    pos = pos + 1

    // Parse patch
    var pat: i64 = 0
    var pat_digits: i64 = 0
    while (pos < slen and @intToPtr(*u8, @ptrOf(s) + pos).* >= 48 and @intToPtr(*u8, @ptrOf(s) + pos).* <= 57) {
        pat = pat * 10 + @intCast(i64, @intToPtr(*u8, @ptrOf(s) + pos).*) - 48
        pat_digits = pat_digits + 1
        pos = pos + 1
    }
    if (pat_digits == 0) { return 0 }

    // Parse optional prerelease
    var pre_ptr: i64 = 0
    var pre_len: i64 = 0
    if (pos < slen and @intToPtr(*u8, @ptrOf(s) + pos).* == 45) {
        pos = pos + 1
        var pre_start = pos
        while (pos < slen and @intToPtr(*u8, @ptrOf(s) + pos).* != 43) {
            pos = pos + 1
        }
        pre_len = pos - pre_start
        pre_ptr = @ptrOf(s) + pre_start
    }

    // Parse optional build metadata
    var build_ptr: i64 = 0
    var build_len: i64 = 0
    if (pos < slen and @intToPtr(*u8, @ptrOf(s) + pos).* == 43) {
        pos = pos + 1
        var build_start = pos
        while (pos < slen) {
            pos = pos + 1
        }
        build_len = pos - build_start
        build_ptr = @ptrOf(s) + build_start
    }

    // Allocate and populate
    var v = @alloc(VERSION_SIZE)
    @intToPtr(*i64, v).* = maj
    @intToPtr(*i64, v + 8).* = min
    @intToPtr(*i64, v + 16).* = pat
    @intToPtr(*i64, v + 24).* = pre_ptr
    @intToPtr(*i64, v + 32).* = pre_len
    @intToPtr(*i64, v + 40).* = build_ptr
    @intToPtr(*i64, v + 48).* = build_len
    return v
}

// ============================================================================
// Accessors
// ============================================================================

fn major(v: i64) i64 { return @intToPtr(*i64, v).* }
fn minor(v: i64) i64 { return @intToPtr(*i64, v + 8).* }
fn patch(v: i64) i64 { return @intToPtr(*i64, v + 16).* }

fn prerelease(v: i64) string {
    var p = @intToPtr(*i64, v + 24).*
    var l = @intToPtr(*i64, v + 32).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn build(v: i64) string {
    var p = @intToPtr(*i64, v + 40).*
    var l = @intToPtr(*i64, v + 48).*
    if (l == 0) { return "" }
    return @string(p, l)
}

// ============================================================================
// Comparison (SemVer 2.0.0 precedence rules)
// ============================================================================

// Compare two version pointers. Returns -1, 0, or 1.
// Precedence: major > minor > patch > prerelease.
// Build metadata is ignored in comparison (per spec).
fn cmp(a: i64, b: i64) i64 {
    if (major(a) < major(b)) { return 0 - 1 }
    if (major(a) > major(b)) { return 1 }
    if (minor(a) < minor(b)) { return 0 - 1 }
    if (minor(a) > minor(b)) { return 1 }
    if (patch(a) < patch(b)) { return 0 - 1 }
    if (patch(a) > patch(b)) { return 1 }

    // Prerelease comparison (SemVer 2.0.0 rule 11):
    // no prerelease > has prerelease (1.0.0 > 1.0.0-alpha)
    var pre_a = prerelease(a)
    var pre_b = prerelease(b)
    var alen = @lenOf(pre_a)
    var blen = @lenOf(pre_b)

    if (alen == 0 and blen == 0) { return 0 }
    if (alen == 0) { return 1 }
    if (blen == 0) { return 0 - 1 }

    // Lexicographic comparison of prerelease strings
    var minlen = alen
    if (blen < minlen) { minlen = blen }
    var i: i64 = 0
    while (i < minlen) {
        var ca = @intCast(i64, @intToPtr(*u8, @ptrOf(pre_a) + i).*)
        var cb = @intCast(i64, @intToPtr(*u8, @ptrOf(pre_b) + i).*)
        if (ca < cb) { return 0 - 1 }
        if (ca > cb) { return 1 }
        i = i + 1
    }
    if (alen < blen) { return 0 - 1 }
    if (alen > blen) { return 1 }
    return 0
}

// Returns true if a > b.
fn gt(a: i64, b: i64) bool { return cmp(a, b) == 1 }
fn gte(a: i64, b: i64) bool { return cmp(a, b) >= 0 }
fn lt(a: i64, b: i64) bool { return cmp(a, b) == (0 - 1) }
fn lte(a: i64, b: i64) bool { return cmp(a, b) <= 0 }
fn eq(a: i64, b: i64) bool { return cmp(a, b) == 0 }

// ============================================================================
// Formatting
// ============================================================================

// Format a version object back to a string.
fn format(v: i64) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.appendInt(major(v))
    sb.appendByte(46)
    sb.appendInt(minor(v))
    sb.appendByte(46)
    sb.appendInt(patch(v))

    var pre = prerelease(v)
    if (@lenOf(pre) > 0) {
        sb.appendByte(45)
        sb.append(pre)
    }

    var b = build(v)
    if (@lenOf(b) > 0) {
        sb.appendByte(43)
        sb.append(b)
    }

    return sb.toString()
}

// ============================================================================
// Increment Operations
// ============================================================================

// Return a new version with major incremented, minor and patch reset to 0.
fn incMajor(v: i64) i64 {
    var nv = @alloc(VERSION_SIZE)
    @intToPtr(*i64, nv).* = major(v) + 1
    @intToPtr(*i64, nv + 8).* = 0
    @intToPtr(*i64, nv + 16).* = 0
    @intToPtr(*i64, nv + 24).* = 0
    @intToPtr(*i64, nv + 32).* = 0
    @intToPtr(*i64, nv + 40).* = 0
    @intToPtr(*i64, nv + 48).* = 0
    return nv
}

// Return a new version with minor incremented, patch reset to 0.
fn incMinor(v: i64) i64 {
    var nv = @alloc(VERSION_SIZE)
    @intToPtr(*i64, nv).* = major(v)
    @intToPtr(*i64, nv + 8).* = minor(v) + 1
    @intToPtr(*i64, nv + 16).* = 0
    @intToPtr(*i64, nv + 24).* = 0
    @intToPtr(*i64, nv + 32).* = 0
    @intToPtr(*i64, nv + 40).* = 0
    @intToPtr(*i64, nv + 48).* = 0
    return nv
}

// Return a new version with patch incremented.
fn incPatch(v: i64) i64 {
    var nv = @alloc(VERSION_SIZE)
    @intToPtr(*i64, nv).* = major(v)
    @intToPtr(*i64, nv + 8).* = minor(v)
    @intToPtr(*i64, nv + 16).* = patch(v) + 1
    @intToPtr(*i64, nv + 24).* = 0
    @intToPtr(*i64, nv + 32).* = 0
    @intToPtr(*i64, nv + 40).* = 0
    @intToPtr(*i64, nv + 48).* = 0
    return nv
}
