// encoding â€” Base64 and hex encode/decode.
//
// Base64: RFC 4648 standard and URL-safe alphabets.
// Hex: lowercase hex encoding/decoding.
//
// References:
//   Go: encoding/base64/base64.go (Encode, Decode)
//   Go: encoding/hex/hex.go (EncodeToString, DecodeString)

import "std/string"

// ============================================================================
// Hex Encoding (Go: encoding/hex)
// ============================================================================

fn hexEncode(data: string) string {
    var dlen = @lenOf(data)
    if (dlen == 0) { return "" }
    var out_len = dlen * 2
    var buf = @alloc(out_len)
    var i: i64 = 0
    while (i < dlen) {
        var b = @intToPtr(*u8, @ptrOf(data) + i).*
        var hi = @intCast(i64, b) >> 4
        var lo = @intCast(i64, b) & 15
        var p0 = @intToPtr(*u8, buf + i * 2)
        var p1 = @intToPtr(*u8, buf + i * 2 + 1)
        p0.* = @intCast(u8, hexDigit(hi))
        p1.* = @intCast(u8, hexDigit(lo))
        i = i + 1
    }
    return @string(buf, out_len)
}

fn hexDigit(v: i64) i64 {
    if (v < 10) { return v + 48 }
    return v - 10 + 97
}

fn hexDecode(s: string) string {
    var slen = @lenOf(s)
    if (slen == 0) { return "" }
    // Odd-length hex strings: ignore last char (same as Go's behavior)
    var pairs = slen >> 1
    if (pairs == 0) { return "" }
    var buf = @alloc(pairs)
    var i: i64 = 0
    while (i < pairs) {
        var c0 = @intToPtr(*u8, @ptrOf(s) + i * 2).*
        var c1 = @intToPtr(*u8, @ptrOf(s) + i * 2 + 1).*
        var hi = hexVal(@intCast(i64, c0))
        var lo = hexVal(@intCast(i64, c1))
        var p = @intToPtr(*u8, buf + i)
        p.* = @intCast(u8, (hi << 4) | lo)
        i = i + 1
    }
    return @string(buf, pairs)
}

fn hexVal(c: i64) i64 {
    // '0'-'9'
    if (c >= 48 and c <= 57) { return c - 48 }
    // 'a'-'f'
    if (c >= 97 and c <= 102) { return c - 97 + 10 }
    // 'A'-'F'
    if (c >= 65 and c <= 70) { return c - 65 + 10 }
    return 0
}

// ============================================================================
// Base64 Encoding (Go: encoding/base64, RFC 4648)
// ============================================================================

fn base64Encode(data: string) string {
    return base64EncodeWith(data, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", true)
}

fn base64UrlEncode(data: string) string {
    return base64EncodeWith(data, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", false)
}

fn base64EncodeWith(data: string, alphabet: string, pad: bool) string {
    var dlen = @lenOf(data)
    if (dlen == 0) { return "" }

    // Output size: (n + 2) / 3 * 4 for padded, ceil(n * 4 / 3) for unpadded
    var full_blocks = dlen / 3
    var remainder = dlen - full_blocks * 3
    var out_len: i64 = 0
    if (pad) {
        out_len = (dlen + 2) / 3 * 4
    } else {
        out_len = full_blocks * 4
        if (remainder == 1) { out_len = out_len + 2 }
        if (remainder == 2) { out_len = out_len + 3 }
    }

    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.grow(out_len)

    // Process full 3-byte blocks
    var i: i64 = 0
    while (i + 2 < dlen) {
        var b0 = @intCast(i64, @intToPtr(*u8, @ptrOf(data) + i).*)
        var b1 = @intCast(i64, @intToPtr(*u8, @ptrOf(data) + i + 1).*)
        var b2 = @intCast(i64, @intToPtr(*u8, @ptrOf(data) + i + 2).*)
        var val = (b0 << 16) | (b1 << 8) | b2

        sb.appendByte(charAt(alphabet, (val >> 18) & 63))
        sb.appendByte(charAt(alphabet, (val >> 12) & 63))
        sb.appendByte(charAt(alphabet, (val >> 6) & 63))
        sb.appendByte(charAt(alphabet, val & 63))
        i = i + 3
    }

    // Handle remainder
    if (remainder == 1) {
        var b0 = @intCast(i64, @intToPtr(*u8, @ptrOf(data) + i).*)
        sb.appendByte(charAt(alphabet, (b0 >> 2) & 63))
        sb.appendByte(charAt(alphabet, (b0 << 4) & 63))
        if (pad) {
            sb.appendByte(61)
            sb.appendByte(61)
        }
    }
    if (remainder == 2) {
        var b0 = @intCast(i64, @intToPtr(*u8, @ptrOf(data) + i).*)
        var b1 = @intCast(i64, @intToPtr(*u8, @ptrOf(data) + i + 1).*)
        var val = (b0 << 8) | b1
        sb.appendByte(charAt(alphabet, (val >> 10) & 63))
        sb.appendByte(charAt(alphabet, (val >> 4) & 63))
        sb.appendByte(charAt(alphabet, (val << 2) & 63))
        if (pad) {
            sb.appendByte(61)
        }
    }

    return sb.toString()
}

fn base64Decode(encoded: string) string {
    return base64DecodeWith(encoded, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
}

fn base64UrlDecode(encoded: string) string {
    return base64DecodeWith(encoded, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")
}

fn base64DecodeWith(encoded: string, alphabet: string) string {
    var slen = @lenOf(encoded)
    if (slen == 0) { return "" }

    // Strip trailing '=' padding (at most 2 chars per RFC 4648)
    var end = slen
    if (end > 0 and @intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + end - 1).*) == 61) {
        end = end - 1
    }
    if (end > 0 and @intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + end - 1).*) == 61) {
        end = end - 1
    }

    // Calculate output size
    var full_quads = end / 4
    var tail = end - full_quads * 4
    var out_len = full_quads * 3
    if (tail == 2) { out_len = out_len + 1 }
    if (tail == 3) { out_len = out_len + 2 }

    var buf = @alloc(out_len)
    var oi: i64 = 0

    // Process full 4-char blocks
    var i: i64 = 0
    while (i + 3 < end) {
        var v0 = b64Val(@intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + i).*), alphabet)
        var v1 = b64Val(@intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + i + 1).*), alphabet)
        var v2 = b64Val(@intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + i + 2).*), alphabet)
        var v3 = b64Val(@intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + i + 3).*), alphabet)
        var val = (v0 << 18) | (v1 << 12) | (v2 << 6) | v3

        @intToPtr(*u8, buf + oi).* = @intCast(u8, (val >> 16) & 255)
        @intToPtr(*u8, buf + oi + 1).* = @intCast(u8, (val >> 8) & 255)
        @intToPtr(*u8, buf + oi + 2).* = @intCast(u8, val & 255)
        oi = oi + 3
        i = i + 4
    }

    // Handle tail
    if (tail == 2) {
        var v0 = b64Val(@intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + i).*), alphabet)
        var v1 = b64Val(@intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + i + 1).*), alphabet)
        @intToPtr(*u8, buf + oi).* = @intCast(u8, (v0 << 2) | (v1 >> 4))
    }
    if (tail == 3) {
        var v0 = b64Val(@intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + i).*), alphabet)
        var v1 = b64Val(@intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + i + 1).*), alphabet)
        var v2 = b64Val(@intCast(i64, @intToPtr(*u8, @ptrOf(encoded) + i + 2).*), alphabet)
        var val = (v0 << 10) | (v1 << 4) | (v2 >> 2)
        @intToPtr(*u8, buf + oi).* = @intCast(u8, (val >> 8) & 255)
        @intToPtr(*u8, buf + oi + 1).* = @intCast(u8, val & 255)
    }

    return @string(buf, out_len)
}

// Look up a base64 character's 6-bit value by scanning the alphabet.
fn b64Val(c: i64, alphabet: string) i64 {
    var i: i64 = 0
    while (i < 64) {
        if (@intCast(i64, @intToPtr(*u8, @ptrOf(alphabet) + i).*) == c) {
            return i
        }
        i = i + 1
    }
    return 0
}
