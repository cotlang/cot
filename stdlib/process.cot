// process â€” Subprocess spawning and management.
//
// Wraps @fork, @waitpid, @pipe, @dup2, @execve builtins.
// Reference: Go os/exec, Zig std.process.Child, Deno Deno.Command

import "std/string"

// ============================================================================
// Low-level wrappers
// ============================================================================

fn fork() i64 {
    return @fork()
}

fn waitpid(pid: i64) i64 {
    return @waitpid(pid)
}

// Creates a pipe. Returns packed (write_fd << 32) | read_fd.
// Use pipeReadFd/pipeWriteFd to extract.
fn pipe() i64 {
    return @pipe()
}

fn pipeReadFd(packed_fds: i64) i64 {
    return packed_fds & 4294967295
}

fn pipeWriteFd(packed_fds: i64) i64 {
    return (packed_fds >> 32) & 4294967295
}

fn dup2(oldfd: i64, newfd: i64) i64 {
    return @dup2(oldfd, newfd)
}

// ============================================================================
// Argv construction helpers
// ============================================================================

// Build a null-terminated argv array in linear memory for execve.
// Layout at buf: [ptr0, ptr1, ..., NULL] then string bytes after.
// Each pointer is an i64 (wasm linear memory address).
// Returns the buffer address (for use as argv_ptr in execve).

// Ref: Go os/exec.Cmd inherits parent env; Zig std.process.Child same
// Dynamically allocate argv/string buffers instead of hardcoded addresses

fn argvBuild1(cmd: string) i64 {
    var buf = @alloc(64)
    var str_pos = @alloc(4096)

    // Copy command string
    @memcpy(str_pos, @ptrOf(cmd), @lenOf(cmd))
    @intToPtr(*u8, str_pos + @lenOf(cmd)).* = @intCast(u8, 0)
    @intToPtr(*i64, buf).* = str_pos
    str_pos = str_pos + @lenOf(cmd) + 1

    // NULL terminator
    @intToPtr(*i64, buf + 8).* = 0
    return buf
}

fn argvBuild2(cmd: string, a1: string) i64 {
    var buf = @alloc(64)
    var str_pos = @alloc(4096)

    // Command
    @memcpy(str_pos, @ptrOf(cmd), @lenOf(cmd))
    @intToPtr(*u8, str_pos + @lenOf(cmd)).* = @intCast(u8, 0)
    @intToPtr(*i64, buf).* = str_pos
    str_pos = str_pos + @lenOf(cmd) + 1

    // Arg 1
    @memcpy(str_pos, @ptrOf(a1), @lenOf(a1))
    @intToPtr(*u8, str_pos + @lenOf(a1)).* = @intCast(u8, 0)
    @intToPtr(*i64, buf + 8).* = str_pos
    str_pos = str_pos + @lenOf(a1) + 1

    // NULL terminator
    @intToPtr(*i64, buf + 16).* = 0
    return buf
}

fn argvBuild3(cmd: string, a1: string, a2: string) i64 {
    var buf = @alloc(64)
    var str_pos = @alloc(4096)

    @memcpy(str_pos, @ptrOf(cmd), @lenOf(cmd))
    @intToPtr(*u8, str_pos + @lenOf(cmd)).* = @intCast(u8, 0)
    @intToPtr(*i64, buf).* = str_pos
    str_pos = str_pos + @lenOf(cmd) + 1

    @memcpy(str_pos, @ptrOf(a1), @lenOf(a1))
    @intToPtr(*u8, str_pos + @lenOf(a1)).* = @intCast(u8, 0)
    @intToPtr(*i64, buf + 8).* = str_pos
    str_pos = str_pos + @lenOf(a1) + 1

    @memcpy(str_pos, @ptrOf(a2), @lenOf(a2))
    @intToPtr(*u8, str_pos + @lenOf(a2)).* = @intCast(u8, 0)
    @intToPtr(*i64, buf + 16).* = str_pos
    str_pos = str_pos + @lenOf(a2) + 1

    @intToPtr(*i64, buf + 24).* = 0
    return buf
}

// Build null-terminated path string, dynamically allocated
fn buildPath(path: string) i64 {
    var buf = @alloc(@lenOf(path) + 1)
    @memcpy(buf, @ptrOf(path), @lenOf(path))
    @intToPtr(*u8, buf + @lenOf(path)).* = @intCast(u8, 0)
    return buf
}

// Empty envp (just NULL pointer), dynamically allocated
fn emptyEnvp() i64 {
    var buf = @alloc(8)
    @intToPtr(*i64, buf).* = 0
    return buf
}

// ============================================================================
// High-level API
// ============================================================================

// Run a command and return its exit code.
// Example: var code = run("/bin/echo", "hello")
fn run(cmd: string, arg1: string) i64 {
    var pid = @fork()
    if (pid < 0) { return pid }
    if (pid == 0) {
        // Child process
        var path = buildPath(cmd)
        var argv = argvBuild2(cmd, arg1)
        var envp = emptyEnvp()
        @execve(path, argv, envp)
        // execve only returns on error
        @exit(127)
    }
    // Parent: wait for child
    return @waitpid(pid)
}

// Run a command with no arguments and return its exit code.
fn run0(cmd: string) i64 {
    var pid = @fork()
    if (pid < 0) { return pid }
    if (pid == 0) {
        var path = buildPath(cmd)
        var argv = argvBuild1(cmd)
        var envp = emptyEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }
    return @waitpid(pid)
}

// Run a command with two arguments and return its exit code.
fn run2(cmd: string, arg1: string, arg2: string) i64 {
    var pid = @fork()
    if (pid < 0) { return pid }
    if (pid == 0) {
        var path = buildPath(cmd)
        var argv = argvBuild3(cmd, arg1, arg2)
        var envp = emptyEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }
    return @waitpid(pid)
}

// Capture stdout from a command. Returns the output as a string.
fn output(cmd: string, arg1: string) string {
    var fds = @pipe()
    if (fds < 0) { return "" }
    var read_fd = pipeReadFd(fds)
    var write_fd = pipeWriteFd(fds)

    var pid = @fork()
    if (pid < 0) {
        @fd_close(read_fd)
        @fd_close(write_fd)
        return ""
    }

    if (pid == 0) {
        // Child: redirect stdout to pipe write end
        @fd_close(read_fd)
        @dup2(write_fd, 1)
        @fd_close(write_fd)
        var path = buildPath(cmd)
        var argv = argvBuild2(cmd, arg1)
        var envp = emptyEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }

    // Parent: read from pipe
    @fd_close(write_fd)
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var chunk = @alloc(4096)
    var done = false
    while (not done) {
        var n = @fd_read(read_fd, chunk, 4096)
        if (n <= 0) {
            done = true
        } else {
            sb.append(@string(chunk, n))
        }
    }
    @fd_close(read_fd)
    @dealloc(chunk)
    @waitpid(pid)
    return sb.toString()
}

// Capture stdout from a command with no arguments.
fn output0(cmd: string) string {
    var fds = @pipe()
    if (fds < 0) { return "" }
    var read_fd = pipeReadFd(fds)
    var write_fd = pipeWriteFd(fds)

    var pid = @fork()
    if (pid < 0) {
        @fd_close(read_fd)
        @fd_close(write_fd)
        return ""
    }

    if (pid == 0) {
        @fd_close(read_fd)
        @dup2(write_fd, 1)
        @fd_close(write_fd)
        var path = buildPath(cmd)
        var argv = argvBuild1(cmd)
        var envp = emptyEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }

    @fd_close(write_fd)
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var chunk = @alloc(4096)
    var done = false
    while (not done) {
        var n = @fd_read(read_fd, chunk, 4096)
        if (n <= 0) {
            done = true
        } else {
            sb.append(@string(chunk, n))
        }
    }
    @fd_close(read_fd)
    @dealloc(chunk)
    @waitpid(pid)
    return sb.toString()
}
