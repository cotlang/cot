// process — Subprocess spawning and management.
//
// Wraps @fork, @waitpid, @pipe, @dup2, @execve builtins.
// Reference: Go os/exec, Zig std.process.Child, Deno Deno.Command

import "std/string"
import "std/list"

// ============================================================================
// Low-level wrappers
// ============================================================================

fn fork() i64 {
    return @fork()
}

fn waitpid(pid: i64) i64 {
    return @waitpid(pid)
}

// Creates a pipe. Returns packed (write_fd << 32) | read_fd.
// Use pipeReadFd/pipeWriteFd to extract.
fn pipe() i64 {
    return @pipe()
}

fn pipeReadFd(packed_fds: i64) i64 {
    return packed_fds & 4294967295
}

fn pipeWriteFd(packed_fds: i64) i64 {
    return (packed_fds >> 32) & 4294967295
}

fn dup2(oldfd: i64, newfd: i64) i64 {
    return @dup2(oldfd, newfd)
}

// ============================================================================
// Argv/Envp construction helpers
// ============================================================================

// Ref: Go os/exec.Cmd inherits parent env; Zig std.process.Child same
// Dynamically allocate all buffers based on actual string sizes

// Build a null-terminated path string, dynamically allocated
fn buildPath(path: string) i64 {
    var buf = @alloc(@lenOf(path) + 1)
    @memcpy(buf, @ptrOf(path), @lenOf(path))
    @intToPtr(*u8, buf + @lenOf(path)).* = @intCast(u8, 0)
    return buf
}

// Copy a string into a buffer at str_pos, null-terminate, return new str_pos
fn copyArg(buf: i64, slot: i64, str_pos: i64, arg: string) i64 {
    @memcpy(str_pos, @ptrOf(arg), @lenOf(arg))
    @intToPtr(*u8, str_pos + @lenOf(arg)).* = @intCast(u8, 0)
    @intToPtr(*i64, buf + slot * 8).* = str_pos
    return str_pos + @lenOf(arg) + 1
}

fn argvBuild1(cmd: string) i64 {
    var total = @lenOf(cmd) + 1
    var buf = @alloc(16)
    var str_buf = @alloc(total)
    copyArg(buf, 0, str_buf, cmd)
    @intToPtr(*i64, buf + 8).* = 0
    return buf
}

fn argvBuild2(cmd: string, a1: string) i64 {
    var total = @lenOf(cmd) + @lenOf(a1) + 2
    var buf = @alloc(24)
    var str_buf = @alloc(total)
    var pos = copyArg(buf, 0, str_buf, cmd)
    copyArg(buf, 1, pos, a1)
    @intToPtr(*i64, buf + 16).* = 0
    return buf
}

fn argvBuild3(cmd: string, a1: string, a2: string) i64 {
    var total = @lenOf(cmd) + @lenOf(a1) + @lenOf(a2) + 3
    var buf = @alloc(32)
    var str_buf = @alloc(total)
    var pos = copyArg(buf, 0, str_buf, cmd)
    pos = copyArg(buf, 1, pos, a1)
    copyArg(buf, 2, pos, a2)
    @intToPtr(*i64, buf + 24).* = 0
    return buf
}

// Build argv from a List(string) — supports arbitrary argument count.
// Reference: Go os/exec.Cmd.argv()
fn argvBuildList(cmd: string, args: *List(string)) i64 {
    var argc = args.len() + 1
    var buf = @alloc((argc + 1) * 8)

    // Calculate total string size
    var total: i64 = @lenOf(cmd) + 1
    var i: i64 = 0
    while (i < args.len()) {
        total = total + @lenOf(args.get(i)) + 1
        i = i + 1
    }

    var str_buf = @alloc(total)
    var pos = copyArg(buf, 0, str_buf, cmd)
    i = 0
    while (i < args.len()) {
        pos = copyArg(buf, i + 1, pos, args.get(i))
        i = i + 1
    }
    @intToPtr(*i64, buf + argc * 8).* = 0
    return buf
}

// Build envp from parent process environment.
// Reference: Go os/exec.Cmd.environ() — inherits parent env by default
fn buildEnvp() i64 {
    var count = @environ_count()
    if (count <= 0) {
        var buf = @alloc(8)
        @intToPtr(*i64, buf).* = 0
        return buf
    }
    var buf = @alloc((count + 1) * 8)

    // Calculate total string size
    var total: i64 = 0
    var i: i64 = 0
    while (i < count) {
        total = total + @environ_len(i) + 1
        i = i + 1
    }

    var str_buf = @alloc(total)
    var pos: i64 = 0
    i = 0
    while (i < count) {
        var elen = @environ_len(i)
        var eptr = @environ_ptr(i)
        @memcpy(str_buf + pos, eptr, elen)
        @intToPtr(*u8, str_buf + pos + elen).* = @intCast(u8, 0)
        @intToPtr(*i64, buf + i * 8).* = str_buf + pos
        pos = pos + elen + 1
        i = i + 1
    }
    @intToPtr(*i64, buf + count * 8).* = 0
    return buf
}

// Empty envp (just NULL pointer)
fn emptyEnvp() i64 {
    var buf = @alloc(8)
    @intToPtr(*i64, buf).* = 0
    return buf
}

// ============================================================================
// High-level API
// ============================================================================

// Run a command with one argument. Returns exit code.
// Inherits parent environment (Go os/exec default behavior).
fn run(cmd: string, arg1: string) i64 {
    var pid = @fork()
    if (pid < 0) { return pid }
    if (pid == 0) {
        var path = buildPath(cmd)
        var argv = argvBuild2(cmd, arg1)
        var envp = buildEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }
    return @waitpid(pid)
}

// Run a command with no arguments.
fn run0(cmd: string) i64 {
    var pid = @fork()
    if (pid < 0) { return pid }
    if (pid == 0) {
        var path = buildPath(cmd)
        var argv = argvBuild1(cmd)
        var envp = buildEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }
    return @waitpid(pid)
}

// Run a command with two arguments.
fn run2(cmd: string, arg1: string, arg2: string) i64 {
    var pid = @fork()
    if (pid < 0) { return pid }
    if (pid == 0) {
        var path = buildPath(cmd)
        var argv = argvBuild3(cmd, arg1, arg2)
        var envp = buildEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }
    return @waitpid(pid)
}

// Run a command with arbitrary arguments from a List(string).
// Reference: Go os/exec.Cmd with .Args field
fn runWithArgs(cmd: string, args: *List(string)) i64 {
    var pid = @fork()
    if (pid < 0) { return pid }
    if (pid == 0) {
        var path = buildPath(cmd)
        var argv = argvBuildList(cmd, args)
        var envp = buildEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }
    return @waitpid(pid)
}

// Capture stdout from a command with one argument.
fn output(cmd: string, arg1: string) string {
    var fds = @pipe()
    if (fds < 0) { return "" }
    var read_fd = pipeReadFd(fds)
    var write_fd = pipeWriteFd(fds)

    var pid = @fork()
    if (pid < 0) {
        @fd_close(read_fd)
        @fd_close(write_fd)
        return ""
    }

    if (pid == 0) {
        @fd_close(read_fd)
        @dup2(write_fd, 1)
        @fd_close(write_fd)
        var path = buildPath(cmd)
        var argv = argvBuild2(cmd, arg1)
        var envp = buildEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }

    @fd_close(write_fd)
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var chunk = @alloc(4096)
    var done = false
    while (not done) {
        var n = @fd_read(read_fd, chunk, 4096)
        if (n <= 0) {
            done = true
        } else {
            sb.append(@string(chunk, n))
        }
    }
    @fd_close(read_fd)
    @dealloc(chunk)
    @waitpid(pid)
    return sb.toString()
}

// Capture stdout from a command with no arguments.
fn output0(cmd: string) string {
    var fds = @pipe()
    if (fds < 0) { return "" }
    var read_fd = pipeReadFd(fds)
    var write_fd = pipeWriteFd(fds)

    var pid = @fork()
    if (pid < 0) {
        @fd_close(read_fd)
        @fd_close(write_fd)
        return ""
    }

    if (pid == 0) {
        @fd_close(read_fd)
        @dup2(write_fd, 1)
        @fd_close(write_fd)
        var path = buildPath(cmd)
        var argv = argvBuild1(cmd)
        var envp = buildEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }

    @fd_close(write_fd)
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var chunk = @alloc(4096)
    var done = false
    while (not done) {
        var n = @fd_read(read_fd, chunk, 4096)
        if (n <= 0) {
            done = true
        } else {
            sb.append(@string(chunk, n))
        }
    }
    @fd_close(read_fd)
    @dealloc(chunk)
    @waitpid(pid)
    return sb.toString()
}

// Capture stdout from a command with arbitrary arguments.
fn outputWithArgs(cmd: string, args: *List(string)) string {
    var fds = @pipe()
    if (fds < 0) { return "" }
    var read_fd = pipeReadFd(fds)
    var write_fd = pipeWriteFd(fds)

    var pid = @fork()
    if (pid < 0) {
        @fd_close(read_fd)
        @fd_close(write_fd)
        return ""
    }

    if (pid == 0) {
        @fd_close(read_fd)
        @dup2(write_fd, 1)
        @fd_close(write_fd)
        var path = buildPath(cmd)
        var argv = argvBuildList(cmd, args)
        var envp = buildEnvp()
        @execve(path, argv, envp)
        @exit(127)
    }

    @fd_close(write_fd)
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var chunk = @alloc(4096)
    var done = false
    while (not done) {
        var n = @fd_read(read_fd, chunk, 4096)
        if (n <= 0) {
            done = true
        } else {
            sb.append(@string(chunk, n))
        }
    }
    @fd_close(read_fd)
    @dealloc(chunk)
    @waitpid(pid)
    return sb.toString()
}
