// json — JSON parser and encoder.
//
// Recursive descent parser, flat tagged struct representation.
// Reference: Go encoding/json/scanner.go (state machine)
//
// JsonValue uses a type tag + data fields. Objects/arrays stored as
// parallel Lists accessed via raw pointers.

import "std/list"
import "std/string"

// Type tags
const JSON_NULL: i64 = 0
const JSON_BOOL: i64 = 1
const JSON_INT: i64 = 2
const JSON_STRING: i64 = 3
const JSON_ARRAY: i64 = 4
const JSON_OBJECT: i64 = 5
const JSON_FLOAT: i64 = 6

// JsonValue — flat struct with type tag.
// For scalars: int_val holds the value (bool 0/1, or integer).
// For strings: str_val holds the string.
// For arrays:  int_val = pointer to List(i64) of JsonValue pointers.
// For objects: int_val = pointer to List(string) of keys,
//              extra    = pointer to List(i64) of JsonValue pointers.
struct JsonValue {
    tag: i64,
    int_val: i64,
    str_val: i64,
    str_len: i64,
    extra: i64,
}

// Parser state: input string + current position
struct JsonParser {
    src: i64,
    len: i64,
    pos: i64,
}

// ============================================================================
// Constructors
// ============================================================================

fn jsonNull() i64 {
    var p = @alloc(40)
    @intToPtr(*i64, p).* = JSON_NULL
    @intToPtr(*i64, p + 8).* = 0
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = 0
    @intToPtr(*i64, p + 32).* = 0
    return p
}

fn jsonBool(val: bool) i64 {
    var p = @alloc(40)
    @intToPtr(*i64, p).* = JSON_BOOL
    if (val) {
        @intToPtr(*i64, p + 8).* = 1
    } else {
        @intToPtr(*i64, p + 8).* = 0
    }
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = 0
    @intToPtr(*i64, p + 32).* = 0
    return p
}

fn jsonInt(val: i64) i64 {
    var p = @alloc(40)
    @intToPtr(*i64, p).* = JSON_INT
    @intToPtr(*i64, p + 8).* = val
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = 0
    @intToPtr(*i64, p + 32).* = 0
    return p
}

fn jsonString(val: string) i64 {
    var p = @alloc(40)
    @intToPtr(*i64, p).* = JSON_STRING
    @intToPtr(*i64, p + 8).* = 0
    @intToPtr(*i64, p + 16).* = @ptrOf(val)
    @intToPtr(*i64, p + 24).* = @lenOf(val)
    @intToPtr(*i64, p + 32).* = 0
    return p
}

// Ref: Go encoding/json uses strconv.ParseFloat
// Store float as string representation (V1: no f64 type in Cot yet)
fn jsonFloat(str_repr: string) i64 {
    var p = @alloc(40)
    @intToPtr(*i64, p).* = JSON_FLOAT
    @intToPtr(*i64, p + 8).* = 0
    @intToPtr(*i64, p + 16).* = @ptrOf(str_repr)
    @intToPtr(*i64, p + 24).* = @lenOf(str_repr)
    @intToPtr(*i64, p + 32).* = 0
    return p
}

fn jsonArray() i64 {
    var p = @alloc(40)
    @intToPtr(*i64, p).* = JSON_ARRAY
    // Allocate a List(i64) for element pointers
    var list_p = @alloc(24)
    @intToPtr(*i64, list_p).* = 0
    @intToPtr(*i64, list_p + 8).* = 0
    @intToPtr(*i64, list_p + 16).* = 0
    @intToPtr(*i64, p + 8).* = list_p
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = 0
    @intToPtr(*i64, p + 32).* = 0
    return p
}

fn jsonObject() i64 {
    var p = @alloc(40)
    @intToPtr(*i64, p).* = JSON_OBJECT
    // keys: List(string) — each entry is 2 i64 (ptr, len)
    var keys_p = @alloc(24)
    @intToPtr(*i64, keys_p).* = 0
    @intToPtr(*i64, keys_p + 8).* = 0
    @intToPtr(*i64, keys_p + 16).* = 0
    @intToPtr(*i64, p + 8).* = keys_p
    // values: List(i64) — each entry is a JsonValue pointer
    var vals_p = @alloc(24)
    @intToPtr(*i64, vals_p).* = 0
    @intToPtr(*i64, vals_p + 8).* = 0
    @intToPtr(*i64, vals_p + 16).* = 0
    @intToPtr(*i64, p + 32).* = vals_p
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = 0
    return p
}

// ============================================================================
// Accessors
// ============================================================================

fn jsonTag(val: i64) i64 {
    return @intToPtr(*i64, val).*
}

fn jsonIsNull(val: i64) bool {
    return @intToPtr(*i64, val).* == JSON_NULL
}

fn jsonGetBool(val: i64) bool {
    return @intToPtr(*i64, val + 8).* != 0
}

fn jsonGetInt(val: i64) i64 {
    return @intToPtr(*i64, val + 8).*
}

fn jsonIsFloat(val: i64) bool {
    return jsonTag(val) == JSON_FLOAT
}

// Returns the string representation of a float number
fn jsonGetFloat(val: i64) string {
    var sp = @intToPtr(*i64, val + 16).*
    var sl = @intToPtr(*i64, val + 24).*
    return @string(sp, sl)
}

fn jsonGetString(val: i64) string {
    var ptr = @intToPtr(*i64, val + 16).*
    var len = @intToPtr(*i64, val + 24).*
    return @string(ptr, len)
}

// ============================================================================
// Array operations
// ============================================================================

fn jsonArrayLen(val: i64) i64 {
    var list_p = @intToPtr(*i64, val + 8).*
    return @intToPtr(*i64, list_p + 8).*
}

fn jsonArrayGet(val: i64, index: i64) i64 {
    var list_p = @intToPtr(*i64, val + 8).*
    var items = @intToPtr(*i64, list_p).*
    return @intToPtr(*i64, items + index * 8).*
}

fn jsonArrayPush(arr: i64, val: i64) void {
    var list_p = @intToPtr(*i64, arr + 8).*
    // Manual List(i64) append
    var items = @intToPtr(*i64, list_p).*
    var count = @intToPtr(*i64, list_p + 8).*
    var cap = @intToPtr(*i64, list_p + 16).*
    if (count >= cap) {
        var new_cap = cap * 2
        if (new_cap < 8) { new_cap = 8 }
        if (cap == 0) {
            items = @alloc(new_cap * 8)
        } else {
            items = @realloc(items, new_cap * 8)
        }
        @intToPtr(*i64, list_p).* = items
        @intToPtr(*i64, list_p + 16).* = new_cap
    }
    @intToPtr(*i64, items + count * 8).* = val
    @intToPtr(*i64, list_p + 8).* = count + 1
}

// ============================================================================
// Object operations
// ============================================================================

fn jsonObjectLen(val: i64) i64 {
    var keys_p = @intToPtr(*i64, val + 8).*
    return @intToPtr(*i64, keys_p + 8).*
}

fn jsonObjectPut(obj: i64, key: string, val: i64) void {
    var keys_p = @intToPtr(*i64, obj + 8).*
    var vals_p = @intToPtr(*i64, obj + 32).*

    // Check for duplicate key — update in place if found (Go map semantics: last wins)
    // Reference: Go encoding/json uses map, RFC 8259 recommends unique keys
    var dup_k_items = @intToPtr(*i64, keys_p).*
    var dup_k_count = @intToPtr(*i64, keys_p + 8).*
    var dup_v_items = @intToPtr(*i64, vals_p).*
    var di: i64 = 0
    while (di < dup_k_count) {
        var kptr = @intToPtr(*i64, dup_k_items + di * 16).*
        var klen = @intToPtr(*i64, dup_k_items + di * 16 + 8).*
        var existing = @string(kptr, klen)
        if (existing == key) {
            @intToPtr(*i64, dup_v_items + di * 8).* = val
            return
        }
        di += 1
    }

    // Append key (string = 2 i64s: ptr, len)
    var k_items = @intToPtr(*i64, keys_p).*
    var k_count = @intToPtr(*i64, keys_p + 8).*
    var k_cap = @intToPtr(*i64, keys_p + 16).*
    if (k_count >= k_cap) {
        var new_cap = k_cap * 2
        if (new_cap < 8) { new_cap = 8 }
        if (k_cap == 0) {
            k_items = @alloc(new_cap * 16)
        } else {
            k_items = @realloc(k_items, new_cap * 16)
        }
        @intToPtr(*i64, keys_p).* = k_items
        @intToPtr(*i64, keys_p + 16).* = new_cap
    }
    @intToPtr(*i64, k_items + k_count * 16).* = @ptrOf(key)
    @intToPtr(*i64, k_items + k_count * 16 + 8).* = @lenOf(key)
    @intToPtr(*i64, keys_p + 8).* = k_count + 1

    // Append value pointer
    var v_items = @intToPtr(*i64, vals_p).*
    var v_count = @intToPtr(*i64, vals_p + 8).*
    var v_cap = @intToPtr(*i64, vals_p + 16).*
    if (v_count >= v_cap) {
        var new_cap = v_cap * 2
        if (new_cap < 8) { new_cap = 8 }
        if (v_cap == 0) {
            v_items = @alloc(new_cap * 8)
        } else {
            v_items = @realloc(v_items, new_cap * 8)
        }
        @intToPtr(*i64, vals_p).* = v_items
        @intToPtr(*i64, vals_p + 16).* = new_cap
    }
    @intToPtr(*i64, v_items + v_count * 8).* = val
    @intToPtr(*i64, vals_p + 8).* = v_count + 1
}

fn jsonObjectGet(obj: i64, key: string) i64 {
    var keys_p = @intToPtr(*i64, obj + 8).*
    var vals_p = @intToPtr(*i64, obj + 32).*
    var k_items = @intToPtr(*i64, keys_p).*
    var k_count = @intToPtr(*i64, keys_p + 8).*
    var v_items = @intToPtr(*i64, vals_p).*

    var i: i64 = 0
    while (i < k_count) {
        var kptr = @intToPtr(*i64, k_items + i * 16).*
        var klen = @intToPtr(*i64, k_items + i * 16 + 8).*
        var k = @string(kptr, klen)
        if (k == key) {
            return @intToPtr(*i64, v_items + i * 8).*
        }
        i += 1
    }
    return 0
}

fn jsonObjectGetString(obj: i64, key: string) string {
    var val = jsonObjectGet(obj, key)
    if (val == 0) { return "" }
    return jsonGetString(val)
}

fn jsonObjectGetInt(obj: i64, key: string) i64 {
    var val = jsonObjectGet(obj, key)
    if (val == 0) { return 0 }
    return jsonGetInt(val)
}

fn jsonObjectGetBool(obj: i64, key: string) bool {
    var val = jsonObjectGet(obj, key)
    if (val == 0) { return false }
    return jsonGetBool(val)
}

// ============================================================================
// Parser — Recursive descent
// ============================================================================

fn parserNew(input: string) i64 {
    var p = @alloc(24)
    @intToPtr(*i64, p).* = @ptrOf(input)
    @intToPtr(*i64, p + 8).* = @lenOf(input)
    @intToPtr(*i64, p + 16).* = 0
    return p
}

fn parserPeek(p: i64) i64 {
    var pos = @intToPtr(*i64, p + 16).*
    var len = @intToPtr(*i64, p + 8).*
    if (pos >= len) { return 0 - 1 }
    var src = @intToPtr(*i64, p).*
    return @intToPtr(*u8, src + pos).*
}

fn parserAdvance(p: i64) void {
    var pos = @intToPtr(*i64, p + 16).*
    @intToPtr(*i64, p + 16).* = pos + 1
}

fn parserSkipWhitespace(p: i64) void {
    var src = @intToPtr(*i64, p).*
    var len = @intToPtr(*i64, p + 8).*
    var pos = @intToPtr(*i64, p + 16).*
    while (pos < len) {
        var c = @intToPtr(*u8, src + pos).*
        if (c == 32 or c == 9 or c == 10 or c == 13) {
            pos += 1
        } else {
            @intToPtr(*i64, p + 16).* = pos
            return
        }
    }
    @intToPtr(*i64, p + 16).* = pos
}

fn parserExpect(p: i64, c: i64) void {
    var ch = parserPeek(p)
    if (ch != c) { @trap() }
    parserAdvance(p)
}

fn parseValue(p: i64) i64 {
    parserSkipWhitespace(p)
    var c = parserPeek(p)
    if (c == 123) { return parseObject(p) }       // {
    if (c == 91) { return parseArray(p) }          // [
    if (c == 34) { return parseString(p) }         // "
    if (c == 116) { return parseTrue(p) }          // t
    if (c == 102) { return parseFalse(p) }         // f
    if (c == 110) { return parseNull(p) }          // n
    // digit or minus
    if (c == 45 or (c >= 48 and c <= 57)) {
        return parseNumber(p)
    }
    @trap()
    return 0
}

fn parseNull(p: i64) i64 {
    parserExpect(p, 110) // n
    parserExpect(p, 117) // u
    parserExpect(p, 108) // l
    parserExpect(p, 108) // l
    return jsonNull()
}

fn parseTrue(p: i64) i64 {
    parserExpect(p, 116) // t
    parserExpect(p, 114) // r
    parserExpect(p, 117) // u
    parserExpect(p, 101) // e
    return jsonBool(true)
}

fn parseFalse(p: i64) i64 {
    parserExpect(p, 102) // f
    parserExpect(p, 97)  // a
    parserExpect(p, 108) // l
    parserExpect(p, 115) // s
    parserExpect(p, 101) // e
    return jsonBool(false)
}

// Port of Go encoding/json scanner.go number state machine:
// stateNeg → state0/state1 → stateDot → stateDot0 → stateE → stateESign → stateE0
// Validates: leading zeros rejected (01 invalid), exponent notation, required digits.
fn parseNumber(p: i64) i64 {
    var src = @intToPtr(*i64, p).*
    var len = @intToPtr(*i64, p + 8).*
    var pos = @intToPtr(*i64, p + 16).*
    var start = pos

    // Optional minus (Go stateNeg)
    if (pos < len and @intToPtr(*u8, src + pos).* == 45) {
        pos += 1
    }

    // Integer part — Go state0/state1 distinction
    if (pos >= len) { @trap() }
    var first = @intToPtr(*u8, src + pos).*
    if (first == 48) {
        // '0' — Go state0: must not be followed by another digit
        pos += 1
    } else if (first >= 49 and first <= 57) {
        // '1'-'9' — Go state1: consume all digits
        pos += 1
        while (pos < len) {
            var c = @intToPtr(*u8, src + pos).*
            if (c < 48 or c > 57) { break }
            pos += 1
        }
    } else {
        @trap()
    }

    // Fractional part (Go stateDot/stateDot0)
    if (pos < len and @intToPtr(*u8, src + pos).* == 46) {
        pos += 1
        // Must have at least one digit after '.' (Go stateDot)
        if (pos >= len) { @trap() }
        var dc = @intToPtr(*u8, src + pos).*
        if (dc < 48 or dc > 57) { @trap() }
        pos += 1
        // Consume remaining fraction digits (Go stateDot0)
        while (pos < len) {
            var c = @intToPtr(*u8, src + pos).*
            if (c < 48 or c > 57) { break }
            pos += 1
        }
    }

    // Exponent part (Go stateE/stateESign/stateE0)
    if (pos < len) {
        var ec = @intToPtr(*u8, src + pos).*
        if (ec == 101 or ec == 69) {
            pos += 1
            // Optional sign (Go stateE)
            if (pos < len) {
                var sc = @intToPtr(*u8, src + pos).*
                if (sc == 43 or sc == 45) { pos += 1 }
            }
            // Must have at least one digit (Go stateESign)
            if (pos >= len) { @trap() }
            var ed = @intToPtr(*u8, src + pos).*
            if (ed < 48 or ed > 57) { @trap() }
            pos += 1
            // Consume remaining exponent digits (Go stateE0)
            while (pos < len) {
                var c = @intToPtr(*u8, src + pos).*
                if (c < 48 or c > 57) { break }
                pos += 1
            }
        }
    }

    // Detect if number contains '.' or 'e'/'E' — treat as float
    // Ref: Go encoding/json uses strconv.ParseFloat for non-integer numbers
    var s = @string(src + start, pos - start)
    var is_float = false
    var di: i64 = 0
    while (di < pos - start) {
        var dc = @intToPtr(*u8, src + start + di).*
        if (dc == 46 or dc == 101 or dc == 69) {
            is_float = true
            di = pos - start
        } else {
            di += 1
        }
    }
    @intToPtr(*i64, p + 16).* = pos
    if (is_float) {
        return jsonFloat(s)
    }
    var result = parseInt(s)
    return jsonInt(result)
}

fn parseString(p: i64) i64 {
    parserExpect(p, 34) // opening "
    var src = @intToPtr(*i64, p).*
    var len = @intToPtr(*i64, p + 8).*
    var pos = @intToPtr(*i64, p + 16).*
    var start = pos

    // Scan for closing quote, handle escape sequences
    var has_escape = false
    while (pos < len) {
        var c = @intToPtr(*u8, src + pos).*
        if (c == 34) {
            // closing "
            if (has_escape) {
                // Need to unescape — build new string
                @intToPtr(*i64, p + 16).* = pos + 1
                return parseStringWithEscapes(src, start, pos)
            }
            // Simple case: no escapes, create substring
            var str = @string(src + start, pos - start)
            @intToPtr(*i64, p + 16).* = pos + 1
            return jsonString(str)
        }
        if (c == 92) {
            has_escape = true
            pos += 2  // skip backslash + escaped char
        } else {
            pos += 1
        }
    }
    @trap()
    return 0
}

// Helper: decode a single hex digit to 0-15, or -1 on invalid
fn hexDigit(c: i64) i64 {
    if (c >= 48 and c <= 57) { return c - 48 }
    if (c >= 97 and c <= 102) { return c - 97 + 10 }
    if (c >= 65 and c <= 70) { return c - 65 + 10 }
    return 0 - 1
}

// Port of Go encoding/json getu4: decode \uXXXX from 4 hex digits at src[pos..pos+4]
fn getu4(src: i64, pos: i64, end: i64) i64 {
    if (pos + 4 > end) { return 0 - 1 }
    var r: i64 = 0
    var i: i64 = 0
    while (i < 4) {
        var c = @intToPtr(*u8, src + pos + i).*
        var d = hexDigit(c)
        if (d < 0) { return 0 - 1 }
        r = r * 16 + d
        i += 1
    }
    return r
}

// UTF-16 surrogate detection (Go utf16.IsSurrogate)
fn isSurrogate(r: i64) bool {
    return r >= 55296 and r <= 57343
}

fn isHighSurrogate(r: i64) bool {
    return r >= 55296 and r <= 56319
}

// Decode UTF-16 surrogate pair to codepoint (Go utf16.DecodeRune)
fn decodeSurrogatePair(high: i64, low: i64) i64 {
    return (high - 55296) * 1024 + (low - 56320) + 65536
}

// Append a Unicode codepoint as UTF-8 to StringBuilder
fn sbAppendUtf8(sb: *StringBuilder, codepoint: i64) void {
    if (codepoint < 128) {
        sb.appendByte(codepoint)
    } else if (codepoint < 2048) {
        sb.appendByte(192 + (codepoint >> 6))
        sb.appendByte(128 + (codepoint & 63))
    } else if (codepoint < 65536) {
        sb.appendByte(224 + (codepoint >> 12))
        sb.appendByte(128 + ((codepoint >> 6) & 63))
        sb.appendByte(128 + (codepoint & 63))
    } else {
        sb.appendByte(240 + (codepoint >> 18))
        sb.appendByte(128 + ((codepoint >> 12) & 63))
        sb.appendByte(128 + ((codepoint >> 6) & 63))
        sb.appendByte(128 + (codepoint & 63))
    }
}

// Hex char for encoding: 0-9 → '0'-'9', 10-15 → 'a'-'f'
fn hexCharOf(v: i64) i64 {
    if (v < 10) { return 48 + v }
    return 97 + v - 10
}

// Port of Go encoding/json unquoteBytes escape handling.
// Rejects invalid escapes (Go: default → return), handles \uXXXX with surrogate pairs.
fn parseStringWithEscapes(src: i64, start: i64, end: i64) i64 {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var i = start
    while (i < end) {
        var c = @intToPtr(*u8, src + i).*
        if (c == 92) {
            i += 1
            if (i >= end) { @trap() }
            var esc = @intToPtr(*u8, src + i).*
            if (esc == 117) {
                // \uXXXX — port of Go getu4 + surrogate pair handling
                var rr = getu4(src, i + 1, end)
                if (rr < 0) { @trap() }
                i += 5
                if (isHighSurrogate(rr)) {
                    // Check for \uXXXX low surrogate pair
                    if (i + 6 <= end and @intToPtr(*u8, src + i).* == 92 and @intToPtr(*u8, src + i + 1).* == 117) {
                        var rr2 = getu4(src, i + 2, end)
                        if (rr2 >= 56320 and rr2 <= 57343) {
                            // Valid surrogate pair — decode
                            i += 6
                            sbAppendUtf8(&sb, decodeSurrogatePair(rr, rr2))
                        } else {
                            // Invalid low surrogate — replacement char
                            sbAppendUtf8(&sb, 65533)
                        }
                    } else {
                        sbAppendUtf8(&sb, 65533)
                    }
                } else if (isSurrogate(rr)) {
                    // Lone low surrogate — replacement char
                    sbAppendUtf8(&sb, 65533)
                } else {
                    sbAppendUtf8(&sb, rr)
                }
            } else {
                // Standard escapes per Go unquoteBytes (line 1234-1260)
                if (esc == 34) { sb.appendByte(34) }
                else if (esc == 92) { sb.appendByte(92) }
                else if (esc == 47) { sb.appendByte(47) }
                else if (esc == 98) { sb.appendByte(8) }
                else if (esc == 102) { sb.appendByte(12) }
                else if (esc == 110) { sb.appendByte(10) }
                else if (esc == 114) { sb.appendByte(13) }
                else if (esc == 116) { sb.appendByte(9) }
                else { @trap() }
                i += 1
            }
        } else {
            sb.appendByte(c)
            i += 1
        }
    }
    var result = sb.toString()
    return jsonString(result)
}

fn parseArray(p: i64) i64 {
    parserExpect(p, 91)  // [
    var arr = jsonArray()
    parserSkipWhitespace(p)
    if (parserPeek(p) == 93) {
        parserAdvance(p)  // ]
        return arr
    }
    // Parse elements
    var elem = parseValue(p)
    jsonArrayPush(arr, elem)
    parserSkipWhitespace(p)
    while (parserPeek(p) == 44) {
        parserAdvance(p)  // ,
        var next = parseValue(p)
        jsonArrayPush(arr, next)
        parserSkipWhitespace(p)
    }
    parserExpect(p, 93)  // ]
    return arr
}

fn parseObject(p: i64) i64 {
    parserExpect(p, 123) // {
    var obj = jsonObject()
    parserSkipWhitespace(p)
    if (parserPeek(p) == 125) {
        parserAdvance(p)  // }
        return obj
    }
    // Parse first key-value pair
    parseKeyValue(p, obj)
    parserSkipWhitespace(p)
    while (parserPeek(p) == 44) {
        parserAdvance(p)  // ,
        parseKeyValue(p, obj)
        parserSkipWhitespace(p)
    }
    parserExpect(p, 125)  // }
    return obj
}

// Parse key-value pair. Keys are full JSON strings — reuse parseString
// to properly handle escape sequences (Go: unquoteBytes on keys).
fn parseKeyValue(p: i64, obj: i64) void {
    parserSkipWhitespace(p)
    var key_val = parseString(p)
    var key = jsonGetString(key_val)
    parserSkipWhitespace(p)
    parserExpect(p, 58)  // :
    var val = parseValue(p)
    jsonObjectPut(obj, key, val)
}

// ============================================================================
// Public parse API
// ============================================================================

fn parse(input: string) i64 {
    var p = parserNew(input)
    var result = parseValue(p)
    return result
}

// ============================================================================
// Encoder — JSON to string
// ============================================================================

fn encode(val: i64) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    encodeValue(val, &sb)
    var result = sb.toString()
    return result
}

fn encodeValue(val: i64, sb: *StringBuilder) void {
    var tag = @intToPtr(*i64, val).*
    if (tag == JSON_NULL) {
        sb.append("null")
    } else if (tag == JSON_BOOL) {
        if (@intToPtr(*i64, val + 8).* != 0) {
            sb.append("true")
        } else {
            sb.append("false")
        }
    } else if (tag == JSON_INT) {
        sb.appendInt(@intToPtr(*i64, val + 8).*)
    } else if (tag == JSON_STRING) {
        encodeString(jsonGetString(val), sb)
    } else if (tag == JSON_ARRAY) {
        encodeArray(val, sb)
    } else if (tag == JSON_OBJECT) {
        encodeObject(val, sb)
    }
}

// Port of Go encoding/json encode.go string escaping.
// Escapes: \", \\, \b, \f, \n, \r, \t, and \u00XX for other control chars.
fn encodeString(s: string, sb: *StringBuilder) void {
    sb.appendByte(34)  // "
    var slen = @lenOf(s)
    var sptr = @ptrOf(s)
    var i: i64 = 0
    while (i < slen) {
        var c = @intToPtr(*u8, sptr + i).*
        if (c == 34) {
            sb.appendByte(92)
            sb.appendByte(34)
        } else if (c == 92) {
            sb.appendByte(92)
            sb.appendByte(92)
        } else if (c == 8) {
            sb.appendByte(92)
            sb.appendByte(98)
        } else if (c == 12) {
            sb.appendByte(92)
            sb.appendByte(102)
        } else if (c == 10) {
            sb.appendByte(92)
            sb.appendByte(110)
        } else if (c == 13) {
            sb.appendByte(92)
            sb.appendByte(114)
        } else if (c == 9) {
            sb.appendByte(92)
            sb.appendByte(116)
        } else if (c < 32) {
            // Other control characters → \u00XX (Go encode.go pattern)
            sb.appendByte(92)
            sb.appendByte(117)
            sb.appendByte(48)
            sb.appendByte(48)
            sb.appendByte(hexCharOf(c >> 4))
            sb.appendByte(hexCharOf(c & 15))
        } else {
            sb.appendByte(c)
        }
        i += 1
    }
    sb.appendByte(34)  // "
}

fn encodeArray(val: i64, sb: *StringBuilder) void {
    sb.appendByte(91)  // [
    var len = jsonArrayLen(val)
    var i: i64 = 0
    while (i < len) {
        if (i > 0) { sb.appendByte(44) }  // ,
        encodeValue(jsonArrayGet(val, i), sb)
        i += 1
    }
    sb.appendByte(93)  // ]
}

fn encodeObject(val: i64, sb: *StringBuilder) void {
    sb.appendByte(123) // {
    var keys_p = @intToPtr(*i64, val + 8).*
    var vals_p = @intToPtr(*i64, val + 32).*
    var k_items = @intToPtr(*i64, keys_p).*
    var k_count = @intToPtr(*i64, keys_p + 8).*
    var v_items = @intToPtr(*i64, vals_p).*

    var i: i64 = 0
    while (i < k_count) {
        if (i > 0) { sb.appendByte(44) } // ,
        var kptr = @intToPtr(*i64, k_items + i * 16).*
        var klen = @intToPtr(*i64, k_items + i * 16 + 8).*
        var key = @string(kptr, klen)
        encodeString(key, sb)
        sb.appendByte(58) // :
        var child = @intToPtr(*i64, v_items + i * 8).*
        encodeValue(child, sb)
        i += 1
    }
    sb.appendByte(125) // }
}

// ============================================================================
// Cleanup
// ============================================================================

// Recursively free a JsonValue and all its children.
// Reference: Go encoding/json — GC handles this; we need explicit cleanup for ARC.
fn jsonFree(val: i64) void {
    if (val == 0) { return }
    var tag = @intToPtr(*i64, val).*

    if (tag == JSON_ARRAY) {
        var arr_p = @intToPtr(*i64, val + 8).*
        if (arr_p != 0) {
            var items = @intToPtr(*i64, arr_p).*
            var count = @intToPtr(*i64, arr_p + 8).*
            var i: i64 = 0
            while (i < count) {
                jsonFree(@intToPtr(*i64, items + i * 8).*)
                i += 1
            }
            if (items != 0) { @dealloc(items) }
            @dealloc(arr_p)
        }
    }

    if (tag == JSON_OBJECT) {
        var keys_p = @intToPtr(*i64, val + 8).*
        var vals_p = @intToPtr(*i64, val + 32).*
        if (vals_p != 0) {
            var v_items = @intToPtr(*i64, vals_p).*
            var v_count = @intToPtr(*i64, vals_p + 8).*
            var i: i64 = 0
            while (i < v_count) {
                jsonFree(@intToPtr(*i64, v_items + i * 8).*)
                i += 1
            }
            if (v_items != 0) { @dealloc(v_items) }
            @dealloc(vals_p)
        }
        if (keys_p != 0) {
            var k_items = @intToPtr(*i64, keys_p).*
            if (k_items != 0) { @dealloc(k_items) }
            @dealloc(keys_p)
        }
    }

    @dealloc(val)
}
