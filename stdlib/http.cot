@safe

// http — TCP networking and basic HTTP.
//
// Wraps @net_socket, @net_bind, @net_listen, @net_accept, @net_connect,
// @net_set_reuse_addr builtins.
// Reference: Go net/http (patterns), POSIX sockets (API)
//
// All socket addresses use struct sockaddr_in (16 bytes) built in linear memory:
//   macOS: [0] sa_len  [1] sa_family  [2:4] sin_port  [4:8] sin_addr  [8:16] zero
//   Linux: [0:2] sa_family  [2:4] sin_port  [4:8] sin_addr  [8:16] zero

import "std/string"

// Socket constants
const AF_INET: i64 = 2
const SOCK_STREAM: i64 = 1
const IPPROTO_TCP: i64 = 6
const SOCKADDR_IN_SIZE: i64 = 16

const NetError = error { SocketError, BindError, ListenError, ConnectError, AcceptError }

// Build a sockaddr_in struct in linear memory at the given buffer pointer.
// ip: 32-bit IPv4 address in host byte order (e.g. INADDR_LOOPBACK = 0x7F000001)
// port: 16-bit port in host byte order (e.g. 8080)
fn buildSockaddrIn(buf: i64, ip: i64, port: i64) void {
    // Zero the entire 16-byte struct
    var i: i64 = 0
    while (i < SOCKADDR_IN_SIZE) {
        @intToPtr(*u8, buf + i).* = @intCast(u8, 0)
        i = i + 1
    }

    if (@target_os() == "macos") {
        // macOS sockaddr_in: sa_len(1) + sa_family(1)
        @intToPtr(*u8, buf).* = @intCast(u8, SOCKADDR_IN_SIZE)
        @intToPtr(*u8, buf + 1).* = @intCast(u8, AF_INET)
    } else {
        // Linux sockaddr_in: sa_family(2) little-endian
        @intToPtr(*u8, buf).* = @intCast(u8, AF_INET)
        @intToPtr(*u8, buf + 1).* = @intCast(u8, 0)
    }

    // sin_port (network byte order = big-endian)
    @intToPtr(*u8, buf + 2).* = @intCast(u8, (port >> 8) & 255)
    @intToPtr(*u8, buf + 3).* = @intCast(u8, port & 255)

    // sin_addr (network byte order = big-endian)
    @intToPtr(*u8, buf + 4).* = @intCast(u8, (ip >> 24) & 255)
    @intToPtr(*u8, buf + 5).* = @intCast(u8, (ip >> 16) & 255)
    @intToPtr(*u8, buf + 6).* = @intCast(u8, (ip >> 8) & 255)
    @intToPtr(*u8, buf + 7).* = @intCast(u8, ip & 255)
}

// INADDR_ANY = 0.0.0.0
const INADDR_ANY: i64 = 0
// INADDR_LOOPBACK = 127.0.0.1 = 0x7F000001
const INADDR_LOOPBACK: i64 = 2130706433

// Create a TCP socket. Returns fd or error.
fn tcpSocket() NetError!i64 {
    var fd = @net_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
    if (fd < 0) { return error.SocketError }
    return fd
}

// Set SO_REUSEADDR on a socket (prevents "address already in use" errors).
fn setReuseAddr(fd: i64) void {
    @net_set_reuse_addr(fd)
}

// Bind a socket to an address and port.
fn bindSocket(fd: i64, ip: i64, port: i64) NetError!i64 {
    var addr_buf = @alloc(SOCKADDR_IN_SIZE)
    buildSockaddrIn(addr_buf, ip, port)
    var result = @net_bind(fd, addr_buf, SOCKADDR_IN_SIZE)
    @dealloc(addr_buf)
    if (result < 0) { return error.BindError }
    return result
}

// Start listening for connections with the given backlog.
fn listenSocket(fd: i64, backlog: i64) NetError!i64 {
    var result = @net_listen(fd, backlog)
    if (result < 0) { return error.ListenError }
    return result
}

// Accept a connection on a listening socket. Returns new fd.
fn acceptConnection(fd: i64) NetError!i64 {
    var client_fd = @net_accept(fd)
    if (client_fd < 0) { return error.AcceptError }
    return client_fd
}

// Connect to a remote address. Returns 0 on success.
fn connectSocket(fd: i64, ip: i64, port: i64) NetError!i64 {
    var addr_buf = @alloc(SOCKADDR_IN_SIZE)
    buildSockaddrIn(addr_buf, ip, port)
    var result = @net_connect(fd, addr_buf, SOCKADDR_IN_SIZE)
    @dealloc(addr_buf)
    if (result < 0) { return error.ConnectError }
    return result
}

// Read from a socket fd. Returns bytes read.
fn socketRead(fd: i64, buf: i64, len: i64) i64 {
    return @fd_read(fd, buf, len)
}

// Write raw bytes to a socket fd. Returns bytes written.
fn socketWrite(fd: i64, buf: i64, len: i64) i64 {
    return @fd_write(fd, buf, len)
}

// Write a string to a socket fd.
fn socketWriteString(fd: i64, s: string) i64 {
    return @fd_write(fd, @ptrOf(s), @lenOf(s))
}

// Close a socket fd.
fn socketClose(fd: i64) void {
    @fd_close(fd)
}

// ===== High-level TCP Server =====

// Create a TCP server socket bound to the given port on all interfaces.
// Sets SO_REUSEADDR and starts listening with backlog 128.
fn tcpListen(port: i64) NetError!i64 {
    var fd = try tcpSocket()
    setReuseAddr(fd)
    try bindSocket(fd, INADDR_ANY, port)
    try listenSocket(fd, 128)
    return fd
}

// Connect to a TCP server at the given ip and port. Returns connected fd.
fn tcpConnect(ip: i64, port: i64) NetError!i64 {
    var fd = try tcpSocket()
    try connectSocket(fd, ip, port)
    return fd
}

// ===== HTTP Response Builder =====

fn httpResponse(status: i64, body: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    if (status == 200) {
        sb.append("HTTP/1.1 200 OK\r\n")
    } else if (status == 404) {
        sb.append("HTTP/1.1 404 Not Found\r\n")
    } else if (status == 500) {
        sb.append("HTTP/1.1 500 Internal Server Error\r\n")
    } else {
        sb.append("HTTP/1.1 200 OK\r\n")
    }
    sb.append("Content-Type: text/plain\r\n")
    sb.append("Connection: close\r\n")
    sb.append("Content-Length: ")
    sb.appendInt(@lenOf(body))
    sb.append("\r\n\r\n")
    sb.append(body)
    return sb.toString()
}

// ===== HTTP Request Parsing =====
// Reference: Go net/http.ReadRequest — parse method, path, headers, body

// HttpRequest layout — heap-allocated (5 string fields × 16 = 80 bytes):
//   offset  0: method_ptr   (i64)
//   offset  8: method_len   (i64)
//   offset 16: path_ptr     (i64)
//   offset 24: path_len     (i64)
//   offset 32: version_ptr  (i64)
//   offset 40: version_len  (i64)
//   offset 48: headers_ptr  (i64) — raw headers block
//   offset 56: headers_len  (i64)
//   offset 64: body_ptr     (i64)
//   offset 72: body_len     (i64)

fn requestMethod(req: i64) string {
    var p = @intToPtr(*i64, req).*
    var l = @intToPtr(*i64, req + 8).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn requestPath(req: i64) string {
    var p = @intToPtr(*i64, req + 16).*
    var l = @intToPtr(*i64, req + 24).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn requestVersion(req: i64) string {
    var p = @intToPtr(*i64, req + 32).*
    var l = @intToPtr(*i64, req + 40).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn requestHeaders(req: i64) string {
    var p = @intToPtr(*i64, req + 48).*
    var l = @intToPtr(*i64, req + 56).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn requestBody(req: i64) string {
    var p = @intToPtr(*i64, req + 64).*
    var l = @intToPtr(*i64, req + 72).*
    if (l == 0) { return "" }
    return @string(p, l)
}

fn reqSetField(req: i64, offset: i64, s: string) void {
    @intToPtr(*i64, req + offset).* = @ptrOf(s)
    @intToPtr(*i64, req + offset + 8).* = @lenOf(s)
}

// Look up a header value by name from the raw headers block.
// Reference: Go net/http.Header.Get — case-sensitive lookup in "Key: Value\r\n" block
// Returns empty string if header not found.
fn getHeader(req: i64, name: string) string {
    var hdrs = requestHeaders(req)
    var hptr = @ptrOf(hdrs)
    var hlen = @lenOf(hdrs)
    var nptr = @ptrOf(name)
    var nlen = @lenOf(name)
    if (hlen == 0 or nlen == 0) { return "" }

    // Scan for "name: " at start of each line
    var pos: i64 = 0
    while (pos + nlen + 2 <= hlen) {
        // Check if we're at start of line (pos == 0 or prev char was \n)
        var at_line_start: i64 = 0
        if (pos == 0) { at_line_start = 1 }
        else if (@intToPtr(*u8, hptr + pos - 1).* == 10) { at_line_start = 1 }

        if (at_line_start == 1) {
            // Compare header name bytes
            var match: i64 = 1
            var j: i64 = 0
            while (j < nlen and match == 1) {
                if (@intToPtr(*u8, hptr + pos + j).* != @intToPtr(*u8, nptr + j).*) {
                    match = 0
                }
                j = j + 1
            }
            // Check for ": " separator after name
            if (match == 1 and @intToPtr(*u8, hptr + pos + nlen).* == 58 and @intToPtr(*u8, hptr + pos + nlen + 1).* == 32) {
                // Found header. Extract value until \r, \n, or end.
                var val_start = pos + nlen + 2
                var val_end = val_start
                while (val_end < hlen and @intToPtr(*u8, hptr + val_end).* != 13 and @intToPtr(*u8, hptr + val_end).* != 10) {
                    val_end = val_end + 1
                }
                return @string(hptr + val_start, val_end - val_start)
            }
        }
        pos = pos + 1
    }
    return ""
}

// Parse a raw HTTP request string into an HttpRequest object.
// Format: "METHOD /path HTTP/1.1\r\nHeaders\r\n\r\nBody"
// Reference: Go net/http.ReadRequest
fn parseRequest(data: string) i64 {
    var req = @alloc(80)
    var i: i64 = 0
    while (i < 80) {
        @intToPtr(*u8, req + i).* = @intCast(u8, 0)
        i = i + 1
    }

    var dptr = @ptrOf(data)
    var dlen = @lenOf(data)
    if (dlen == 0) { return req }

    // Find first space (end of method)
    var pos: i64 = 0
    while (pos < dlen and @intToPtr(*u8, dptr + pos).* != 32) {
        pos = pos + 1
    }
    reqSetField(req, 0, substring(data, 0, pos))
    pos = pos + 1

    // Find second space (end of path)
    var path_start = pos
    while (pos < dlen and @intToPtr(*u8, dptr + pos).* != 32) {
        pos = pos + 1
    }
    reqSetField(req, 16, substring(data, path_start, pos))
    pos = pos + 1

    // Find end of request line (\r\n)
    var ver_start = pos
    while (pos < dlen - 1) {
        if (@intToPtr(*u8, dptr + pos).* == 13 and @intToPtr(*u8, dptr + pos + 1).* == 10) {
            reqSetField(req, 32, substring(data, ver_start, pos))
            pos = pos + 2
            break
        }
        pos = pos + 1
    }

    // Find end of headers (\r\n\r\n)
    var hdr_start = pos
    while (pos < dlen - 3) {
        if (@intToPtr(*u8, dptr + pos).* == 13 and @intToPtr(*u8, dptr + pos + 1).* == 10 and @intToPtr(*u8, dptr + pos + 2).* == 13 and @intToPtr(*u8, dptr + pos + 3).* == 10) {
            reqSetField(req, 48, substring(data, hdr_start, pos))
            pos = pos + 4
            break
        }
        pos = pos + 1
    }

    // Remaining is body
    if (pos < dlen) {
        reqSetField(req, 64, substring(data, pos, dlen))
    }

    return req
}
