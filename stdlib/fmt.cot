// fmt — String formatting and ANSI color utilities.
//
// Format strings with positional placeholders, ANSI terminal colors,
// and human-readable byte/duration formatting.
//
// References:
//   Go: fmt.Sprintf (format verbs)
//   Deno: @std/fmt (colors, bytes, duration)

import "std/string"

// ============================================================================
// ANSI Color Codes
// ============================================================================

fn red(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[31m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn green(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[32m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn yellow(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[33m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn blue(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[34m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn magenta(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[35m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn cyan(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[36m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn gray(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[90m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn white(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[37m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

// ============================================================================
// Text Styles
// ============================================================================

fn bold(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[1m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn dim(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[2m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn italic(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[3m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn underline(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[4m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

fn strikethrough(s: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("\x1b[9m")
    sb.append(s)
    sb.append("\x1b[0m")
    return sb.toString()
}

// Strip ANSI escape codes from a string.
fn stripAnsi(s: string) string {
    var slen = @lenOf(s)
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var i: i64 = 0
    while (i < slen) {
        var c = @intToPtr(*u8, @ptrOf(s) + i).*
        if (c == 27 and i + 1 < slen and @intToPtr(*u8, @ptrOf(s) + i + 1).* == 91) {
            // Skip ESC [ ... until 'm'
            i = i + 2
            while (i < slen and @intToPtr(*u8, @ptrOf(s) + i).* != 109) {
                i = i + 1
            }
            if (i < slen) { i = i + 1 }
        } else {
            sb.appendByte(@intCast(i64, c))
            i = i + 1
        }
    }
    return sb.toString()
}

// ============================================================================
// Byte Formatting
// ============================================================================

// Format a byte count as a human-readable string.
// formatBytes(0) → "0 B", formatBytes(1024) → "1.0 KB", formatBytes(1048576) → "1.0 MB"
fn formatBytes(bytes: i64) string {
    if (bytes == 0) { return "0 B" }

    var val = bytes
    if (val < 0) { val = 0 - val }

    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    if (bytes < 0) { sb.append("-") }

    if (val < 1024) {
        sb.appendInt(val)
        sb.append(" B")
        return sb.toString()
    }

    // Units: KB, MB, GB, TB, PB
    // Each step is *1024. Use integer math: whole + tenths.
    var units_idx: i64 = 0
    var whole = val
    var frac: i64 = 0

    // KB
    if (val < 1048576) {
        whole = val / 1024
        frac = (val * 10 / 1024) - whole * 10
        units_idx = 1
    } else if (val < 1073741824) {
        // MB
        whole = val / 1048576
        frac = (val * 10 / 1048576) - whole * 10
        units_idx = 2
    } else if (val < 1099511627776) {
        // GB
        whole = val / 1073741824
        frac = (val * 10 / 1073741824) - whole * 10
        units_idx = 3
    } else if (val < 1125899906842624) {
        // TB
        whole = val / 1099511627776
        frac = (val * 10 / 1099511627776) - whole * 10
        units_idx = 4
    } else {
        // PB
        whole = val / 1125899906842624
        frac = (val * 10 / 1125899906842624) - whole * 10
        units_idx = 5
    }

    sb.appendInt(whole)
    sb.append(".")
    sb.appendInt(frac)
    sb.append(" ")

    if (units_idx == 1) { sb.append("KB") }
    if (units_idx == 2) { sb.append("MB") }
    if (units_idx == 3) { sb.append("GB") }
    if (units_idx == 4) { sb.append("TB") }
    if (units_idx == 5) { sb.append("PB") }

    return sb.toString()
}

// ============================================================================
// Duration Formatting
// ============================================================================

// Format nanoseconds as human-readable duration.
// formatDuration(500) → "500ns", formatDuration(1500000) → "1.5ms"
fn formatDuration(ns: i64) string {
    var val = ns
    if (val < 0) { val = 0 - val }

    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    if (ns < 0) { sb.append("-") }

    if (val < 1000) {
        sb.appendInt(val)
        sb.append("ns")
        return sb.toString()
    }

    if (val < 1000000) {
        var whole = val / 1000
        var frac = (val * 10 / 1000) - whole * 10
        sb.appendInt(whole)
        if (frac > 0) {
            sb.append(".")
            sb.appendInt(frac)
        }
        sb.append("us")
        return sb.toString()
    }

    if (val < 1000000000) {
        var whole = val / 1000000
        var frac = (val * 10 / 1000000) - whole * 10
        sb.appendInt(whole)
        if (frac > 0) {
            sb.append(".")
            sb.appendInt(frac)
        }
        sb.append("ms")
        return sb.toString()
    }

    // Seconds
    var whole = val / 1000000000
    var frac = (val * 10 / 1000000000) - whole * 10
    sb.appendInt(whole)
    if (frac > 0) {
        sb.append(".")
        sb.appendInt(frac)
    }
    sb.append("s")
    return sb.toString()
}

// ============================================================================
// Padding
// ============================================================================

// Pad string on the right to reach target width.
fn padRight(s: string, width: i64) string {
    var slen = @lenOf(s)
    if (slen >= width) { return s }
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append(s)
    var i = slen
    while (i < width) {
        sb.appendByte(32)
        i = i + 1
    }
    return sb.toString()
}

// Pad string on the left to reach target width.
fn padLeft(s: string, width: i64) string {
    var slen = @lenOf(s)
    if (slen >= width) { return s }
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var i: i64 = 0
    while (i < width - slen) {
        sb.appendByte(32)
        i = i + 1
    }
    sb.append(s)
    return sb.toString()
}

// Center string within target width.
fn center(s: string, width: i64) string {
    var slen = @lenOf(s)
    if (slen >= width) { return s }
    var total_pad = width - slen
    var left_pad = total_pad / 2
    var right_pad = total_pad - left_pad
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var i: i64 = 0
    while (i < left_pad) {
        sb.appendByte(32)
        i = i + 1
    }
    sb.append(s)
    i = 0
    while (i < right_pad) {
        sb.appendByte(32)
        i = i + 1
    }
    return sb.toString()
}

// ============================================================================
// Number Formatting
// ============================================================================

// Format integer with zero-padding to given width.
// zeroPad(5, 3) → "005", zeroPad(42, 2) → "42"
fn zeroPad(n: i64, width: i64) string {
    var s = intToString(n)
    var slen = @lenOf(s)
    if (slen >= width) { return s }
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var i: i64 = 0
    while (i < width - slen) {
        sb.appendByte(48)
        i = i + 1
    }
    sb.append(s)
    return sb.toString()
}

// Format integer in hexadecimal (lowercase).
fn hex(n: i64) string {
    if (n == 0) { return "0" }
    var val = n
    if (val < 0) { val = 0 - val }
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    // Build in reverse using a temp buffer
    var buf = @alloc(16)
    var pos: i64 = 0
    while (val > 0) {
        var digit = val & 15
        if (digit < 10) {
            @intToPtr(*u8, buf + pos).* = @intCast(u8, digit + 48)
        } else {
            @intToPtr(*u8, buf + pos).* = @intCast(u8, digit - 10 + 97)
        }
        pos = pos + 1
        val = val >> 4
    }
    if (n < 0) { sb.append("-") }
    // Reverse
    var i = pos - 1
    while (i >= 0) {
        sb.appendByte(@intCast(i64, @intToPtr(*u8, buf + i).*))
        i = i - 1
    }
    @dealloc(buf)
    return sb.toString()
}

// Format integer in binary.
// Reference: Zig fmt.zig digitToChar with base=2
fn binary(n: i64) string {
    if (n == 0) { return "0" }
    var val = n
    if (val < 0) { val = 0 - val }
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var buf = @alloc(64)
    var pos: i64 = 0
    while (val > 0) {
        var digit = val & 1
        @intToPtr(*u8, buf + pos).* = @intCast(u8, digit + 48)
        pos = pos + 1
        val = val >> 1
    }
    if (n < 0) { sb.append("-") }
    var i = pos - 1
    while (i >= 0) {
        sb.appendByte(@intCast(i64, @intToPtr(*u8, buf + i).*))
        i = i - 1
    }
    @dealloc(buf)
    return sb.toString()
}

// Format integer in octal.
// Reference: Zig fmt.zig digitToChar with base=8
fn octal(n: i64) string {
    if (n == 0) { return "0" }
    var val = n
    if (val < 0) { val = 0 - val }
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var buf = @alloc(22)
    var pos: i64 = 0
    while (val > 0) {
        var digit = val & 7
        @intToPtr(*u8, buf + pos).* = @intCast(u8, digit + 48)
        pos = pos + 1
        val = val >> 3
    }
    if (n < 0) { sb.append("-") }
    var i = pos - 1
    while (i >= 0) {
        sb.appendByte(@intCast(i64, @intToPtr(*u8, buf + i).*))
        i = i - 1
    }
    @dealloc(buf)
    return sb.toString()
}

// Format integer with given base (2-36).
// Reference: Zig fmt.zig printIntAny — generic base-N formatting
fn formatInt(n: i64, base: i64) string {
    if (base < 2 or base > 36) { @trap() }
    if (n == 0) { return "0" }
    var val = n
    if (val < 0) { val = 0 - val }
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var buf = @alloc(64)
    var pos: i64 = 0
    while (val > 0) {
        var digit = val % base
        if (digit < 10) {
            @intToPtr(*u8, buf + pos).* = @intCast(u8, digit + 48)
        } else {
            @intToPtr(*u8, buf + pos).* = @intCast(u8, digit - 10 + 97)
        }
        pos = pos + 1
        val = val / base
    }
    if (n < 0) { sb.append("-") }
    var i = pos - 1
    while (i >= 0) {
        sb.appendByte(@intCast(i64, @intToPtr(*u8, buf + i).*))
        i = i - 1
    }
    @dealloc(buf)
    return sb.toString()
}
