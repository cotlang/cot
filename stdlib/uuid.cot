// uuid â€” UUID v4 generation.
//
// Generates RFC 4122 version 4 UUIDs (random-based).
// Uses @random builtin for cryptographic randomness.
//
// References:
//   Deno: @std/uuid (v4)
//   Go: google/uuid (NewRandom)

// ============================================================================
// UUID v4 Generation
// ============================================================================

// Generate a new random UUID v4 string.
// Format: "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
// where y is one of [8, 9, a, b].
fn v4() string {
    // Generate 16 random bytes
    var bytes = @alloc(16)
    @random(bytes, 16)

    // Set version to 4: byte[6] = (byte[6] & 0x0f) | 0x40
    var b6 = @intToPtr(*u8, bytes + 6)
    b6.* = @intCast(u8, (@intCast(i64, b6.*) & 15) | 64)

    // Set variant to RFC 4122: byte[8] = (byte[8] & 0x3f) | 0x80
    var b8 = @intToPtr(*u8, bytes + 8)
    b8.* = @intCast(u8, (@intCast(i64, b8.*) & 63) | 128)

    // Format as "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" (36 chars)
    var out = @alloc(36)
    var oi: i64 = 0
    var bi: i64 = 0
    while (bi < 16) {
        var need_dash = false
        if (bi == 4) { need_dash = true }
        if (bi == 6) { need_dash = true }
        if (bi == 8) { need_dash = true }
        if (bi == 10) { need_dash = true }
        if (need_dash) {
            @intToPtr(*u8, out + oi).* = @intCast(u8, 45)
            oi = oi + 1
        }
        var b = @intCast(i64, @intToPtr(*u8, bytes + bi).*)
        var hi = b >> 4
        var lo = b & 15
        @intToPtr(*u8, out + oi).* = @intCast(u8, hexChar(hi))
        @intToPtr(*u8, out + oi + 1).* = @intCast(u8, hexChar(lo))
        oi = oi + 2
        bi = bi + 1
    }

    @dealloc(bytes)
    return @string(out, 36)
}

fn hexChar(v: i64) i64 {
    if (v < 10) { return v + 48 }
    return v - 10 + 97
}

// Check if a string is a valid UUID v4 format.
// Validates format: 8-4-4-4-12 hex chars with dashes.
fn isValid(s: string) bool {
    if (@lenOf(s) != 36) { return false }
    var i: i64 = 0
    while (i < 36) {
        var c = @intCast(i64, @intToPtr(*u8, @ptrOf(s) + i).*)
        if (i == 8 or i == 13 or i == 18 or i == 23) {
            if (c != 45) { return false }
        } else {
            if (!isHexDigit(c)) { return false }
        }
        i = i + 1
    }
    // Check version nibble (position 14 must be '4')
    var v = @intCast(i64, @intToPtr(*u8, @ptrOf(s) + 14).*)
    if (v != 52) { return false }
    // Check variant nibble (position 19 must be 8, 9, a, or b)
    var y = @intCast(i64, @intToPtr(*u8, @ptrOf(s) + 19).*)
    if (y != 56 and y != 57 and y != 97 and y != 98) { return false }
    return true
}

fn isHexDigit(c: i64) bool {
    if (c >= 48 and c <= 57) { return true }
    if (c >= 97 and c <= 102) { return true }
    if (c >= 65 and c <= 70) { return true }
    return false
}

// Return the version number from a UUID string (should be 4 for v4).
fn version(s: string) i64 {
    if (@lenOf(s) < 15) { return 0 - 1 }
    var c = @intCast(i64, @intToPtr(*u8, @ptrOf(s) + 14).*)
    if (c >= 48 and c <= 57) { return c - 48 }
    return 0 - 1
}
