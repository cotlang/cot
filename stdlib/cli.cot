// cli â€” Command-line argument parsing.
//
// Parse flags (--name=value, --flag, -f), positional arguments,
// and generate --help output.
//
// References:
//   Go: flag package (flag.String, flag.Int, flag.Bool, flag.Parse)
//   Deno: @std/cli (parseArgs)

import "std/string"
import "std/os"
import "std/list"

// ============================================================================
// Parsed Result
// ============================================================================

// A parsed CLI result stored as parallel arrays.
// Flags: name/value pairs. Positional: ordered args.
// Heap-allocated via @alloc.
//
// Layout (8 bytes each):
//   [0]  flag_keys_buf     (i64 ptr to keys buffer)
//   [8]  flag_vals_buf     (i64 ptr to values buffer)
//   [16] flag_count        (i64)
//   [24] flag_cap          (i64)
//   [32] positional_buf    (i64 ptr to args buffer)
//   [40] positional_count  (i64)
//   [48] positional_cap    (i64)

fn newArgs() i64 {
    var p = @alloc(56)
    @intToPtr(*i64, p).* = 0
    @intToPtr(*i64, p + 8).* = 0
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = 0
    @intToPtr(*i64, p + 32).* = 0
    @intToPtr(*i64, p + 40).* = 0
    @intToPtr(*i64, p + 48).* = 0
    return p
}

// ============================================================================
// Internal: Flag Storage
// ============================================================================

fn addFlag(args: i64, key: string, val: string) void {
    var count = @intToPtr(*i64, args + 16).*
    var cap = @intToPtr(*i64, args + 24).*

    if (count >= cap) {
        var new_cap = cap * 2
        if (new_cap == 0) { new_cap = 8 }

        var keys_buf = @intToPtr(*i64, args).*
        var vals_buf = @intToPtr(*i64, args + 8).*

        // Each entry is 16 bytes (ptr + len for string)
        var new_keys = @alloc(new_cap * 16)
        var new_vals = @alloc(new_cap * 16)

        if (count > 0) {
            @memcpy(new_keys, keys_buf, count * 16)
            @memcpy(new_vals, vals_buf, count * 16)
            @dealloc(keys_buf)
            @dealloc(vals_buf)
        }

        @intToPtr(*i64, args).* = new_keys
        @intToPtr(*i64, args + 8).* = new_vals
        @intToPtr(*i64, args + 24).* = new_cap
    }

    var keys_buf = @intToPtr(*i64, args).*
    var vals_buf = @intToPtr(*i64, args + 8).*

    // Store key string (ptr at offset, len at offset+8)
    @intToPtr(*i64, keys_buf + count * 16).* = @ptrOf(key)
    @intToPtr(*i64, keys_buf + count * 16 + 8).* = @lenOf(key)

    // Store val string
    @intToPtr(*i64, vals_buf + count * 16).* = @ptrOf(val)
    @intToPtr(*i64, vals_buf + count * 16 + 8).* = @lenOf(val)

    @intToPtr(*i64, args + 16).* = count + 1
}

fn addPositional(args: i64, val: string) void {
    var count = @intToPtr(*i64, args + 40).*
    var cap = @intToPtr(*i64, args + 48).*

    if (count >= cap) {
        var new_cap = cap * 2
        if (new_cap == 0) { new_cap = 8 }

        var buf = @intToPtr(*i64, args + 32).*
        var new_buf = @alloc(new_cap * 16)

        if (count > 0) {
            @memcpy(new_buf, buf, count * 16)
            @dealloc(buf)
        }

        @intToPtr(*i64, args + 32).* = new_buf
        @intToPtr(*i64, args + 48).* = new_cap
    }

    var buf = @intToPtr(*i64, args + 32).*
    @intToPtr(*i64, buf + count * 16).* = @ptrOf(val)
    @intToPtr(*i64, buf + count * 16 + 8).* = @lenOf(val)

    @intToPtr(*i64, args + 40).* = count + 1
}

// ============================================================================
// Parsing
// ============================================================================

// Parse process arguments (skipping argv[0] which is the program name).
fn parseArgs() i64 {
    var result = newArgs()
    var argc = argsCount()
    var i: i64 = 1

    while (i < argc) {
        var a = arg(i)
        var alen = @lenOf(a)

        if (alen >= 2 and @intToPtr(*u8, @ptrOf(a)).* == 45 and @intToPtr(*u8, @ptrOf(a) + 1).* == 45) {
            // Long flag: --name or --name=value
            var flag_start: i64 = 2
            var eq_pos = indexOf(a, "=")
            if (eq_pos >= 0) {
                var key = substring(a, flag_start, eq_pos)
                var val = substring(a, eq_pos + 1, alen)
                addFlag(result, key, val)
            } else {
                var key = substring(a, flag_start, alen)
                // Check if this is -- (end of flags)
                if (@lenOf(key) == 0) {
                    // Everything after -- is positional
                    i = i + 1
                    while (i < argc) {
                        addPositional(result, arg(i))
                        i = i + 1
                    }
                    return result
                }
                addFlag(result, key, "true")
            }
        } else if (alen >= 2 and @intToPtr(*u8, @ptrOf(a)).* == 45) {
            // Short flag: -f or -f value
            var key = substring(a, 1, alen)
            if (@lenOf(key) == 1 and i + 1 < argc) {
                var next = arg(i + 1)
                // If next arg doesn't start with -, treat as value
                if (@lenOf(next) > 0 and @intToPtr(*u8, @ptrOf(next)).* != 45) {
                    addFlag(result, key, next)
                    i = i + 1
                } else {
                    addFlag(result, key, "true")
                }
            } else {
                addFlag(result, key, "true")
            }
        } else {
            addPositional(result, a)
        }

        i = i + 1
    }

    return result
}

// ============================================================================
// Accessors
// ============================================================================

// Get number of parsed flags.
fn flagCount(args: i64) i64 {
    return @intToPtr(*i64, args + 16).*
}

// Get flag key at index.
fn flagKey(args: i64, index: i64) string {
    var keys_buf = @intToPtr(*i64, args).*
    var ptr = @intToPtr(*i64, keys_buf + index * 16).*
    var len = @intToPtr(*i64, keys_buf + index * 16 + 8).*
    return @string(ptr, len)
}

// Get flag value at index.
fn flagValue(args: i64, index: i64) string {
    var vals_buf = @intToPtr(*i64, args + 8).*
    var ptr = @intToPtr(*i64, vals_buf + index * 16).*
    var len = @intToPtr(*i64, vals_buf + index * 16 + 8).*
    return @string(ptr, len)
}

// Get a flag value by name. Returns the default if not found.
fn getFlag(args: i64, name: string, default: string) string {
    var count = flagCount(args)
    var i: i64 = 0
    while (i < count) {
        if (flagKey(args, i) == name) {
            return flagValue(args, i)
        }
        i = i + 1
    }
    return default
}

// Check if a flag exists.
fn hasFlag(args: i64, name: string) bool {
    var count = flagCount(args)
    var i: i64 = 0
    while (i < count) {
        if (flagKey(args, i) == name) {
            return true
        }
        i = i + 1
    }
    return false
}

// Get a flag value as integer. Returns the default if not found or not a number.
fn getFlagInt(args: i64, name: string, default: i64) i64 {
    var val = getFlag(args, name, "")
    if (@lenOf(val) == 0) { return default }
    return parseIntOr(val, default)
}

// Get number of positional arguments.
fn positionalCount(args: i64) i64 {
    return @intToPtr(*i64, args + 40).*
}

// Get positional argument at index.
fn positional(args: i64, index: i64) string {
    var buf = @intToPtr(*i64, args + 32).*
    var ptr = @intToPtr(*i64, buf + index * 16).*
    var len = @intToPtr(*i64, buf + index * 16 + 8).*
    return @string(ptr, len)
}
