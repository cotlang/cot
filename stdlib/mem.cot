// mem — Byte-level memory operations.
//
// Operates on raw pointers + lengths (not string type).
// For string operations, use std/string instead.
//
// Reference: Zig std/mem.zig (eql, indexOf, startsWith, endsWith, zeroes)

// Compare two byte regions for equality.
// Reference: Zig mem.eql(u8, a, b) — length check then byte-by-byte
fn eql(a: i64, a_len: i64, b: i64, b_len: i64) bool {
    if (a_len != b_len) { return false }
    if (a == b) { return true }
    if (a_len == 0) { return true }
    var i: i64 = 0
    while (i < a_len) {
        var ca = @intToPtr(*u8, a + i).*
        var cb = @intToPtr(*u8, b + i).*
        if (ca != cb) { return false }
        i = i + 1
    }
    return true
}

// Lexicographic comparison of two byte regions.
// Returns -1 if a < b, 0 if equal, 1 if a > b.
// Reference: C memcmp — byte-by-byte comparison
fn cmp(a: i64, a_len: i64, b: i64, b_len: i64) i64 {
    var min_len = a_len
    if (b_len < min_len) { min_len = b_len }
    var i: i64 = 0
    while (i < min_len) {
        var ca = @intToPtr(*u8, a + i).*
        var cb = @intToPtr(*u8, b + i).*
        if (ca < cb) { return 0 - 1 }
        if (ca > cb) { return 1 }
        i = i + 1
    }
    if (a_len < b_len) { return 0 - 1 }
    if (a_len > b_len) { return 1 }
    return 0
}

// Find first occurrence of a given value in a byte region.
// Returns index or -1 if not found.
// Reference: Zig mem.indexOfScalar(u8, slice, value)
fn indexOfScalar(ptr: i64, len: i64, b: i64) i64 {
    var i: i64 = 0
    while (i < len) {
        if (@intToPtr(*u8, ptr + i).* == b) { return i }
        i = i + 1
    }
    return 0 - 1
}

// Find last occurrence of a given value in a byte region.
// Returns index or -1 if not found.
// Reference: Zig mem.lastIndexOfScalar(u8, slice, value)
fn lastIndexOfScalar(ptr: i64, len: i64, b: i64) i64 {
    var i = len - 1
    while (i >= 0) {
        if (@intToPtr(*u8, ptr + i).* == b) { return i }
        i = i - 1
    }
    return 0 - 1
}

// Check if byte region starts with prefix.
// Reference: Zig mem.startsWith(u8, haystack, needle)
fn startsWith(ptr: i64, len: i64, prefix: i64, prefix_len: i64) bool {
    if (prefix_len > len) { return false }
    return eql(ptr, prefix_len, prefix, prefix_len)
}

// Check if byte region ends with suffix.
// Reference: Zig mem.endsWith(u8, haystack, needle)
fn endsWith(ptr: i64, len: i64, suffix: i64, suffix_len: i64) bool {
    if (suffix_len > len) { return false }
    return eql(ptr + len - suffix_len, suffix_len, suffix, suffix_len)
}

// Set all bytes in a region to zero.
// Reference: Zig @memset(slice, 0)
fn zero(ptr: i64, len: i64) void {
    var i: i64 = 0
    while (i < len) {
        @intToPtr(*u8, ptr + i).* = 0
        i = i + 1
    }
}

// Set all bytes in a region to a given value.
// Reference: C memset
fn set(ptr: i64, len: i64, value: i64) void {
    var i: i64 = 0
    while (i < len) {
        @intToPtr(*u8, ptr + i).* = @intCast(u8, value)
        i = i + 1
    }
}

// Count occurrences of a value in a byte region.
// Reference: Zig mem.count(u8, slice, value)
fn countScalar(ptr: i64, len: i64, b: i64) i64 {
    var n: i64 = 0
    var i: i64 = 0
    while (i < len) {
        if (@intToPtr(*u8, ptr + i).* == b) { n = n + 1 }
        i = i + 1
    }
    return n
}

// Read a little-endian u16 from a pointer.
fn readU16LE(ptr: i64) i64 {
    var b0 = @intToPtr(*u8, ptr).*
    var b1 = @intToPtr(*u8, ptr + 1).*
    return b0 + b1 * 256
}

// Read a little-endian u32 from a pointer.
fn readU32LE(ptr: i64) i64 {
    var b0 = @intToPtr(*u8, ptr).*
    var b1 = @intToPtr(*u8, ptr + 1).*
    var b2 = @intToPtr(*u8, ptr + 2).*
    var b3 = @intToPtr(*u8, ptr + 3).*
    return b0 + b1 * 256 + b2 * 65536 + b3 * 16777216
}

// Write a little-endian u16 to a pointer.
fn writeU16LE(ptr: i64, val: i64) void {
    @intToPtr(*u8, ptr).* = @intCast(u8, val & 255)
    @intToPtr(*u8, ptr + 1).* = @intCast(u8, (val >> 8) & 255)
}

// Write a little-endian u32 to a pointer.
fn writeU32LE(ptr: i64, val: i64) void {
    @intToPtr(*u8, ptr).* = @intCast(u8, val & 255)
    @intToPtr(*u8, ptr + 1).* = @intCast(u8, (val >> 8) & 255)
    @intToPtr(*u8, ptr + 2).* = @intCast(u8, (val >> 16) & 255)
    @intToPtr(*u8, ptr + 3).* = @intCast(u8, (val >> 24) & 255)
}
