// cot-mcp â€” MCP server for Cot language tools.
//
// Provides Claude with Cot syntax reference, stdlib docs, and project info.
// Protocol: JSON-RPC 2.0 over stdio, newline-delimited.

import "std/json"
import "std/string"
import "std/io"

// ============================================================================
// JSON-RPC response builders
// ============================================================================

fn makeResponse(id_val: i64, result: i64) i64 {
    var resp = jsonObject()
    jsonObjectPut(resp, "jsonrpc", jsonString("2.0"))
    jsonObjectPut(resp, "id", jsonInt(id_val))
    jsonObjectPut(resp, "result", result)
    return resp
}

fn makeToolResponse(id_val: i64, text: string) i64 {
    var item = jsonObject()
    jsonObjectPut(item, "type", jsonString("text"))
    jsonObjectPut(item, "text", jsonString(text))

    var content = jsonArray()
    jsonArrayPush(content, item)

    var result = jsonObject()
    jsonObjectPut(result, "content", content)
    return makeResponse(id_val, result)
}

fn makeError(id_val: i64, code: i64, message: string) i64 {
    var err = jsonObject()
    jsonObjectPut(err, "code", jsonInt(code))
    jsonObjectPut(err, "message", jsonString(message))

    var resp = jsonObject()
    jsonObjectPut(resp, "jsonrpc", jsonString("2.0"))
    jsonObjectPut(resp, "id", jsonInt(id_val))
    jsonObjectPut(resp, "error", err)
    return resp
}

// ============================================================================
// MCP handlers
// ============================================================================

fn handleInitialize(id_val: i64) i64 {
    var caps = jsonObject()
    jsonObjectPut(caps, "tools", jsonObject())

    var info = jsonObject()
    jsonObjectPut(info, "name", jsonString("cot-tools"))
    jsonObjectPut(info, "version", jsonString("0.3.1"))

    var result = jsonObject()
    jsonObjectPut(result, "protocolVersion", jsonString("2024-11-05"))
    jsonObjectPut(result, "capabilities", caps)
    jsonObjectPut(result, "serverInfo", info)
    return makeResponse(id_val, result)
}

fn handleToolsList(id_val: i64) i64 {
    var tools = jsonArray()

    var schema1 = jsonObject()
    jsonObjectPut(schema1, "type", jsonString("object"))
    var t1 = jsonObject()
    jsonObjectPut(t1, "name", jsonString("get_syntax_reference"))
    jsonObjectPut(t1, "description", jsonString("Get Cot language syntax cheat sheet"))
    jsonObjectPut(t1, "inputSchema", schema1)
    jsonArrayPush(tools, t1)

    var module_prop = jsonObject()
    jsonObjectPut(module_prop, "type", jsonString("string"))
    jsonObjectPut(module_prop, "description", jsonString("Module: json string fs io list map os time random sort set math"))
    var props2 = jsonObject()
    jsonObjectPut(props2, "module", module_prop)
    var schema2 = jsonObject()
    jsonObjectPut(schema2, "type", jsonString("object"))
    jsonObjectPut(schema2, "properties", props2)
    var t2 = jsonObject()
    jsonObjectPut(t2, "name", jsonString("get_stdlib_docs"))
    jsonObjectPut(t2, "description", jsonString("Get Cot stdlib function signatures"))
    jsonObjectPut(t2, "inputSchema", schema2)
    jsonArrayPush(tools, t2)

    var schema3 = jsonObject()
    jsonObjectPut(schema3, "type", jsonString("object"))
    var t3 = jsonObject()
    jsonObjectPut(t3, "name", jsonString("get_project_info"))
    jsonObjectPut(t3, "description", jsonString("Get Cot build/test commands and project structure"))
    jsonObjectPut(t3, "inputSchema", schema3)
    jsonArrayPush(tools, t3)

    var result = jsonObject()
    jsonObjectPut(result, "tools", tools)
    return makeResponse(id_val, result)
}

fn handleToolsCall(req: i64, id_val: i64) i64 {
    var params = jsonObjectGet(req, "params")
    if params == 0 { return makeError(id_val, 0 - 32602, "Missing params") }
    var name = jsonObjectGetString(params, "name")
    if @lenOf(name) == 0 { return makeError(id_val, 0 - 32602, "Missing tool name") }

    if name == "get_syntax_reference" {
        var text = syntaxReference()
        return makeToolResponse(id_val, text)
    }
    if name == "get_stdlib_docs" {
        var args = jsonObjectGet(params, "arguments")
        var module = ""
        if args != 0 {
            module = jsonObjectGetString(args, "module")
        }
        var text = stdlibDocs(module)
        return makeToolResponse(id_val, text)
    }
    if name == "get_project_info" {
        var text = projectInfo()
        return makeToolResponse(id_val, text)
    }
    return makeError(id_val, 0 - 32602, "Unknown tool")
}

// ============================================================================
// Request routing
// ============================================================================

fn getIdVal(req: i64) i64 {
    var id = jsonObjectGet(req, "id")
    if id == 0 { return 0 }
    return jsonGetInt(id)
}

fn handleRequest(req: i64, writer: i64) void {
    var method = jsonObjectGetString(req, "method")
    var id_val = getIdVal(req)

    var response: i64 = 0
    if method == "initialize" {
        response = handleInitialize(id_val)
    } else if method == "tools/list" {
        response = handleToolsList(id_val)
    } else if method == "tools/call" {
        response = handleToolsCall(req, id_val)
    } else if method == "notifications/initialized" {
        return
    } else {
        if id_val != 0 {
            response = makeError(id_val, 0 - 32601, "Method not found")
        }
    }

    if response != 0 {
        var out = encode(response)
        writeString(writer, out)
        writeByte(writer, 10)
        writerFlush(writer)
    }
}

// ============================================================================
// Main
// ============================================================================

fn main() i64 {
    var reader = newBufferedReader(0)
    var writer = newBufferedWriter(1)

    var running: i64 = 1
    while running == 1 {
        var line = readLine(reader)
        if @lenOf(line) == 0 {
            running = 0
        } else {
            var request = parse(line)
            handleRequest(request, writer)
        }
    }
    return 0
}

// ============================================================================
// Tool: get_syntax_reference
// ============================================================================

fn syntaxReference() string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("# Cot Language Syntax Reference\n\n")

    sb.append("## Variables & Constants\n")
    sb.append("const x: i64 = 10    // immutable, typed\n")
    sb.append("const y = 20         // immutable, inferred\n")
    sb.append("var z = 30           // mutable, inferred\n")
    sb.append("No semicolons.\n\n")

    sb.append("## Types\n")
    sb.append("Primitives: i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 bool void\n")
    sb.append("Aliases: int=i64, float=f64, byte=u8, string=[]u8\n")
    sb.append("Composite: *T (pointer), ?T (optional), E!T (error union)\n\n")

    sb.append("## Functions\n")
    sb.append("fn add(a: i64, b: i64) i64 { return a + b }\n")
    sb.append("fn noop() void { }\n")
    sb.append("fn apply(f: fn(i64) -> i64, x: i64) i64 { return f(x) }\n\n")

    sb.append("## Generics (separate parens, NOT angle brackets)\n")
    sb.append("fn max(T)(a: T, b: T) T { if a > b { return a } return b }\n")
    sb.append("struct Box(T) { value: T }\n")
    sb.append("var b = Box(i64) { .value = 42 }\n\n")

    sb.append("## Structs\n")
    sb.append("struct Point { x: i64, y: i64 }\n")
    sb.append("// Stack init (PERIOD prefix, EQUALS sign):\n")
    sb.append("var p = Point { .x = 10, .y = 20 }\n")
    sb.append("// Heap init (NO period, COLON separator):\n")
    sb.append("var h = new Point { x: 10, y: 20 }\n\n")

    sb.append("## Methods (explicit self, like Zig)\n")
    sb.append("impl Point {\n")
    sb.append("    fn sum(self: Point) i64 { return self.x + self.y }\n")
    sb.append("}\n\n")

    sb.append("## Control Flow\n")
    sb.append("if condition { } else if other { } else { }\n")
    sb.append("while condition { }\n")
    sb.append("for item in collection { }\n")
    sb.append("break / continue\n")
    sb.append("Logical: and, or, not (NOT &&, ||, !)\n\n")

    sb.append("## Error Handling (Zig-style)\n")
    sb.append("const MyError = error { NotFound, IoError }\n")
    sb.append("fn read() MyError!i64 { return error.IoError }\n")
    sb.append("var val = read() catch 0    // catch with default\n")
    sb.append("var val = try read()        // propagate error\n\n")

    sb.append("## Imports\n")
    sb.append("import \"std/json\"          // stdlib module\n")
    sb.append("import \"std/string\"        // stdlib module\n")
    sb.append("import \"./myfile\"          // relative file\n\n")

    sb.append("## Builtins\n")
    sb.append("@alloc(size)  @dealloc(ptr)  @realloc(ptr, size)\n")
    sb.append("@memcpy(dst, src, len)  @sizeOf(T)  @intCast(T, val)\n")
    sb.append("@intToPtr(*T, addr)  @string(ptr, len)\n")
    sb.append("@ptrOf(s)  @lenOf(s)  @assert(cond)  @assert_eq(a, b)\n")
    sb.append("@print(val)  @trap()  @target_os()\n")
    sb.append("@fd_read(fd, buf, len)  @fd_write(fd, buf, len)\n")
    sb.append("@fd_open(ptr, len, flags)  @fd_close(fd)  @fd_seek(fd, off, whence)\n\n")

    sb.append("## Tests\n")
    sb.append("test \"my test\" { @assert_eq(1 + 1, 2) }\n")
    sb.append("Run: cot test file.cot\n")

    var result = sb.toString()
    return result
}

// ============================================================================
// Tool: get_stdlib_docs
// ============================================================================

fn stdlibDocs(module: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }

    if @lenOf(module) == 0 {
        sb.append("# Cot Stdlib Modules\n\n")
        sb.append("Available: json, string, fs, io, list, map, os, time, random, sort, set, math\n")
        sb.append("Use get_stdlib_docs with module param for details.\n")
        var result = sb.toString()
        return result
    }

    if module == "json" {
        sb.append("# std/json\n\n")
        sb.append("JSON parser + encoder. Values are heap-allocated i64 pointers.\n\n")
        sb.append("## Constructors (return i64)\n")
        sb.append("jsonNull()  jsonBool(val: bool)  jsonInt(val: i64)  jsonString(val: string)\n")
        sb.append("jsonArray()  jsonObject()\n\n")
        sb.append("## Accessors\n")
        sb.append("jsonTag(val: i64) i64       // 0=null 1=bool 2=int 3=string 4=array 5=object\n")
        sb.append("jsonIsNull(val: i64) bool\n")
        sb.append("jsonGetBool(val: i64) bool  jsonGetInt(val: i64) i64  jsonGetString(val: i64) string\n\n")
        sb.append("## Array ops\n")
        sb.append("jsonArrayLen(val: i64) i64  jsonArrayGet(val: i64, index: i64) i64\n")
        sb.append("jsonArrayPush(arr: i64, val: i64) void\n\n")
        sb.append("## Object ops\n")
        sb.append("jsonObjectLen(val: i64) i64  jsonObjectPut(obj: i64, key: string, val: i64) void\n")
        sb.append("jsonObjectGet(obj: i64, key: string) i64\n")
        sb.append("jsonObjectGetString(obj: i64, key: string) string\n")
        sb.append("jsonObjectGetInt(obj: i64, key: string) i64\n\n")
        sb.append("## Parse/Encode\n")
        sb.append("parse(input: string) i64    encode(val: i64) string\n")
    } else if module == "string" {
        sb.append("# std/string\n\n")
        sb.append("charAt(s, index) i64  indexOf(s, needle) i64  lastIndexOf(s, needle) i64\n")
        sb.append("contains(s, needle) bool  startsWith(s, prefix) bool  endsWith(s, suffix) bool\n")
        sb.append("count(s, needle) i64  substring(s, start, end) string\n")
        sb.append("trim(s) string  trimLeft(s) string  trimRight(s) string\n")
        sb.append("toUpper(s) string  toLower(s) string  replace(s, old, new) string\n")
        sb.append("repeat(s, n) string  parseInt(s) i64  intToString(n) string\n")
        sb.append("compare(a, b) i64  splitInto(s, sep, result: *List(string)) void\n\n")
        sb.append("## StringBuilder\n")
        sb.append("var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }\n")
        sb.append("sb.append(s)  sb.appendByte(b)  sb.appendInt(n)\n")
        sb.append("sb.toString() string  sb.length() i64  sb.clear()  sb.free()\n")
    } else if module == "fs" {
        sb.append("# std/fs\n\n")
        sb.append("struct File { fd: i64 }\n")
        sb.append("openFile(path: string, flags: i64) File\n")
        sb.append("createFile(path: string) File\n")
        sb.append("readFile(path: string) string  writeFile(path: string, data: string) void\n")
        sb.append("stdin() File  stdout() File  stderr() File\n\n")
        sb.append("## File methods\n")
        sb.append("f.read(buf, len) FsError!i64  f.write(buf, len) FsError!i64\n")
        sb.append("f.writeAll(s: string) FsError!i64  f.close() void  f.isValid() i64\n")
        sb.append("f.seekTo(pos) FsError!i64  f.seekBy(delta) FsError!i64  f.getPos() FsError!i64\n\n")
        sb.append("## Flags\n")
        sb.append("O_RDONLY=0  O_WRONLY=1  O_RDWR=2  O_CREATE  O_WRITE_CREATE\n")
    } else if module == "io" {
        sb.append("# std/io\n\n")
        sb.append("Buffered I/O. State is heap-allocated (i64 pointer).\n\n")
        sb.append("## BufferedReader\n")
        sb.append("newBufferedReader(fd: i64) i64\n")
        sb.append("newBufferedReaderSize(fd: i64, size: i64) i64\n")
        sb.append("readByte(r: i64) i64           // -1 on EOF\n")
        sb.append("readLine(r: i64) string         // empty string on EOF\n")
        sb.append("readerFill(r: i64) void\n\n")
        sb.append("## BufferedWriter\n")
        sb.append("newBufferedWriter(fd: i64) i64\n")
        sb.append("newBufferedWriterSize(fd: i64, size: i64) i64\n")
        sb.append("writeByte(w: i64, b: i64) void\n")
        sb.append("writeString(w: i64, s: string) void\n")
        sb.append("writerWriteAll(w: i64, ptr: i64, len: i64) void\n")
        sb.append("writerFlush(w: i64) void\n")
    } else if module == "list" {
        sb.append("# std/list\n\n")
        sb.append("struct List(T) { items: i64, count: i64, capacity: i64 }\n")
        sb.append("var l: List(i64) = .{}\n\n")
        sb.append("## Core\n")
        sb.append("l.append(val)  l.get(i) T  l.set(i, val)  l.pop() T\n")
        sb.append("l.len() i64  l.cap() i64  l.first() T  l.last() T\n\n")
        sb.append("## Modify\n")
        sb.append("l.insert(i, val)  l.orderedRemove(i) T  l.swapRemove(i) T\n")
        sb.append("l.appendSlice(src, n)  l.reverse()  l.clone() List(T)\n")
        sb.append("l.clear()  l.free()  l.resize(n)  l.sort(cmp)\n\n")
        sb.append("## Search\n")
        sb.append("l.indexOf(val) i64  l.contains(val) i64  l.equal(other) i64\n")
    } else if module == "map" {
        sb.append("# std/map\n\n")
        sb.append("struct Map(K, V) -- hash map with open addressing.\n")
        sb.append("var m: Map(i64, i64) = .{}\n\n")
        sb.append("m.set(key, val)  m.get(key) V  m.contains(key) i64\n")
        sb.append("m.remove(key) i64  m.len() i64  m.clear()  m.free()\n")
        sb.append("m.keys() List(K)  m.values() List(V)\n")
    } else if module == "os" {
        sb.append("# std/os\n\n")
        sb.append("exit(code: i64)  argsCount() i64  argLen(n) i64  argPtr(n) i64\n")
        sb.append("arg(n: i64) string  environ(n: i64) string\n")
        sb.append("environCount() i64  environLen(n) i64  environPtr(n) i64\n")
    } else if module == "time" {
        sb.append("# std/time\n\n")
        sb.append("nanoTimestamp() i64  milliTimestamp() i64  timestamp() i64\n")
        sb.append("struct Timer { start_time: i64 }\n")
        sb.append("t.elapsed() i64  t.reset() void\n")
        sb.append("ns_per_ms=1000000  ns_per_s=1000000000  ms_per_s=1000\n")
    } else if module == "random" {
        sb.append("# std/random\n\n")
        sb.append("fillBytes(buf: i64, len: i64) i64\n")
        sb.append("randomInt() i64  randomRange(max: i64) i64\n")
    } else if module == "sort" {
        sb.append("# std/sort\n\n")
        sb.append("insertionSort for List(T) with comparator function.\n")
    } else if module == "set" {
        sb.append("# std/set\n\n")
        sb.append("struct Set(T) -- hash set.\n")
        sb.append("var s: Set(i64) = .{}\n")
        sb.append("s.add(val)  s.contains(val) i64  s.remove(val) i64\n")
        sb.append("s.len() i64  s.clear()  s.free()\n")
    } else if module == "math" {
        sb.append("# std/math\n\n")
        sb.append("abs(x) i64  min(a, b) i64  max(a, b) i64  clamp(x, lo, hi) i64\n")
        sb.append("@sqrt(x)  @floor(x)  @ceil(x)  @fabs(x)  @min(a,b)  @max(a,b)\n")
    } else {
        sb.append("Unknown module: ")
        sb.append(module)
        sb.append("\nAvailable: json, string, fs, io, list, map, os, time, random, sort, set, math\n")
    }

    var result = sb.toString()
    return result
}

// ============================================================================
// Tool: get_project_info
// ============================================================================

fn projectInfo() string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("# Cot Project Info\n\n")

    sb.append("## CLI Commands\n")
    sb.append("cot build <file.cot> [-o name]  # Compile to native executable\n")
    sb.append("cot build <file.cot> --target=wasm32  # Compile to .wasm\n")
    sb.append("cot run <file.cot> [-- args]    # Compile + run + cleanup\n")
    sb.append("cot test <file.cot>             # Run tests (test blocks)\n")
    sb.append("cot lsp                         # Language server (stdio)\n\n")

    sb.append("## Project Structure\n")
    sb.append("compiler/           Zig compiler source\n")
    sb.append("stdlib/             Standard library (.cot files)\n")
    sb.append("  json.cot          JSON parser + encoder\n")
    sb.append("  string.cot        String ops + StringBuilder\n")
    sb.append("  list.cot          Generic dynamic array List(T)\n")
    sb.append("  map.cot           Generic hash map Map(K, V)\n")
    sb.append("  set.cot           Generic hash set Set(T)\n")
    sb.append("  fs.cot            File I/O (File struct, readFile, writeFile)\n")
    sb.append("  io.cot            Buffered I/O (BufferedReader, BufferedWriter)\n")
    sb.append("  os.cot            Process args, env, exit\n")
    sb.append("  time.cot          Timestamps, Timer\n")
    sb.append("  random.cot        Random bytes, integers\n")
    sb.append("  sort.cot          Insertion sort for List(T)\n")
    sb.append("  math.cot          abs, min, max, clamp\n")
    sb.append("test/e2e/           End-to-end tests\n")
    sb.append("test/cases/         Category unit tests\n\n")

    sb.append("## Writing Tests\n")
    sb.append("test \"name\" { @assert_eq(1 + 1, 2) }\n")
    sb.append("test \"strings\" { @assert_eq(\"hello\", \"hello\") }\n")
    sb.append("Run: cot test file.cot\n\n")

    sb.append("## Architecture\n")
    sb.append("Cot -> Scanner -> Parser -> Checker -> IR -> SSA\n")
    sb.append("  -> Wasm bytecode\n")
    sb.append("    -> .wasm file (--target=wasm32)\n")
    sb.append("    -> native AOT via CLIF (default)\n")
    sb.append("Compiler is written in Zig. Language follows Zig patterns.\n")

    var result = sb.toString()
    return result
}
