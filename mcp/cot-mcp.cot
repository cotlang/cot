// cot-mcp — MCP server for Cot language tools.
//
// Provides Claude with Cot syntax reference, stdlib docs, and project info.
// Protocol: JSON-RPC 2.0 over stdio, newline-delimited.

import "std/json"
import "std/string"
import "std/io"

// ============================================================================
// JSON-RPC response builders
// ============================================================================

fn makeResponse(id_val: i64, result: i64) i64 {
    var resp = jsonObject()
    jsonObjectPut(resp, "jsonrpc", jsonString("2.0"))
    jsonObjectPut(resp, "id", jsonInt(id_val))
    jsonObjectPut(resp, "result", result)
    return resp
}

fn makeToolResponse(id_val: i64, text: string) i64 {
    var item = jsonObject()
    jsonObjectPut(item, "type", jsonString("text"))
    jsonObjectPut(item, "text", jsonString(text))

    var content = jsonArray()
    jsonArrayPush(content, item)

    var result = jsonObject()
    jsonObjectPut(result, "content", content)
    return makeResponse(id_val, result)
}

fn makeError(id_val: i64, code: i64, message: string) i64 {
    var err = jsonObject()
    jsonObjectPut(err, "code", jsonInt(code))
    jsonObjectPut(err, "message", jsonString(message))

    var resp = jsonObject()
    jsonObjectPut(resp, "jsonrpc", jsonString("2.0"))
    jsonObjectPut(resp, "id", jsonInt(id_val))
    jsonObjectPut(resp, "error", err)
    return resp
}

// ============================================================================
// MCP handlers
// ============================================================================

fn handleInitialize(id_val: i64) i64 {
    var caps = jsonObject()
    jsonObjectPut(caps, "tools", jsonObject())

    var info = jsonObject()
    jsonObjectPut(info, "name", jsonString("cot-tools"))
    jsonObjectPut(info, "version", jsonString("0.3.2"))

    var result = jsonObject()
    jsonObjectPut(result, "protocolVersion", jsonString("2024-11-05"))
    jsonObjectPut(result, "capabilities", caps)
    jsonObjectPut(result, "serverInfo", info)
    return makeResponse(id_val, result)
}

fn handleToolsList(id_val: i64) i64 {
    var tools = jsonArray()

    var schema1 = jsonObject()
    jsonObjectPut(schema1, "type", jsonString("object"))
    var t1 = jsonObject()
    jsonObjectPut(t1, "name", jsonString("get_syntax_reference"))
    jsonObjectPut(t1, "description", jsonString("Get Cot language syntax cheat sheet"))
    jsonObjectPut(t1, "inputSchema", schema1)
    jsonArrayPush(tools, t1)

    var module_prop = jsonObject()
    jsonObjectPut(module_prop, "type", jsonString("string"))
    jsonObjectPut(module_prop, "description", jsonString("Module: json string string_map fs io list map set sort math mem os time random encoding url http async path crypto fmt log dotenv cli uuid semver testing regex process"))
    var props2 = jsonObject()
    jsonObjectPut(props2, "module", module_prop)
    var schema2 = jsonObject()
    jsonObjectPut(schema2, "type", jsonString("object"))
    jsonObjectPut(schema2, "properties", props2)
    var t2 = jsonObject()
    jsonObjectPut(t2, "name", jsonString("get_stdlib_docs"))
    jsonObjectPut(t2, "description", jsonString("Get Cot stdlib function signatures"))
    jsonObjectPut(t2, "inputSchema", schema2)
    jsonArrayPush(tools, t2)

    var schema3 = jsonObject()
    jsonObjectPut(schema3, "type", jsonString("object"))
    var t3 = jsonObject()
    jsonObjectPut(t3, "name", jsonString("get_project_info"))
    jsonObjectPut(t3, "description", jsonString("Get Cot build/test commands and project structure"))
    jsonObjectPut(t3, "inputSchema", schema3)
    jsonArrayPush(tools, t3)

    var result = jsonObject()
    jsonObjectPut(result, "tools", tools)
    return makeResponse(id_val, result)
}

fn handleToolsCall(req: i64, id_val: i64) i64 {
    var params = jsonObjectGet(req, "params")
    if (params == 0) { return makeError(id_val, 0 - 32602, "Missing params") }
    var name = jsonObjectGetString(params, "name")
    if (@lenOf(name) == 0) { return makeError(id_val, 0 - 32602, "Missing tool name") }

    if (name == "get_syntax_reference") {
        var text = syntaxReference()
        return makeToolResponse(id_val, text)
    }
    if (name == "get_stdlib_docs") {
        var args = jsonObjectGet(params, "arguments")
        var module = ""
        if (args != 0) {
            module = jsonObjectGetString(args, "module")
        }
        var text = stdlibDocs(module)
        return makeToolResponse(id_val, text)
    }
    if (name == "get_project_info") {
        var text = projectInfo()
        return makeToolResponse(id_val, text)
    }
    return makeError(id_val, 0 - 32602, "Unknown tool")
}

// ============================================================================
// Request routing
// ============================================================================

fn getIdVal(req: i64) i64 {
    var id = jsonObjectGet(req, "id")
    if (id == 0) { return 0 }
    return jsonGetInt(id)
}

fn handleRequest(req: i64, writer: i64) void {
    var method = jsonObjectGetString(req, "method")
    var id_val = getIdVal(req)

    var response: i64 = 0
    if (method == "initialize") {
        response = handleInitialize(id_val)
    } else if (method == "tools/list") {
        response = handleToolsList(id_val)
    } else if (method == "tools/call") {
        response = handleToolsCall(req, id_val)
    } else if (method == "notifications/initialized") {
        return
    } else {
        if (id_val != 0) {
            response = makeError(id_val, 0 - 32601, "Method not found")
        }
    }

    if (response != 0) {
        var out = encode(response)
        writeString(writer, out)
        writeByte(writer, 10)
        writerFlush(writer)
    }
}

// ============================================================================
// Main
// ============================================================================

fn main() i64 {
    var reader = newBufferedReader(0)
    var writer = newBufferedWriter(1)

    var running: i64 = 1
    while (running == 1) {
        var line = readLine(reader)
        if (@lenOf(line) == 0) {
            running = 0
        } else {
            var request = parse(line)
            handleRequest(request, writer)
        }
    }
    return 0
}

// ============================================================================
// Tool: get_syntax_reference
// ============================================================================

fn syntaxReference() string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("# Cot Language Syntax Reference\n\n")

    sb.append("## Variables & Constants\n")
    sb.append("const x: i64 = 10    // immutable, typed\n")
    sb.append("const y = 20         // immutable, inferred\n")
    sb.append("var z = 30           // mutable, inferred\n")
    sb.append("No semicolons.\n\n")

    sb.append("## Types\n")
    sb.append("Integers: i8 i16 i32 i64 u8 u16 u32 u64\n")
    sb.append("Floats: f32 f64\n")
    sb.append("Other: bool void noreturn byte(=u8) int(=i64) float(=f64)\n")
    sb.append("Pointer: *T          Optional: ?T\n")
    sb.append("Error union: E!T     Inferred error: !T\n")
    sb.append("String: string (=[]u8, ptr+len pair)\n")
    sb.append("Tuple: (i64, string)  // anonymous product type\n\n")

    sb.append("## Literals\n")
    sb.append("42  0xFF  0b1010  3.14  true  false  null  undefined\n")
    sb.append("\"hello\"  'A' (char)  \"hello {name}\" (interpolation)\n")
    sb.append("[1, 2, 3] (array)  (10, \"hi\") (tuple)\n\n")

    sb.append("## Functions\n")
    sb.append("fn add(a: i64, b: i64) i64 { return a + b }\n")
    sb.append("fn noop() void { }\n")
    sb.append("fn apply(f: fn(i64) -> i64, x: i64) i64 { return f(x) }\n\n")

    sb.append("## Closures\n")
    sb.append("var add = fn(a: i64, b: i64) -> i64 { return a + b }\n")
    sb.append("var inc = fn(x: i64) -> i64 { return x + 1 }\n\n")

    sb.append("## Generics (separate parens, NOT angle brackets)\n")
    sb.append("fn max(T)(a: T, b: T) T { if (a > b) { return a } return b }\n")
    sb.append("struct Box(T) { value: T }\n")
    sb.append("var b = Box(i64) { .value = 42 }\n\n")

    sb.append("## Structs\n")
    sb.append("struct Point { x: i64, y: i64 }\n")
    sb.append("// Stack init (PERIOD prefix, EQUALS sign):\n")
    sb.append("var p = Point { .x = 10, .y = 20 }\n")
    sb.append("// Heap init (NO period, COLON separator):\n")
    sb.append("var h = new Point { x: 10, y: 20 }\n\n")

    sb.append("## Enums & Unions\n")
    sb.append("const Color = enum { Red, Green, Blue }\n")
    sb.append("const Token = enum(u8) { Eof, Ident, Int }  // backing type\n")
    sb.append("const Op = enum { @\"and\", @\"or\", add }  // quoted idents for keywords\n")
    sb.append("var c = Color.Red\n")
    sb.append("const Value = union(Tag) { int: i64, float: f64, none: void }\n\n")

    sb.append("## Enum Methods (value receiver, not pointer)\n")
    sb.append("impl Color {\n")
    sb.append("    fn isWarm(self: Color) bool {\n")
    sb.append("        return switch (self) { .Red => true, else => false }\n")
    sb.append("    }\n")
    sb.append("}\n\n")

    sb.append("## Methods (explicit self, like Zig)\n")
    sb.append("impl Point {\n")
    sb.append("    fn sum(self: Point) i64 { return self.x + self.y }\n")
    sb.append("    fn setX(self: *Point, x: i64) void { self.x = x }\n")
    sb.append("}\n\n")

    sb.append("## Traits\n")
    sb.append("trait Printable { fn toString(self: *Self) string }\n")
    sb.append("impl Printable for Point { fn toString(self: *Point) string { ... } }\n\n")

    sb.append("## Control Flow\n")
    sb.append("if (condition) { } else if (other) { } else { }\n")
    sb.append("if (optional) |val| { }  // Zig-style optional unwrap\n")
    sb.append("while (condition) { }\n")
    sb.append("while (i < 10) : (i = i + 1) { }  // with step expression\n")
    sb.append("for item in collection { }\n")
    sb.append("for i, item in collection { }  // indexed\n")
    sb.append("for i in 0..10 { }  // range\n")
    sb.append("inline for i in 0..N { }  // comptime unrolled\n")
    sb.append("// Labeled loops:\n")
    sb.append("'outer: while (true) { break 'outer }  // break from outer\n")
    sb.append("'search: for item in list { if (item == target) { break 'search } }\n")
    sb.append("Logical: and, or, not (also &&, ||, !)\n\n")

    sb.append("## Switch\n")
    sb.append("switch (x) {\n")
    sb.append("    1 => doOne(),\n")
    sb.append("    2..5 => doRange(),       // range pattern\n")
    sb.append("    6 if (cond) => guarded(), // guard clause\n")
    sb.append("    else => default(),\n")
    sb.append("}\n")
    sb.append("// String switch (compares by value, not pointer):\n")
    sb.append("switch (name) { \"fn\" => Token.kw_fn, \"var\" => Token.kw_var, else => Token.ident }\n\n")

    sb.append("## Error Handling (Zig-style)\n")
    sb.append("const MyError = error { NotFound, IoError }\n")
    sb.append("const Combined = MyError || OtherError  // error set merge\n")
    sb.append("fn read() MyError!i64 { return error.IoError }\n")
    sb.append("fn read2() !i64 { ... }  // inferred error set\n")
    sb.append("var val = read() catch 0         // catch with default\n")
    sb.append("var val = read() catch |e| { }   // catch with capture\n")
    sb.append("var val = try read()              // propagate error\n\n")

    sb.append("## Defer & Errdefer\n")
    sb.append("defer file.close()       // runs at scope exit\n")
    sb.append("errdefer cleanup()       // runs only on error return\n\n")

    sb.append("## Async / Await\n")
    sb.append("async fn fetchData(url: string) i64 { ... }\n")
    sb.append("var result = await fetchData(\"http://example.com\")\n")
    sb.append("var future = async fetchData(url)  // start async\n")
    sb.append("var val = await future              // wait for result\n\n")

    sb.append("## Destructuring\n")
    sb.append("const (a, b) = getTuple()\n")
    sb.append("const (x, _, z) = triple  // _ to ignore\n\n")

    sb.append("## String Interpolation\n")
    sb.append("var msg = \"hello {name}, you are {age} years old\"\n\n")

    sb.append("## noreturn\n")
    sb.append("fn panic(msg: string) noreturn { @trap() }\n")
    sb.append("unreachable  // noreturn value\n\n")

    sb.append("## @embedFile\n")
    sb.append("const data = @embedFile(\"data.bin\")  // embed file at comptime\n\n")

    sb.append("## Runtime Safety\n")
    sb.append("// Default: bounds checks, null checks, overflow detection\n")
    sb.append("// --release: disables safety checks for performance\n\n")

    sb.append("## Doc Comments\n")
    sb.append("/// This is a doc comment for the following declaration\n")
    sb.append("fn add(a: i64, b: i64) i64 { return a + b }\n\n")

    sb.append("## Imports\n")
    sb.append("import \"std/json\"          // stdlib module\n")
    sb.append("import \"std/string\"        // stdlib module\n")
    sb.append("import \"./myfile\"          // relative file\n\n")

    sb.append("## @safe Mode (opt-in file annotation)\n")
    sb.append("@safe  // first line of file, enables these features:\n")
    sb.append("// 1. Colon struct init:   Point { x: 10, y: 20 }  (instead of .x = 10)\n")
    sb.append("// 2. Field shorthand:     new Point { x, y }  =>  new Point { x: x, y: y }\n")
    sb.append("// 3. Implicit self:       fn getX() i64 { return self.x }  (self injected)\n")
    sb.append("// 4. Constructor sugar:   new Rect(10, 20)  calls init(w, h)\n")
    sb.append("// 5. Auto pointer wrap:   fn foo(p: Point)  auto-wrapped to *Point for structs\n")
    sb.append("// Implicit self: value receiver for enums (self: Token), pointer for structs (self: *Point)\n\n")

    sb.append("## Comptime (compile-time evaluation)\n")
    sb.append("comptime { var x = 0; x += 10; x }  // mutable comptime vars, returns 10\n")
    sb.append("const SIZE = comptime { 4 * 1024 }   // comptime constant\n")
    sb.append("// @typeInfo — comptime type reflection:\n")
    sb.append("inline for field in @typeInfo(Color).fields { field.name, field.value }\n")
    sb.append("@typeName(i64)          // => \"i64\"\n")
    sb.append("@enumName(Color, 0)     // => \"Red\"\n")
    sb.append("@enumLen(Color)         // number of variants\n")
    sb.append("// Dead branch elimination:\n")
    sb.append("if (@targetOs() == \"darwin\") { } else { @compileError(\"unsupported\") }\n\n")

    sb.append("## ARC & Weak References\n")
    sb.append("var p = new Foo { x: 42 }   // ARC: refcount = 1\n")
    sb.append("weak var w = p               // weak: does NOT retain (breaks cycles)\n")
    sb.append("@arcRetain(val)             // manual retain (no-op for non-ARC types)\n")
    sb.append("@arcRelease(val)            // manual release (no-op for non-ARC types)\n\n")

    sb.append("## Builtins (compiler intrinsics)\n")
    sb.append("// Type intrinsics\n")
    sb.append("@sizeOf(T) @alignOf(T) @offsetOf(T, \"field\")\n\n")
    sb.append("// Casts\n")
    sb.append("@intCast(T, val) @floatCast(T, val) @bitCast(T, val) @truncate(T, val) @as(T, val)\n")
    sb.append("@intFromFloat(val) @floatFromInt(T, val) @ptrCast(*T, ptr) @intToPtr(*T, addr) @ptrToInt(ptr)\n")
    sb.append("@alignCast(alignment, ptr) @constCast(ptr)\n\n")
    sb.append("// Enum / error\n")
    sb.append("@intFromEnum(val) @enumFromInt(E, n) or @enumFromInt(n) with @as @enumLen(E) @tagName(val) @errorName(err) @intFromBool(b)\n\n")
    sb.append("// String\n")
    sb.append("@string(ptr, len) @ptrOf(s) @lenOf(s)\n\n")
    sb.append("// ARC\n")
    sb.append("@arcRetain(val) @arcRelease(val)\n\n")
    sb.append("// Control\n")
    sb.append("@trap() @panic(msg)\n\n")
    sb.append("// Comptime\n")
    sb.append("@compileError(msg) @embedFile(path) @target() @targetOs() @targetArch()\n\n")
    sb.append("// Reflection\n")
    sb.append("@TypeOf(expr) @hasField(T, name) @field(val, name)\n")
    sb.append("@typeInfo(T) @typeName(T) @enumName(E, idx)\n\n")
    sb.append("// Testing\n")
    sb.append("@assert(cond) @assertEq(a, b)\n\n")
    sb.append("## Runtime functions (via std/sys)\n")
    sb.append("import \"std/sys\"  // makes all runtime functions available\n")
    sb.append("// Memory: alloc(0, size), dealloc(ptr), realloc(ptr, size), memcpy(d,s,l), memset_zero(ptr,l)\n")
    sb.append("// I/O: fd_write(fd,ptr,len), fd_read(fd,buf,len), fd_close(fd), fd_seek(fd,off,w), fd_open(ptr,len,flags)\n")
    sb.append("// Process: exit(code), fork(), waitpid(pid), pipe(), dup2(old,new), execve(path,argv,envp)\n")
    sb.append("// CLI: args_count(), arg_len(n), arg_ptr(n), environ_count(), environ_len(n), environ_ptr(n)\n")
    sb.append("// Net: net_socket(d,t,p), net_bind(fd,a,l), net_listen(fd,b), net_accept(fd), net_connect(fd,a,l)\n")
    sb.append("// System: time(), random(buf,len), isatty(fd)\n")
    sb.append("// Higher-level: std/fs, std/os, std/http, std/time, std/random, std/process\n\n")

    sb.append("## Tests & Benchmarks\n")
    sb.append("test \"my test\" { @assertEq(1 + 1, 2) }\n")
    sb.append("bench \"my bench\" { doExpensiveWork() }\n")
    sb.append("Run: cot test file.cot  |  cot bench file.cot\n")

    var result = sb.toString()
    return result
}

// ============================================================================
// Tool: get_stdlib_docs
// ============================================================================

fn stdlibDocs(module: string) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }

    if (@lenOf(module) == 0) {
        sb.append("# Cot Stdlib Modules (29)\n\n")
        sb.append("## Core: json, string, string_map, list, map, set, sort, math, mem\n")
        sb.append("## I/O: fs, io, os, encoding\n")
        sb.append("## System: time, random, process, crypto\n")
        sb.append("## Net: http, url, async\n")
        sb.append("## Util: path, fmt, log, dotenv, cli, uuid, semver, testing, regex\n\n")
        sb.append("Use get_stdlib_docs with module param for details.\n")
        var result = sb.toString()
        return result
    }

    if (module == "json") {
        sb.append("# std/json\n\n")
        sb.append("JSON parser + encoder. Values are heap-allocated i64 pointers.\n\n")
        sb.append("## Constructors (return i64)\n")
        sb.append("jsonNull()  jsonBool(val: bool)  jsonInt(val: i64)  jsonString(val: string)\n")
        sb.append("jsonArray()  jsonObject()\n\n")
        sb.append("## Accessors\n")
        sb.append("jsonTag(val: i64) i64       // 0=null 1=bool 2=int 3=string 4=array 5=object\n")
        sb.append("jsonIsNull(val: i64) bool\n")
        sb.append("jsonGetBool(val: i64) bool  jsonGetInt(val: i64) i64  jsonGetString(val: i64) string\n\n")
        sb.append("## Array ops\n")
        sb.append("jsonArrayLen(val: i64) i64  jsonArrayGet(val: i64, index: i64) i64\n")
        sb.append("jsonArrayPush(arr: i64, val: i64) void\n\n")
        sb.append("## Object ops\n")
        sb.append("jsonObjectLen(val: i64) i64  jsonObjectPut(obj: i64, key: string, val: i64) void\n")
        sb.append("jsonObjectGet(obj: i64, key: string) i64\n")
        sb.append("jsonObjectGetString(obj: i64, key: string) string\n")
        sb.append("jsonObjectGetInt(obj: i64, key: string) i64\n\n")
        sb.append("## Parse/Encode\n")
        sb.append("parse(input: string) i64    encode(val: i64) string\n")
    } else if (module == "string") {
        sb.append("# std/string\n\n")
        sb.append("charAt(s, index) i64  indexOf(s, needle) i64  lastIndexOf(s, needle) i64\n")
        sb.append("contains(s, needle) bool  startsWith(s, prefix) bool  endsWith(s, suffix) bool\n")
        sb.append("count(s, needle) i64  substring(s, start, end) string\n")
        sb.append("trim(s) string  trimLeft(s) string  trimRight(s) string\n")
        sb.append("toUpper(s) string  toLower(s) string  replace(s, old, new) string\n")
        sb.append("repeat(s, n) string  parseInt(s) i64  parseIntOrNull(s) ?i64\n")
        sb.append("parseFloat(s) f64  parseFloatOrNull(s) ?f64  intToString(n) string\n")
        sb.append("compare(a, b) i64  splitInto(s, sep, result: *List(string)) void\n\n")
        sb.append("## StringBuilder\n")
        sb.append("var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }\n")
        sb.append("sb.append(s)  sb.appendByte(b)  sb.appendInt(n)\n")
        sb.append("sb.toString() string  sb.length() i64  sb.clear()  sb.free()\n")
    } else if (module == "fs") {
        sb.append("# std/fs\n\n")
        sb.append("struct File { fd: i64 }\n")
        sb.append("openFile(path: string, flags: i64) File\n")
        sb.append("createFile(path: string) File\n")
        sb.append("readFile(path: string) string  writeFile(path: string, data: string) void\n")
        sb.append("stdin() File  stdout() File  stderr() File\n\n")
        sb.append("## File methods\n")
        sb.append("f.read(buf, len) FsError!i64  f.write(buf, len) FsError!i64\n")
        sb.append("f.writeAll(s: string) FsError!i64  f.close() void  f.isValid() i64\n")
        sb.append("f.seekTo(pos) FsError!i64  f.seekBy(delta) FsError!i64  f.getPos() FsError!i64\n\n")
        sb.append("## Flags\n")
        sb.append("O_RDONLY=0  O_WRONLY=1  O_RDWR=2  O_CREATE  O_WRITE_CREATE\n")
    } else if (module == "io") {
        sb.append("# std/io\n\n")
        sb.append("Buffered I/O. State is heap-allocated (i64 pointer).\n\n")
        sb.append("## BufferedReader\n")
        sb.append("newBufferedReader(fd: i64) i64\n")
        sb.append("newBufferedReaderSize(fd: i64, size: i64) i64\n")
        sb.append("readByte(r: i64) i64           // -1 on EOF\n")
        sb.append("readLine(r: i64) string         // empty string on EOF\n")
        sb.append("readerFill(r: i64) void\n\n")
        sb.append("## BufferedWriter\n")
        sb.append("newBufferedWriter(fd: i64) i64\n")
        sb.append("newBufferedWriterSize(fd: i64, size: i64) i64\n")
        sb.append("writeByte(w: i64, b: i64) void\n")
        sb.append("writeString(w: i64, s: string) void\n")
        sb.append("writerWriteAll(w: i64, ptr: i64, len: i64) void\n")
        sb.append("writerFlush(w: i64) void\n")
    } else if (module == "list") {
        sb.append("# std/list\n\n")
        sb.append("struct List(T) { items: i64, count: i64, capacity: i64 }\n")
        sb.append("var l: List(i64) = .{}\n\n")
        sb.append("## Core\n")
        sb.append("l.append(val)  l.get(i) T  l.set(i, val)  l.pop() T\n")
        sb.append("l.len() i64  l.cap() i64  l.first() T  l.last() T\n\n")
        sb.append("## Modify\n")
        sb.append("l.insert(i, val)  l.orderedRemove(i) T  l.swapRemove(i) T\n")
        sb.append("l.appendSlice(src, n)  l.reverse()  l.clone() List(T)\n")
        sb.append("l.clear()  l.free()  l.resize(n)  l.sort(cmp)\n\n")
        sb.append("## Search\n")
        sb.append("l.indexOf(val) i64  l.contains(val) i64  l.equal(other) i64\n")
    } else if (module == "map") {
        sb.append("# std/map\n\n")
        sb.append("struct Map(K, V) -- hash map with open addressing.\n")
        sb.append("var m: Map(i64, i64) = .{}\n\n")
        sb.append("m.set(key, val)  m.get(key) V  m.contains(key) i64\n")
        sb.append("m.remove(key) i64  m.len() i64  m.clear()  m.free()\n")
        sb.append("m.keys() List(K)  m.values() List(V)\n")
    } else if (module == "os") {
        sb.append("# std/os\n\n")
        sb.append("exit(code: i64)  argsCount() i64  argLen(n) i64  argPtr(n) i64\n")
        sb.append("arg(n: i64) string  environ(n: i64) string\n")
        sb.append("environCount() i64  environLen(n) i64  environPtr(n) i64\n")
    } else if (module == "time") {
        sb.append("# std/time\n\n")
        sb.append("nanoTimestamp() i64  milliTimestamp() i64  timestamp() i64\n")
        sb.append("struct Timer { start_time: i64 }\n")
        sb.append("t.elapsed() i64  t.reset() void\n")
        sb.append("ns_per_ms=1000000  ns_per_s=1000000000  ms_per_s=1000\n")
    } else if (module == "random") {
        sb.append("# std/random\n\n")
        sb.append("fillBytes(buf: i64, len: i64) i64\n")
        sb.append("randomInt() i64  randomRange(max: i64) i64\n")
    } else if (module == "sort") {
        sb.append("# std/sort\n\n")
        sb.append("insertionSort for List(T) with comparator function.\n")
    } else if (module == "set") {
        sb.append("# std/set\n\n")
        sb.append("struct Set(T) -- hash set.\n")
        sb.append("var s: Set(i64) = .{}\n")
        sb.append("s.add(val)  s.contains(val) i64  s.remove(val) i64\n")
        sb.append("s.len() i64  s.clear()  s.free()\n")
    } else if (module == "math") {
        sb.append("# std/math\n\n")
        sb.append("abs(x) i64  min(a, b) i64  max(a, b) i64  clamp(x, lo, hi) i64\n")
        sb.append("@sqrt(x)  @floor(x)  @ceil(x)  @fabs(x)  @min(a,b)  @max(a,b)\n")
    } else if (module == "encoding") {
        sb.append("# std/encoding\n\n")
        sb.append("## Hex\n")
        sb.append("hexEncode(data: string) string\n")
        sb.append("hexDecode(s: string) string\n\n")
        sb.append("## Base64\n")
        sb.append("base64Encode(data: string) string\n")
        sb.append("base64Decode(encoded: string) string\n")
        sb.append("base64UrlEncode(data: string) string   // URL-safe variant\n")
        sb.append("base64UrlDecode(encoded: string) string\n")
    } else if (module == "url") {
        sb.append("# std/url\n\n")
        sb.append("parseUrl(raw: string) i64              // returns URL handle\n")
        sb.append("urlScheme(url: i64) string\n")
        sb.append("urlHost(url: i64) string\n")
        sb.append("urlPort(url: i64) string\n")
        sb.append("urlPath(url: i64) string\n")
        sb.append("urlQuery(url: i64) string\n")
        sb.append("urlFragment(url: i64) string\n")
        sb.append("urlToString(url: i64) string\n")
    } else if (module == "http") {
        sb.append("# std/http\n\n")
        sb.append("Low-level TCP networking (POSIX sockets).\n\n")
        sb.append("## Socket ops\n")
        sb.append("tcpSocket() NetError!i64\n")
        sb.append("setReuseAddr(fd: i64) void\n")
        sb.append("bindSocket(fd: i64, ip: i64, port: i64) NetError!i64\n")
        sb.append("listenSocket(fd: i64, backlog: i64) NetError!i64\n")
        sb.append("acceptConnection(fd: i64) NetError!i64\n")
        sb.append("connectSocket(fd: i64, ip: i64, port: i64) NetError!i64\n\n")
        sb.append("## I/O\n")
        sb.append("socketRead(fd: i64, buf: i64, len: i64) i64\n")
        sb.append("socketWrite(fd: i64, buf: i64, len: i64) i64\n")
        sb.append("socketWriteString(fd: i64, s: string) i64\n")
        sb.append("socketClose(fd: i64) void\n\n")
        sb.append("## High-level\n")
        sb.append("tcpListen(port: i64) NetError!i64\n")
        sb.append("tcpConnect(ip: i64, port: i64) NetError!i64\n")
        sb.append("httpResponse(status: i64, body: string) string\n")
        sb.append("buildSockaddrIn(buf: i64, ip: i64, port: i64) void\n")
    } else if (module == "async") {
        sb.append("# std/async\n\n")
        sb.append("Event loop abstraction (kqueue on macOS, epoll on Linux).\n\n")
        sb.append("## Event loop\n")
        sb.append("eventLoopCreate() i64\n")
        sb.append("watchRead(loop_fd: i64, fd: i64) i64\n")
        sb.append("watchWrite(loop_fd: i64, fd: i64) i64\n")
        sb.append("unwatchRead(loop_fd: i64, fd: i64) i64\n")
        sb.append("unwatchWrite(loop_fd: i64, fd: i64) i64\n")
        sb.append("eventLoopWait(loop_fd: i64, buf: i64, max_events: i64) i64\n")
        sb.append("eventFd(buf: i64, index: i64) i64\n\n")
        sb.append("## Async I/O\n")
        sb.append("asyncAccept(loop_fd: i64, listen_fd: i64) IoError!i64\n")
        sb.append("asyncRead(loop_fd: i64, fd: i64, buf: i64, len: i64) IoError!i64\n")
        sb.append("asyncWrite(loop_fd: i64, fd: i64, buf: i64, len: i64) IoError!i64\n")
        sb.append("asyncWriteString(loop_fd: i64, fd: i64, s: string) IoError!i64\n")
        sb.append("asyncConnect(loop_fd: i64, fd: i64, addr_buf: i64, addr_len: i64) IoError!i64\n\n")
        sb.append("## Utilities\n")
        sb.append("setNonBlocking(fd: i64) i64\n")
        sb.append("isEagain(result: i64) bool\n")
    } else if (module == "path") {
        sb.append("# std/path\n\n")
        sb.append("basename(p: string) string     // file name component\n")
        sb.append("dirname(p: string) string      // directory component\n")
        sb.append("extname(p: string) string      // file extension\n")
        sb.append("isAbsolute(p: string) bool\n")
        sb.append("join(a: string, b: string) string\n")
        sb.append("join3(a: string, b: string, c: string) string\n")
        sb.append("join4(a: string, b: string, c: string, d: string) string\n")
        sb.append("clean(p: string) string         // normalize path\n")
        sb.append("relative(base: string, target: string) string\n")
    } else if (module == "crypto") {
        sb.append("# std/crypto\n\n")
        sb.append("sha256(input: string) string           // returns hex digest\n")
        sb.append("hmacSha256(key: string, message: string) string  // HMAC-SHA256 hex\n")
    } else if (module == "fmt") {
        sb.append("# std/fmt\n\n")
        sb.append("## ANSI colors\n")
        sb.append("red(s) green(s) yellow(s) blue(s) magenta(s) cyan(s) gray(s) white(s)\n")
        sb.append("bold(s) dim(s) italic(s) underline(s) strikethrough(s) stripAnsi(s)\n\n")
        sb.append("## Formatting\n")
        sb.append("formatBytes(bytes: i64) string         // e.g. \"1.5 MB\"\n")
        sb.append("formatDuration(ns: i64) string         // e.g. \"1.23s\"\n")
        sb.append("padRight(s: string, width: i64) string\n")
        sb.append("padLeft(s: string, width: i64) string\n")
        sb.append("center(s: string, width: i64) string\n")
        sb.append("zeroPad(n: i64, width: i64) string\n")
        sb.append("hex(n: i64) string\n")
    } else if (module == "log") {
        sb.append("# std/log\n\n")
        sb.append("setLevel(level: i64) void   // 0=DEBUG 1=INFO 2=WARN 3=ERROR\n")
        sb.append("setTimestamps(enabled: bool) void\n")
        sb.append("debug(msg: string) void  info(msg: string) void\n")
        sb.append("warn(msg: string) void   logError(msg: string) void\n")
        sb.append("debugKv(msg, key, val) void  infoKv(msg, key, val) void\n")
        sb.append("warnKv(msg, key, val) void   logErrorKv(msg, key, val) void\n")
    } else if (module == "dotenv") {
        sb.append("# std/dotenv\n\n")
        sb.append("parseEnv(content: string) i64    // parse .env text\n")
        sb.append("entryCount(env: i64) i64\n")
        sb.append("entryKey(env: i64, n: i64) string\n")
        sb.append("entryValue(env: i64, n: i64) string\n")
        sb.append("get(env: i64, key: string) string\n")
        sb.append("has(env: i64, key: string) bool\n")
    } else if (module == "cli") {
        sb.append("# std/cli\n\n")
        sb.append("parseArgs() i64                        // parse process args\n")
        sb.append("getFlag(args: i64, name: string, default: string) string\n")
        sb.append("hasFlag(args: i64, name: string) bool\n")
        sb.append("getFlagInt(args: i64, name: string, default: i64) i64\n")
        sb.append("positionalCount(args: i64) i64\n")
        sb.append("positional(args: i64, index: i64) string\n")
        sb.append("flagCount(args: i64) i64\n")
        sb.append("flagKey(args: i64, index: i64) string\n")
        sb.append("flagValue(args: i64, index: i64) string\n")
    } else if (module == "uuid") {
        sb.append("# std/uuid\n\n")
        sb.append("v4() string           // generate UUID v4\n")
        sb.append("isValid(s: string) bool\n")
        sb.append("version(s: string) i64\n")
    } else if (module == "semver") {
        sb.append("# std/semver\n\n")
        sb.append("parse(s: string) i64          // parse semver string\n")
        sb.append("major(v: i64) i64  minor(v: i64) i64  patch(v: i64) i64\n")
        sb.append("prerelease(v: i64) string  build(v: i64) string\n")
        sb.append("format(v: i64) string\n\n")
        sb.append("## Comparison\n")
        sb.append("cmp(a: i64, b: i64) i64  // -1, 0, 1\n")
        sb.append("gt(a, b) bool  gte(a, b) bool  lt(a, b) bool  lte(a, b) bool  eq(a, b) bool\n\n")
        sb.append("## Increment\n")
        sb.append("incMajor(v: i64) i64  incMinor(v: i64) i64  incPatch(v: i64) i64\n")
    } else if (module == "testing") {
        sb.append("# std/testing\n\n")
        sb.append("Extended test assertions (beyond @assert/@assertEq builtins).\n\n")
        sb.append("assertContains(haystack: string, needle: string) void\n")
        sb.append("assertStartsWith(s: string, prefix: string) void\n")
        sb.append("assertEndsWith(s: string, suffix: string) void\n")
        sb.append("assertStrEq(actual: string, expected: string, label: string) void\n")
        sb.append("assertGt(actual: i64, threshold: i64) void\n")
        sb.append("assertGte(actual: i64, threshold: i64) void\n")
        sb.append("assertLt(actual: i64, threshold: i64) void\n")
        sb.append("assertLte(actual: i64, threshold: i64) void\n")
        sb.append("assertInRange(actual: i64, min: i64, max: i64) void\n")
        sb.append("assertTrue(cond: bool, msg: string) void\n")
        sb.append("assertFalse(cond: bool, msg: string) void\n")
        sb.append("assertEmpty(s: string) void\n")
        sb.append("assertNotEmpty(s: string) void\n")
        sb.append("assertLen(s: string, expected: i64) void\n")
    } else if (module == "regex") {
        sb.append("# std/regex\n\n")
        sb.append("Thompson NFA regex engine.\n\n")
        sb.append("regexMatch(pattern: string, text: string) bool\n")
        sb.append("regexFind(pattern: string, text: string) i64\n")
        sb.append("regexFindSpan(pattern: string, text: string) i64\n")
        sb.append("spanStart(span: i64) i64  spanLen(span: i64) i64\n")
        sb.append("regexReplace(pattern: string, text: string, replacement: string) string\n")
        sb.append("regexReplaceAll(pattern: string, text: string, replacement: string) string\n")
        sb.append("regexSplit(pattern: string, text: string) i64\n")
        sb.append("splitCount(result: i64) i64  splitGet(result: i64, index: i64) string\n")
    } else if (module == "string_map") {
        sb.append("# std/string_map\n\n")
        sb.append("Hash map with string keys (optimized string hashing).\n\n")
        sb.append("struct StringMap(V) { ... }\n")
        sb.append("var m: StringMap(i64) = .{}\n\n")
        sb.append("m.set(key: string, val: V)  m.get(key: string) V\n")
        sb.append("m.contains(key: string) i64  m.remove(key: string) i64\n")
        sb.append("m.len() i64  m.clear()  m.free()\n")
    } else if (module == "mem") {
        sb.append("# std/mem\n\n")
        sb.append("Byte-level memory operations.\n\n")
        sb.append("eql(a: i64, b: i64, len: i64) bool\n")
        sb.append("cmp(a: i64, b: i64, len: i64) i64\n")
        sb.append("startsWith(ptr: i64, plen: i64, prefix: i64, prefix_len: i64) bool\n")
        sb.append("endsWith(ptr: i64, plen: i64, suffix: i64, suffix_len: i64) bool\n")
        sb.append("zero(ptr: i64, len: i64) void\n")
        sb.append("set(ptr: i64, val: i64, len: i64) void\n")
        sb.append("readU16LE(ptr: i64) i64  readU32LE(ptr: i64) i64\n")
        sb.append("writeU16LE(ptr: i64, val: i64) void  writeU32LE(ptr: i64, val: i64) void\n")
    } else if (module == "process") {
        sb.append("# std/process\n\n")
        sb.append("Process management (native only, WASI stubs return -1).\n\n")
        sb.append("## Low-level (POSIX)\n")
        sb.append("fork() i64  waitpid(pid: i64) i64\n")
        sb.append("pipe() i64  pipeReadFd(packed_fds: i64) i64  pipeWriteFd(packed_fds: i64) i64\n")
        sb.append("dup2(oldfd: i64, newfd: i64) i64\n\n")
        sb.append("## High-level\n")
        sb.append("run(cmd: string, arg1: string) i64     // fork+exec, return exit code\n")
        sb.append("run0(cmd: string) i64                   // no args variant\n")
        sb.append("run2(cmd: string, arg1: string, arg2: string) i64\n")
        sb.append("output(cmd: string, arg1: string) string  // capture stdout\n")
        sb.append("output0(cmd: string) string\n")
    } else {
        sb.append("Unknown module: ")
        sb.append(module)
        sb.append("\nAvailable (29): json, string, string_map, fs, io, list, map, set, sort, math, mem, os, time, random, encoding, url, http, async, path, crypto, fmt, log, dotenv, cli, uuid, semver, testing, regex, process\n")
    }

    var result = sb.toString()
    return result
}

// ============================================================================
// Tool: get_project_info
// ============================================================================

fn projectInfo() string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    sb.append("# Cot Project Info\n\n")

    sb.append("## CLI Commands\n")
    sb.append("cot build <file.cot> [-o name] [--target=<t>] [--release]  # Compile\n")
    sb.append("cot run <file.cot> [-- args] [--release]    # Compile + run + cleanup\n")
    sb.append("cot test <file.cot> [--filter=<str>] [--target=<t>]  # Run tests\n")
    sb.append("cot bench <file.cot> [--filter=<str>] [--n=<count>]  # Run benchmarks\n")
    sb.append("cot check <file.cot>             # Type-check only\n")
    sb.append("cot lint <file.cot>              # Check for warnings\n")
    sb.append("cot fmt <file.cot> [--check] [--stdout]  # Format source\n")
    sb.append("cot doc <file.cot> [-o dir]      # Generate docs\n")
    sb.append("cot init [name] [--lib]          # Create new project\n")
    sb.append("cot lsp                          # Language server (stdio)\n")
    sb.append("cot mcp                          # MCP server (stdio)\n")
    sb.append("cot version                      # Print version\n")
    sb.append("cot help [command]               # Print help\n\n")

    sb.append("## Targets\n")
    sb.append("native (default)  wasm32  wasm32-gc\n\n")

    sb.append("## Project Structure\n")
    sb.append("compiler/           Zig compiler source\n")
    sb.append("stdlib/             Standard library (29 modules):\n")
    sb.append("  Core:    json string string_map list map set sort math mem\n")
    sb.append("  I/O:     fs io os encoding\n")
    sb.append("  System:  time random process crypto\n")
    sb.append("  Net:     http url async\n")
    sb.append("  Util:    path fmt log dotenv cli uuid semver testing regex\n")
    sb.append("test/e2e/           End-to-end tests (~900 tests)\n")
    sb.append("test/cases/         Category unit tests (~100 tests)\n\n")

    sb.append("## Writing Tests\n")
    sb.append("test \"name\" { @assertEq(1 + 1, 2) }\n")
    sb.append("test \"strings\" { @assertEq(\"hello\", \"hello\") }\n")
    sb.append("Run: cot test file.cot\n\n")

    sb.append("## Architecture\n")
    sb.append("Cot -> Scanner -> Parser -> Checker -> IR -> SSA\n")
    sb.append("  -> Wasm bytecode\n")
    sb.append("    -> .wasm file (--target=wasm32)\n")
    sb.append("    -> native AOT via CLIF (default)\n")
    sb.append("Compiler is written in Zig. Language follows Zig patterns.\n")
    sb.append("ARC memory management (automatic retain/release).\n")

    var result = sb.toString()
    return result
}
