/// Type checker for the self-hosted Cot compiler.
/// Ported from compiler/frontend/checker.zig
///
/// Checks the AST for type errors, builds the type registry, and
/// resolves type expressions. Operates on the flat-encoded AST
/// produced by parser.cot.

import "std/list"
import "std/map"
import "std/string"
import "ast"
import "errors"
import "types"
import "token"
import "scanner"
import "parser"

// ============================================================================
// Constants
// ============================================================================

// null_node: defined in ast.cot
// invalid_type: defined in types.cot

// Type expression kind constants — imported from ast.cot via `import "ast"`
// (TYPE_NAMED, TYPE_POINTER, TYPE_OPTIONAL, TYPE_ERROR_UNION, TYPE_SLICE, TYPE_ARRAY, TYPE_FUNCTION)

// ============================================================================
// Symbol — named binding in scope
// ============================================================================

// C18: Symbol kind constants (Zig checker.zig:38-39)
const SYM_VARIABLE: int = 0
const SYM_CONSTANT: int = 1
const SYM_FUNCTION: int = 2
const SYM_TYPE: int = 3
const SYM_PARAMETER: int = 4

struct Symbol {
    name: string,
    type_idx: int,
    node: int,
    mutable: bool,
    is_func: bool,
    is_type: bool,
    is_const_val: bool,
    const_value: int,
    float_const_value: int,  // C19: f64 bits stored as int (Zig checker.zig:47)
    kind: int,               // C18: SYM_VARIABLE/CONSTANT/FUNCTION/TYPE/PARAMETER
    is_extern: bool,
    is_export: bool,
    used: bool,
}

fn makeSymbol(name: string, type_idx: int, node: int, mutable: bool) Symbol {
    return Symbol {
        name: name,
        type_idx: type_idx,
        node: node,
        mutable: mutable,
        is_func: false,
        is_type: false,
        is_const_val: false,
        const_value: 0,
        float_const_value: 0,
        kind: SYM_VARIABLE,
        is_extern: false,
        is_export: false,
        used: false,
    }
}

fn makeFuncSymbol(name: string, type_idx: int, node: int) Symbol {
    return Symbol {
        name: name,
        type_idx: type_idx,
        node: node,
        mutable: false,
        is_func: true,
        is_type: false,
        is_const_val: false,
        const_value: 0,
        float_const_value: 0,
        kind: SYM_FUNCTION,
        is_extern: false,
        is_export: false,
        used: false,
    }
}

fn makeExternFuncSymbol(name: string, type_idx: int, node: int) Symbol {
    return Symbol {
        name: name,
        type_idx: type_idx,
        node: node,
        mutable: false,
        is_func: true,
        is_type: false,
        is_const_val: false,
        const_value: 0,
        float_const_value: 0,
        kind: SYM_FUNCTION,
        is_extern: true,
        is_export: false,
        used: false,
    }
}

fn makeTypeSymbol(name: string, type_idx: int, node: int) Symbol {
    return Symbol {
        name: name,
        type_idx: type_idx,
        node: node,
        mutable: false,
        is_func: false,
        is_type: true,
        is_const_val: false,
        const_value: 0,
        float_const_value: 0,
        kind: SYM_TYPE,
        is_extern: false,
        is_export: false,
        used: false,
    }
}

fn makeConstSymbol(name: string, type_idx: int, node: int, value: int) Symbol {
    return Symbol {
        name: name,
        type_idx: type_idx,
        node: node,
        mutable: false,
        is_func: false,
        is_type: false,
        is_const_val: true,
        const_value: value,
        float_const_value: 0,
        kind: SYM_CONSTANT,
        is_extern: false,
        is_export: false,
        used: false,
    }
}

fn makeParamSymbol(name: string, type_idx: int, node: int) Symbol {
    return Symbol {
        name: name,
        type_idx: type_idx,
        node: node,
        mutable: false,
        is_func: false,
        is_type: false,
        is_const_val: false,
        const_value: 0,
        float_const_value: 0,
        kind: SYM_PARAMETER,
        is_extern: false,
        is_export: false,
        used: false,
    }
}

// ============================================================================
// GenericImplEntry — stored during collection for deferred instantiation
// ============================================================================

struct GenericImplEntry {
    base_name: string,
    node_idx: int,
    tp_count: int,
    methods_count: int,
    ast_ptr: int,  // @ptrToInt of declaring file's *Ast
}

impl GenericImplEntry {
    fn getAst() *Ast {
        return @intToPtr(*Ast, self.ast_ptr)
    }
}

// GenericInfo — stores generic struct/function definition location.
// Zig: GenericInfo { type_params, node_idx, tree }.
// Needed for cross-file generic resolution: node_idx is in declaring file's AST.
struct GenericInfo {
    node_idx: int,
    ast_ptr: int,  // @ptrToInt of declaring file's *Ast
}

impl GenericInfo {
    fn getAst() *Ast {
        return @intToPtr(*Ast, self.ast_ptr)
    }
}

// ============================================================================
// SharedCheckerState — persists across Checkers in multi-file mode
// ============================================================================
// Copied from Zig compiler pattern: driver.zig creates shared state,
// passes to each Checker. After checkFile(), caller syncs back.

struct SharedCheckerState {
    global_map: int,                         // raw ptr to Map(string, int) — global scope
    symbols: List(Symbol),
    generic_structs: Map(string, int),
    generic_functions: Map(string, int),
    instantiation_cache: Map(string, int),
    generic_impl_entries: List(GenericImplEntry),
    trait_defs: Map(string, int),
    trait_impls: Map(string, string),
}

impl SharedCheckerState {
    static fn init() SharedCheckerState {
        var symbols: List(Symbol) = .{}
        var generic_structs: Map(string, int) = .{}
        var generic_functions: Map(string, int) = .{}
        var instantiation_cache: Map(string, int) = .{}
        var generic_impl_entries: List(GenericImplEntry) = .{}
        var trait_defs: Map(string, int) = .{}
        var trait_impls: Map(string, string) = .{}
        return SharedCheckerState {
            global_map: allocMap(),
            symbols: symbols,
            generic_structs: generic_structs,
            generic_functions: generic_functions,
            instantiation_cache: instantiation_cache,
            generic_impl_entries: generic_impl_entries,
            trait_defs: trait_defs,
            trait_impls: trait_impls,
        }
    }

}

// ============================================================================
// Checker — type checking state
// ============================================================================

struct Checker {
    types: *TypeRegistry,
    ast: *Ast,
    err: *ErrorReporter,
    symbols: List(Symbol),
    // Scope chain (parallel List(int) arrays)
    scope_parents: List(int),
    scope_maps: List(int),       // raw pointers to heap-allocated Map(string, int)
    current_scope: int,
    global_scope: int,
    expr_types: Map(int, int),
    trait_defs: Map(string, int),   // trait name → AST node index
    current_return_type: int,
    in_loop: bool,
    safe_mode: bool,
    // Generic support
    generic_structs: Map(string, int),        // name → struct_decl node_idx
    generic_functions: Map(string, int),      // name → fn_decl node_idx
    generic_impl_entries: List(GenericImplEntry),
    instantiation_cache: Map(string, int),    // "List(5)" → concrete type_idx
    type_sub_keys: List(string),             // parallel lists = active substitution map
    type_sub_vals: List(int),
    trait_impls: Map(string, string),        // "Trait:Type" → trait_name
    // Type flow
    expected_type: int,                       // Zig RLS pattern
    current_switch_enum_type: int,            // for .variant shorthand
    // Lint
    lint_mode: bool,
    // Async
    in_async_fn: bool,
    // Comptime
    comptime_vars: Map(string, int),
    in_comptime: bool,
}

impl Checker {
    static fn init(ast: *Ast, types: *TypeRegistry, err: *ErrorReporter) Checker {
        var symbols: List(Symbol) = .{}
        var scope_parents: List(int) = .{}
        var scope_maps: List(int) = .{}

        // Create global scope (index 0)
        var global_map = allocMap()
        scope_parents.append(-1)
        scope_maps.append(global_map)

        var expr_types: Map(int, int) = .{}
        var trait_defs: Map(string, int) = .{}
        var generic_structs: Map(string, int) = .{}
        var generic_functions: Map(string, int) = .{}
        var instantiation_cache: Map(string, int) = .{}
        var generic_impl_entries: List(GenericImplEntry) = .{}
        var type_sub_keys: List(string) = .{}
        var type_sub_vals: List(int) = .{}
        var trait_impls: Map(string, string) = .{}
        var comptime_vars: Map(string, int) = .{}

        return Checker {
            types: types,
            ast: ast,
            err: err,
            symbols: symbols,
            scope_parents: scope_parents,
            scope_maps: scope_maps,
            current_scope: 0,
            global_scope: 0,
            expr_types: expr_types,
            trait_defs: trait_defs,
            current_return_type: VOID,
            in_loop: false,
            safe_mode: false,
            generic_structs: generic_structs,
            generic_functions: generic_functions,
            generic_impl_entries: generic_impl_entries,
            instantiation_cache: instantiation_cache,
            type_sub_keys: type_sub_keys,
            type_sub_vals: type_sub_vals,
            trait_impls: trait_impls,
            expected_type: invalid_type,
            current_switch_enum_type: invalid_type,
            lint_mode: false,
            in_async_fn: false,
            comptime_vars: comptime_vars,
            in_comptime: false,
        }
    }

    /// Initialize a Checker with a shared global scope map pointer.
    /// For multi-file mode: all Checkers share the same global scope map
    /// (scope_maps[0]) so symbols from File A are visible in File B.
    /// Uses the regular init pattern but overrides scope_maps[0].
    static fn initShared(ast: *Ast, types: *TypeRegistry, err: *ErrorReporter, global_map_ptr: int) Checker {
        var c = Checker.init(ast, types, err)
        // Replace the fresh global scope map with the shared one
        // scope_maps[0] is a raw pointer to a heap Map(string, int)
        @intToPtr(*int, c.scope_maps.items).* = global_map_ptr
        return c
    }

    /// Load shared state from SharedCheckerState for multi-file mode.
    /// Call AFTER initShared, BEFORE checkFile.
    fn loadSharedState(shared: *SharedCheckerState) void {
        self.symbols = shared.symbols
        self.generic_structs = shared.generic_structs
        self.generic_functions = shared.generic_functions
        self.instantiation_cache = shared.instantiation_cache
        self.trait_defs = shared.trait_defs
        self.trait_impls = shared.trait_impls
        self.generic_impl_entries = shared.generic_impl_entries
    }

    /// Write checker state back to SharedCheckerState after checkFile().
    fn syncToShared(shared: *SharedCheckerState) void {
        shared.symbols = self.symbols
        shared.generic_structs = self.generic_structs
        shared.generic_functions = self.generic_functions
        shared.instantiation_cache = self.instantiation_cache
        shared.generic_impl_entries = self.generic_impl_entries
        shared.trait_defs = self.trait_defs
        shared.trait_impls = self.trait_impls
    }

    // ---- Scope management ----

    fn pushScope() int {
        const idx = self.scope_parents.count
        var new_map = allocMap()
        self.scope_parents.append(self.current_scope)
        self.scope_maps.append(new_map)
        self.current_scope = idx
        return idx
    }

    fn popScope() void {
        self.current_scope = self.scope_parents.get(self.current_scope)
    }

    // ---- Type substitution (active during generic instantiation) ----

    fn hasTypeSubstitution() bool {
        return self.type_sub_keys.count > 0
    }

    fn lookupTypeSub(name: string) int {
        // Search in reverse: last-pushed wins (inner generic shadows outer)
        // Matches Zig pattern where each instantiation replaces the entire map
        var i = self.type_sub_keys.count
        while (i > 0) {
            i -= 1
            if (self.type_sub_keys.get(i) == name) {
                return self.type_sub_vals.get(i)
            }
        }
        return -1
    }

    fn pushTypeSub(key: string, val: int) void {
        self.type_sub_keys.append(key)
        self.type_sub_vals.append(val)
    }

    fn defineSymbol(sym: Symbol) void {
        const idx = self.symbols.count
        self.symbols.append(sym)
        // Register in current scope's map
        var map = self.getScopeMap(self.current_scope)
        map.set(sym.name, idx)
    }

    fn isDefined(name: string) bool {
        var map = self.getScopeMap(self.current_scope)
        return map.has(name) != 0
    }

    fn lookupSymbol(name: string) int {
        var scope_idx = self.current_scope
        while (scope_idx >= 0) {
            var map = self.getScopeMap(scope_idx)
            if (map.has(name) != 0) {
                const sym_idx = map.get(name)
                // Mark as used for lint checks
                self.getSymbol(sym_idx).used = true
                return sym_idx
            }
            scope_idx = self.scope_parents.get(scope_idx)
        }
        return -1
    }

    fn getSymbol(idx: int) *Symbol {
        return @intToPtr(*Symbol, self.symbols.items + idx * @sizeOf(Symbol))
    }

    fn getScopeMap(scope_idx: int) *Map(string, int) {
        return @intToPtr(*Map(string, int), self.scope_maps.get(scope_idx))
    }

    // ---- Main entry point ----

    fn checkFile() void {
        self.safe_mode = self.ast.safe_mode

        // Pass 1: collect type declarations (struct, enum, union, type alias)
        for i in 0..self.ast.file_decls.count {
            self.collectTypeDecl(self.ast.file_decls.get(i))
        }

        // Pass 2: collect non-type declarations (fn, var/const, impl)
        for i in 0..self.ast.file_decls.count {
            self.collectNonTypeDecl(self.ast.file_decls.get(i))
        }

        // Pass 3: check declaration bodies
        for i in 0..self.ast.file_decls.count {
            self.checkDecl(self.ast.file_decls.get(i))
        }
    }

    // ---- Declaration collection (pass 1 & 2) ----

    fn collectTypeDecl(idx: int) void {
        const tag = nodeTag(self.ast, idx)
        if (tag == "struct_decl") { self.collectStructDecl(idx) }
        else if (tag == "enum_decl") { self.collectEnumDecl(idx) }
        else if (tag == "union_decl") { self.collectUnionDecl(idx) }
        else if (tag == "type_alias") { self.collectTypeAlias(idx) }
        else if (tag == "error_set_decl") { self.collectErrorSetDecl(idx) }
        else if (tag == "trait_decl") { self.collectTraitDecl(idx) }
    }

    fn collectNonTypeDecl(idx: int) void {
        const tag = nodeTag(self.ast, idx)
        if (tag == "fn_decl") { self.collectFnDecl(idx) }
        else if (tag == "var_decl") { self.collectVarDecl(idx) }
        else if (tag == "impl_block") { self.collectImplBlock(idx) }
        else if (tag == "impl_trait") { self.collectImplTrait(idx) }
    }

    fn collectStructDecl(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.struct_decl |sd| => {
            const name = sd.name
            if (self.isDefined(name)) {
                self.reportError(idx, ErrorCode.e302, "redefined identifier")
                return
            }

            // Generic structs: store definition, don't build concrete type yet
            if (sd.type_params.count > 0) {
                // Store GenericInfo with AST pointer for cross-file resolution
                // Zig: self.generics.generic_structs.put(name, .{ .node_idx = idx, .tree = self.tree })
                var info = new GenericInfo { node_idx: idx, ast_ptr: @ptrToInt(self.ast) }
                retain(@ptrToInt(self.ast))   // AST escapes as raw int — ARC can't track
                retain(@ptrToInt(info))       // Keep GenericInfo alive past local scope
                self.generic_structs.set(name, @ptrToInt(info))
                self.defineSymbol(makeTypeSymbol(name, invalid_type, idx))
                return
            }

            const struct_type = self.buildStructType(idx, name)
            self.defineSymbol(makeTypeSymbol(name, struct_type, idx))
            self.types.registerNamed(name, struct_type)

            // Register nested declarations with qualified names (Parent_Child)
            for ni in 0..sd.nested_decls.count {
                const nested_idx = sd.nested_decls.get(ni)
                self.collectNestedDecl(name, nested_idx)
            }
        }, else => {} }, else => {} }
    }

    fn collectNestedDecl(parent_name: string, nested_idx: int) void {
        const ntag = nodeTag(self.ast, nested_idx)
        const node = self.ast.getNode(nested_idx)
        if (ntag == "error_set_decl") {
            switch (node) { Node.decl |d| => switch (d) { Decl.error_set_decl |esd| => {
                const qualified = "${parent_name}_${esd.name}"
                self.collectErrorSetDeclAs(nested_idx, qualified)
            }, else => {} }, else => {} }
        } else if (ntag == "enum_decl") {
            switch (node) { Node.decl |d| => switch (d) { Decl.enum_decl |ed| => {
                const qualified = "${parent_name}_${ed.name}"
                const enum_type = self.buildEnumType(nested_idx)
                self.defineSymbol(makeTypeSymbol(qualified, enum_type, nested_idx))
                self.types.registerNamed(qualified, enum_type)
            }, else => {} }, else => {} }
        } else if (ntag == "struct_decl") {
            switch (node) { Node.decl |d| => switch (d) { Decl.struct_decl |sd| => {
                const qualified = "${parent_name}_${sd.name}"
                const ns_type = self.buildStructType(nested_idx, qualified)
                self.defineSymbol(makeTypeSymbol(qualified, ns_type, nested_idx))
                self.types.registerNamed(qualified, ns_type)
            }, else => {} }, else => {} }
        } else if (ntag == "type_alias") {
            switch (node) { Node.decl |d| => switch (d) { Decl.type_alias |ta| => {
                const qualified = "${parent_name}_${ta.name}"
                const target_type = self.resolveTypeExpr(ta.target)
                self.defineSymbol(makeTypeSymbol(qualified, target_type, nested_idx))
                self.types.registerNamed(qualified, target_type)
            }, else => {} }, else => {} }
        } else if (ntag == "var_decl") {
            switch (node) { Node.decl |d| => switch (d) { Decl.var_decl |v| => {
                const qualified = "${parent_name}_${v.name}"
                self.defineSymbol(makeSymbol(qualified, invalid_type, nested_idx, !v.is_const))
            }, else => {} }, else => {} }
        }
    }

    fn collectErrorSetDeclAs(idx: int, qualified_name: string) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.error_set_decl |esd| => {
            const variants_count = esd.variants.count
            var variant_names_ptr: int = 0
            if (variants_count > 0) {
                variant_names_ptr = alloc(0, variants_count * @sizeOf(ErrorVariant))
                for vi in 0..variants_count {
                    const v_str = esd.variants.get(vi)
                    const ev = @intToPtr(*ErrorVariant, variant_names_ptr + vi * @sizeOf(ErrorVariant))
                    ev.name = v_str
                }
            }
            const es_type = self.types.add(Type.error_set(ErrorSetType {
                name: qualified_name,
                variant_count: variants_count,
                variant_names: variant_names_ptr,
            }))
            self.defineSymbol(makeTypeSymbol(qualified_name, es_type, idx))
            self.types.registerNamed(qualified_name, es_type)
        }, else => {} }, else => {} }
    }

    fn collectEnumDecl(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.enum_decl |ed| => {
            const name = ed.name
            if (self.isDefined(name)) {
                self.reportError(idx, ErrorCode.e302, "redefined identifier")
                return
            }
            const enum_type = self.buildEnumType(idx)
            self.defineSymbol(makeTypeSymbol(name, enum_type, idx))
            self.types.registerNamed(name, enum_type)
        }, else => {} }, else => {} }
    }

    fn collectUnionDecl(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.union_decl |ud| => {
            const name = ud.name
            if (self.isDefined(name)) {
                self.reportError(idx, ErrorCode.e302, "redefined identifier")
                return
            }
            const union_type = self.buildUnionType(idx)
            self.defineSymbol(makeTypeSymbol(name, union_type, idx))
            self.types.registerNamed(name, union_type)
        }, else => {} }, else => {} }
    }

    fn collectTypeAlias(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.type_alias |ta| => {
            const name = ta.name
            if (self.isDefined(name)) {
                self.reportError(idx, ErrorCode.e302, "redefined identifier")
                return
            }
            const target_type = self.resolveTypeExpr(ta.target)
            self.defineSymbol(makeTypeSymbol(name, target_type, idx))
            self.types.registerNamed(name, target_type)
        }, else => {} }, else => {} }
    }

    fn collectErrorSetDecl(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.error_set_decl |esd| => {
            const name = esd.name
            if (self.isDefined(name)) {
                self.reportError(idx, ErrorCode.e302, "redefined identifier")
                return
            }
            // Build error set type with variant names (Zig checker.zig:435-439)
            const variants_count = esd.variants.count
            var variant_names_ptr: int = 0
            if (variants_count > 0) {
                variant_names_ptr = alloc(0, variants_count * @sizeOf(ErrorVariant))
                for vi in 0..variants_count {
                    const v_str = esd.variants.get(vi)
                    const ev = @intToPtr(*ErrorVariant, variant_names_ptr + vi * @sizeOf(ErrorVariant))
                    ev.name = v_str
                }
            }
            const es_type = self.types.add(Type.error_set(ErrorSetType {
                name: name,
                variant_count: variants_count,
                variant_names: variant_names_ptr,
            }))
            self.defineSymbol(makeTypeSymbol(name, es_type, idx))
            self.types.registerNamed(name, es_type)
        }, else => {} }, else => {} }
    }

    fn collectFnDecl(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.fn_decl |f| => {
            const name = f.name
            if (self.isDefined(name)) {
                self.reportError(idx, ErrorCode.e302, "redefined identifier")
                return
            }

            // Generic functions: store definition, don't build concrete type yet
            if (f.type_params.count > 0) {
                // Store GenericInfo with AST pointer for cross-file resolution
                var info = new GenericInfo { node_idx: idx, ast_ptr: @ptrToInt(self.ast) }
                retain(@ptrToInt(self.ast))   // AST escapes as raw int — ARC can't track
                retain(@ptrToInt(info))       // Keep GenericInfo alive past local scope
                self.generic_functions.set(name, @ptrToInt(info))
                self.defineSymbol(makeTypeSymbol(name, invalid_type, idx))
                return
            }

            const func_type = self.buildFuncType(idx)
            if (f.is_extern) {
                self.defineSymbol(makeExternFuncSymbol(name, func_type, idx))
            } else {
                var sym = makeFuncSymbol(name, func_type, idx)
                sym.is_export = f.is_export
                self.defineSymbol(sym)
            }
        }, else => {} }, else => {} }
    }

    fn collectVarDecl(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.var_decl |v| => {
            const name = v.name
            if (self.isDefined(name)) {
                self.reportError(idx, ErrorCode.e302, "redefined identifier")
                return
            }
            self.defineSymbol(makeSymbol(name, invalid_type, idx, !v.is_const))
        }, else => {} }, else => {} }
    }

    fn collectImplBlock(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.impl_block |ib| => {
            const type_name = ib.type_name

            // Generic impl blocks: store for deferred instantiation
            if (ib.type_params.count > 0) {
                // Retain the AST so it survives after checkFileRecursive returns
                retain(@ptrToInt(self.ast))
                self.generic_impl_entries.append(GenericImplEntry {
                    base_name: type_name,
                    node_idx: idx,
                    tp_count: ib.type_params.count,
                    methods_count: ib.methods.count,
                    ast_ptr: @ptrToInt(self.ast),
                })
                return
            }

            for mi in 0..ib.methods.count {
                self.collectImplMethod(type_name, ib.methods.get(mi))
            }

            // Register associated constants: impl Foo { const MAX = 100 }
            // → defines "Foo.MAX" as a const symbol in global scope
            for ci in 0..ib.consts.count {
                self.collectAssociatedConst(type_name, ib.consts.get(ci))
            }
        }, else => {} }, else => {} }
    }

    /// Register an associated constant from an impl block.
    /// impl Foo { const MAX = 100 } → symbol "Foo.MAX"
    fn collectAssociatedConst(type_name: string, const_idx: int) void {
        const ctag = nodeTag(self.ast, const_idx)
        if (ctag != "var_decl") { return }
        const cnode = self.ast.getNode(const_idx)
        switch (cnode) { Node.decl |d| => switch (d) { Decl.var_decl |v| => {
            if (!v.is_const) { return }
            const synth_name = "${type_name}_${v.name}"
            // Try to evaluate as a constant
            var const_val: int = 0
            var const_type: int = invalid_type
            if (v.value != null_node) {
                const cv = self.evalConstExpr(v.value)
                if (cv.0 != 0) {
                    const_val = cv.1
                    const_type = I64
                }
            }
            if (v.type_expr != null_node) {
                const_type = self.resolveTypeExpr(v.type_expr)
            }
            if (const_type == invalid_type) { const_type = I64 }
            self.defineSymbol(makeConstSymbol(synth_name, const_type, const_idx, const_val))
        }, else => {} }, else => {} }
    }

    fn collectImplMethod(type_name: string, method_idx: int) void {
        const mtag = nodeTag(self.ast, method_idx)
        const mnode = self.ast.getNode(method_idx)
        if (mtag == "fn_decl") {
            switch (mnode) { Node.decl |d| => switch (d) { Decl.fn_decl |f| => {
                const method_name = f.name
                const synth_name = "${type_name}_${method_name}"
                const func_type = self.buildFuncType(method_idx)

                // Detect static (no params or first param not named "self")
                var is_static = true
                if (f.params.count > 0) {
                    const first_param = f.params.get(0)
                    const fp_node = self.ast.getNode(first_param)
                    switch (fp_node) { Node.expr |e| => switch (e) { Expr.field_def |fd| => {
                        if (fd.name == "self") {
                            is_static = false
                        }
                    }, else => {} }, else => {} }
                }

                self.defineSymbol(makeFuncSymbol(synth_name, func_type, method_idx))
                self.types.registerMethod(type_name, MethodInfo {
                    name: method_name,
                    func_name: synth_name,
                    func_type: func_type,
                    receiver_is_ptr: !is_static,
                    is_static: is_static,
                })
            }, else => {} }, else => {} }
        } else if (mtag == "var_decl") {
            switch (mnode) { Node.decl |d| => switch (d) { Decl.var_decl |v| => {
                const synth_name = "${type_name}_${v.name}"
                self.defineSymbol(makeSymbol(synth_name, invalid_type, method_idx, !v.is_const))
            }, else => {} }, else => {} }
        }
    }

    fn collectTraitDecl(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.trait_decl |td| => {
            self.trait_defs.set(td.name, idx)
        }, else => {} }, else => {} }
    }

    fn collectImplTrait(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.impl_trait |it| => {
            const trait_name = it.trait_name
            const target_type = it.target_type

            // Validate trait exists
            if (self.trait_defs.has(trait_name) == 0) {
                self.reportError(idx, ErrorCode.e301, "undefined trait")
                return
            }

            // Validate all required methods are provided
            const trait_idx = self.trait_defs.get(trait_name)
            const trait_node = self.ast.getNode(trait_idx)
            switch (trait_node) { Node.decl |td_outer| => switch (td_outer) { Decl.trait_decl |td| => {
                for ti in 0..td.methods.count {
                    const trait_method_idx = td.methods.get(ti)
                    if (nodeTag(self.ast, trait_method_idx) == "fn_decl") {
                        // Extract required method name
                        const tm_node = self.ast.getNode(trait_method_idx)
                        var required_name = ""
                        switch (tm_node) { Node.decl |tmd| => switch (tmd) { Decl.fn_decl |tmf| => {
                            required_name = tmf.name
                        }, else => {} }, else => {} }

                        var found = false
                        for mi in 0..it.methods.count {
                            const impl_method_idx = it.methods.get(mi)
                            if (nodeTag(self.ast, impl_method_idx) == "fn_decl") {
                                const im_node = self.ast.getNode(impl_method_idx)
                                switch (im_node) { Node.decl |imd| => switch (imd) { Decl.fn_decl |imf| => {
                                    if (imf.name == required_name) {
                                        found = true
                                    }
                                }, else => {} }, else => {} }
                            }
                        }
                        if (!found) {
                            self.reportError(idx, ErrorCode.e300, "missing required trait method")
                            return
                        }
                    }
                }
            }, else => {} }, else => {} }

            // Register trait impl for trait bound validation
            const impl_key = "${trait_name}:${target_type}"
            self.trait_impls.set(impl_key, trait_name)

            // Register methods (same pattern as impl_block)
            for mi in 0..it.methods.count {
                self.collectImplMethod(target_type, it.methods.get(mi))
            }
        }, else => {} }, else => {} }
    }

    // ---- Declaration checking (pass 3) ----

    fn checkDecl(idx: int) void {
        const tag = nodeTag(self.ast, idx)
        if (tag == "fn_decl") {
            const node = self.ast.getNode(idx)
            switch (node) { Node.decl |d| => switch (d) { Decl.fn_decl |f| => {
                // Skip generic functions
                if (f.type_params.count > 0) { return }
                self.checkFnDeclBody(idx, f.name)
            }, else => {} }, else => {} }
        }
        else if (tag == "var_decl") { self.checkTopVarDecl(idx) }
        else if (tag == "impl_block") { self.checkImplBlock(idx) }
        else if (tag == "impl_trait") { self.checkImplTraitBodies(idx) }
        else if (tag == "test_decl" or tag == "bench_decl") { self.checkTestDecl(idx) }
    }

    fn checkImplBlock(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.impl_block |ib| => {
            // Skip generic impl blocks
            if (ib.type_params.count > 0) { return }

            for mi in 0..ib.methods.count {
                const method_idx = ib.methods.get(mi)
                if (nodeTag(self.ast, method_idx) == "fn_decl") {
                    const m_node = self.ast.getNode(method_idx)
                    switch (m_node) { Node.decl |md| => switch (md) { Decl.fn_decl |mf| => {
                        self.checkFnDeclBody(method_idx, "${ib.type_name}_${mf.name}")
                    }, else => {} }, else => {} }
                }
            }
        }, else => {} }, else => {} }
    }

    fn checkImplTraitBodies(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.impl_trait |it| => {
            for mi in 0..it.methods.count {
                const method_idx = it.methods.get(mi)
                if (nodeTag(self.ast, method_idx) == "fn_decl") {
                    const m_node = self.ast.getNode(method_idx)
                    switch (m_node) { Node.decl |md| => switch (md) { Decl.fn_decl |mf| => {
                        self.checkFnDeclBody(method_idx, "${it.target_type}_${mf.name}")
                    }, else => {} }, else => {} }
                }
            }
        }, else => {} }, else => {} }
    }

    fn checkTestDecl(idx: int) void {
        // Works for both test_decl and bench_decl (both have .body field)
        var body: int = null_node
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) {
            Decl.test_decl |t| => { body = t.body },
            Decl.bench_decl |b| => { body = b.body },
            else => {},
        }, else => {} }
        if (body == null_node) { return }
        self.pushScope()
        const old_ret = self.current_return_type
        self.current_return_type = VOID
        self.checkStmt(body)
        self.current_return_type = old_ret
        self.popScope()
    }

    fn checkFnDeclBody(idx: int, lookup_name: string) void {
        const sym_idx = self.lookupSymbol(lookup_name)
        if (sym_idx < 0) { return }
        const sym = self.getSymbol(sym_idx)

        // Get return type from func type
        var return_type: int = VOID
        const func_t = self.types.get(sym.type_idx)
        if (func_t.tag == TAG_FUNC) {
            const ft = switch (func_t) {
                Type.func |f| => f,
                else => FuncType { param_count: 0, params: 0, return_type: VOID },
            }
            return_type = ft.return_type
        }

        const fn_node = self.ast.getNode(idx)
        switch (fn_node) { Node.decl |d| => switch (d) { Decl.fn_decl |f| => {
            if (f.body == null_node) { return }

            self.pushScope()
            const old_ret = self.current_return_type
            self.current_return_type = return_type

            // Define parameters in scope (same substitution-aware @safe as buildFuncType)
            for pi in 0..f.params.count {
                const param_idx = f.params.get(pi)
                if (nodeTag(self.ast, param_idx) == "field_def") {
                    const p_node = self.ast.getNode(param_idx)
                    switch (p_node) { Node.expr |e| => switch (e) { Expr.field_def |fd| => {
                        const pname = fd.name
                        const ptype_n = fd.type_expr
                        var ptype = self.resolveTypeExpr(ptype_n)
                        // Don't auto-ref params whose type is a substituted generic type parameter
                        var is_substituted = false
                        if (self.hasTypeSubstitution() and ptype_n != null_node) {
                            const ptype_tag = nodeTag(self.ast, ptype_n)
                            if (ptype_tag == "ident") {
                                const pt_node = self.ast.getNode(ptype_n)
                                switch (pt_node) { Node.expr |pe| => switch (pe) { Expr.ident |id| => {
                                    if (self.lookupTypeSub(id.name) >= 0) {
                                        is_substituted = true
                                    }
                                }, else => {} }, else => {} }
                            } else if (ptype_tag == "type_expr") {
                                const pt_node = self.ast.getNode(ptype_n)
                                switch (pt_node) { Node.expr |pe| => switch (pe) { Expr.type_expr |te| => {
                                    if (te.kind == TYPE_NAMED) {
                                        const inner_n = te.data1
                                        if (inner_n != null_node and nodeTag(self.ast, inner_n) == "ident") {
                                            const in_node = self.ast.getNode(inner_n)
                                            switch (in_node) { Node.expr |ie| => switch (ie) { Expr.ident |iid| => {
                                                if (self.lookupTypeSub(iid.name) >= 0) {
                                                    is_substituted = true
                                                }
                                            }, else => {} }, else => {} }
                                        }
                                    }
                                }, else => {} }, else => {} }
                            }
                        }
                        if (!is_substituted) {
                            ptype = self.safeWrapType(ptype)
                        }
                        self.defineSymbol(makeParamSymbol(pname, ptype, idx))
                    }, else => {} }, else => {} }
                }
            }

            self.checkBlockBody(f.body)

            self.current_return_type = old_ret
            self.popScope()
        }, else => {} }, else => {} }
    }

    fn checkTopVarDecl(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.decl |d| => switch (d) { Decl.var_decl |v| => {
            var var_type: int = invalid_type
            if (v.type_expr != null_node) {
                var_type = self.resolveTypeExpr(v.type_expr)
            }
            if (v.value != null_node) {
                const val_type = self.checkExpr(v.value)
                if (var_type == invalid_type) {
                    var_type = self.materializeType(val_type)
                } else if (!self.types.isAssignable(val_type, var_type)) {
                    self.reportError(idx, ErrorCode.e300, "type mismatch")
                }
            }

            // Update symbol with resolved type
            const sym_idx = self.lookupSymbol(v.name)
            if (sym_idx >= 0) {
                // Try to evaluate const value
                if (v.is_const and v.value != null_node) {
                    const cv = self.evalConstExpr(v.value)
                    if (cv.0 != 0) {
                        self.updateSymbolType(sym_idx, var_type)
                        self.updateSymbolConst(sym_idx, cv.1)
                        return
                    }
                }
                self.updateSymbolType(sym_idx, var_type)
            }

            // Register error set consts as named types for use in type positions
            // Enables: const AllErrors = FileError || NetError
            // Zig checker.zig:694-698
            if (v.is_const and var_type != invalid_type) {
                const vt = self.types.get(var_type)
                if (vt.tag == TAG_ERROR_SET) {
                    self.types.registerNamed(v.name, var_type)
                }
            }
        }, else => {} }, else => {} }
    }

    fn updateSymbolType(sym_idx: int, type_idx: int) void {
        var sym_ptr = self.getSymbol(sym_idx)
        sym_ptr.type_idx = type_idx
    }

    fn updateSymbolConst(sym_idx: int, value: int) void {
        var sym_ptr = self.getSymbol(sym_idx)
        sym_ptr.is_const_val = true
        sym_ptr.const_value = value
    }

    // ---- Statement checking ----

    fn checkStmt(idx: int) void {
        if (idx == null_node) { return }
        const tag = nodeTag(self.ast, idx)
        if (tag == "expr_stmt") {
            const node = self.ast.getNode(idx)
            switch (node) { Node.stmt |s| => switch (s) { Stmt.expr_stmt |es| => {
                self.checkExpr(es.expr)
            }, else => {} }, else => {} }
        }
        else if (tag == "return_stmt") { self.checkReturn(idx) }
        else if (tag == "var_stmt") { self.checkVarStmt(idx) }
        else if (tag == "assign_stmt") { self.checkAssign(idx) }
        else if (tag == "if_stmt") { self.checkIfStmt(idx) }
        else if (tag == "while_stmt") { self.checkWhileStmt(idx) }
        else if (tag == "for_stmt") { self.checkForStmt(idx) }
        else if (tag == "block_stmt") { self.checkBlockStmt(idx) }
        else if (tag == "break_stmt") { if (!self.in_loop) { self.reportError(idx, ErrorCode.e400, "break outside loop") } }
        else if (tag == "continue_stmt") { if (!self.in_loop) { self.reportError(idx, ErrorCode.e401, "continue outside loop") } }
        else if (tag == "defer_stmt") {
            const node = self.ast.getNode(idx)
            switch (node) { Node.stmt |s| => switch (s) { Stmt.defer_stmt |ds| => {
                self.checkExpr(ds.expr)
            }, else => {} }, else => {} }
        }
        else if (tag == "destructure_stmt") { self.checkDestructureStmt(idx) }
    }

    fn checkReturn(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.stmt |s| => switch (s) { Stmt.return_stmt |rs| => {
            if (rs.value != null_node) {
                const saved_expected = self.expected_type
                self.expected_type = self.current_return_type
                const val_type = self.checkExpr(rs.value)
                self.expected_type = saved_expected
                if (self.current_return_type == VOID) {
                    self.reportError(idx, ErrorCode.e402, "void function should not return a value")
                } else if (!self.types.isAssignable(val_type, self.current_return_type)) {
                    self.reportError(idx, ErrorCode.e300, "type mismatch")
                }
            } else if (self.current_return_type != VOID) {
                self.reportError(idx, ErrorCode.e402, "non-void function must return a value")
            }
        }, else => {} }, else => {} }
    }

    fn checkVarStmt(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.stmt |s| => switch (s) { Stmt.var_stmt |vs| => {
            if (self.isDefined(vs.name)) {
                // "previously defined here" note (Zig ref: checker.zig:562-570)
                const prev_sym_idx = self.lookupSymbol(vs.name)
                if (prev_sym_idx >= 0) {
                    const prev_sym = self.getSymbol(prev_sym_idx)
                    if (prev_sym.node != null_node) {
                        const prev_span = self.ast.nodeSpan(prev_sym.node)
                        var offset: int = 0
                        if (idx != null_node) { offset = self.ast.nodeSpan(idx).start }
                        self.err.reportWithNote(offset, ErrorCode.e302, "redefined identifier", prev_span.start, "previously defined here")
                    } else {
                        self.reportError(idx, ErrorCode.e302, "redefined identifier")
                    }
                } else {
                    self.reportError(idx, ErrorCode.e302, "redefined identifier")
                }
                return
            }

            // Shadow warning W003 (Zig ref: checker.zig:2897-2901)
            if (self.lint_mode) {
                const shadow_idx = self.lookupSymbol(vs.name)
                if (shadow_idx >= 0) {
                    self.err.warningWithCode(self.ast.nodeSpan(idx).start, WarningCode.w003, vs.name)
                }
            }

            var var_type: int = invalid_type
            if (vs.type_expr != null_node) {
                var_type = self.resolveTypeExpr(vs.type_expr)
            }

            if (vs.value != null_node) {
                // Zero-init requires type annotation (Zig ref: checker.zig:2921-2923)
                if (nodeTag(self.ast, vs.value) == "zero_init" and var_type == invalid_type) {
                    self.reportError(idx, ErrorCode.e300, "zero init requires type annotation")
                    return
                }
                // Check for undefined literal
                if (nodeTag(self.ast, vs.value) != "literal" or self.getLiteralKind(vs.value) != @intFromEnum(LiteralKind.undefined_lit)) {
                    const saved_expected = self.expected_type
                    if (var_type != invalid_type) { self.expected_type = var_type }
                    const val_type = self.checkExpr(vs.value)
                    self.expected_type = saved_expected
                    if (var_type == invalid_type) {
                        var_type = self.materializeType(val_type)
                    } else if (!self.types.isAssignable(val_type, var_type)) {
                        // @safe coercion: Foo accepts *Foo (Zig ref: checker.zig:2910-2918)
                        var coerced = false
                        if (self.safe_mode) {
                            const var_t = self.types.get(var_type)
                            const val_t = self.types.get(val_type)
                            if (var_t.tag == TAG_STRUCT and val_t.tag == TAG_POINTER) {
                                const pointee = switch (val_t) { Type.pointer |p| => p.elem, else => invalid_type }
                                if (pointee == var_type) {
                                    var_type = val_type
                                    coerced = true
                                }
                            }
                        }
                        if (!coerced) {
                            self.reportError(idx, ErrorCode.e300, "type mismatch")
                        }
                    }
                }
            }

            // Unowned/weak validation (Zig ref: checker.zig:2925-2935)
            if (vs.is_unowned or vs.is_weak) {
                if (!self.types.couldBeARC(var_type)) {
                    const qual = if (vs.is_unowned) { "unowned" } else { "weak" }
                    self.reportError(idx, ErrorCode.e300, "${qual} requires ARC-managed type")
                }
            }

            // Store const_value for comptime const-folding
            if (vs.is_const and vs.value != null_node) {
                const cv = self.evalConstExpr(vs.value)
                if (cv.0 != 0) {
                    self.defineSymbol(makeConstSymbol(vs.name, var_type, idx, cv.1))
                    return
                }
            }
            self.defineSymbol(makeSymbol(vs.name, var_type, idx, !vs.is_const))
        }, else => {} }, else => {} }
    }

    fn checkAssign(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.stmt |s| => switch (s) { Stmt.assign_stmt |asgn| => {
            // Validate assignment target (Zig ref: checker.zig:2988-2998)
            const target_tag = nodeTag(self.ast, asgn.target)
            if (target_tag != "ident" and target_tag != "index_expr" and
                target_tag != "field_access" and target_tag != "deref") {
                self.reportError(idx, ErrorCode.e303, "invalid assignment target")
                return
            }

            const target_type = self.checkExpr(asgn.target)
            const value_type = self.checkExpr(asgn.value)

            // Check mutability for identifier targets
            if (target_tag == "ident") {
                const t_node = self.ast.getNode(asgn.target)
                switch (t_node) { Node.expr |e| => switch (e) { Expr.ident |id| => {
                    const sym_idx = self.lookupSymbol(id.name)
                    if (sym_idx >= 0) {
                        const sym = self.getSymbol(sym_idx)
                        if (!sym.mutable) {
                            self.reportError(idx, ErrorCode.e303, "cannot assign to constant")
                            return
                        }
                    }
                }, else => {} }, else => {} }
            }

            if (!self.types.isAssignable(value_type, target_type)) {
                self.reportError(idx, ErrorCode.e300, "type mismatch")
            }
        }, else => {} }, else => {} }
    }

    fn checkIfStmt(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.stmt |s| => switch (s) { Stmt.if_stmt |ifs| => {
            const cond_type = self.checkExpr(ifs.condition)

            // Optional capture: if (expr) |val| { }
            if (@lenOf(ifs.capture) > 0) {
                const cond_t = self.types.get(cond_type)
                if (cond_t.tag != TAG_OPTIONAL) {
                    self.reportError(idx, ErrorCode.e300, "capture requires optional type")
                    return
                }
                const elem_type = switch (cond_t) {
                    Type.optional |o| => o.elem,
                    else => invalid_type,
                }
                self.pushScope()
                self.defineSymbol(makeSymbol(ifs.capture, elem_type, null_node, false))
                self.checkStmt(ifs.then_branch)
                self.popScope()
                if (ifs.else_branch != null_node) { self.checkStmt(ifs.else_branch) }
                return
            }

            // Normal if: condition must be bool
            if (!self.isBoolType(cond_type)) {
                self.reportError(idx, ErrorCode.e300, "condition must be bool")
            }

            // Comptime dead branch elimination
            const cv = self.evalConstExpr(ifs.condition)
            if (cv.0 != 0) {
                if (cv.1 != 0) { self.checkStmt(ifs.then_branch); return }
                if (ifs.else_branch != null_node) { self.checkStmt(ifs.else_branch); return }
                return
            }

            self.warnEmptyBlock(idx, ifs.then_branch)
            self.checkStmt(ifs.then_branch)
            if (ifs.else_branch != null_node) {
                self.warnEmptyBlock(idx, ifs.else_branch)
                self.checkStmt(ifs.else_branch)
            }
        }, else => {} }, else => {} }
    }

    fn checkWhileStmt(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.stmt |s| => switch (s) { Stmt.while_stmt |ws| => {
            const cond_type = self.checkExpr(ws.condition)

            if (@lenOf(ws.capture) > 0) {
                const cond_t = self.types.get(cond_type)
                if (cond_t.tag != TAG_OPTIONAL) {
                    self.reportError(idx, ErrorCode.e300, "capture requires optional type")
                    return
                }
                const elem_type = switch (cond_t) {
                    Type.optional |o| => o.elem,
                    else => invalid_type,
                }
                self.pushScope()
                self.defineSymbol(makeSymbol(ws.capture, elem_type, null_node, false))
                const old_in_loop = self.in_loop
                self.in_loop = true
                self.checkStmt(ws.body)
                self.in_loop = old_in_loop
                self.popScope()
                return
            }

            if (!self.isBoolType(cond_type)) {
                self.reportError(idx, ErrorCode.e300, "condition must be bool")
            }
            self.warnEmptyBlock(idx, ws.body)
            const old_in_loop = self.in_loop
            self.in_loop = true
            self.checkStmt(ws.body)
            // Check continue expression (Zig ref: checker.zig:3059, 3072)
            if (ws.continue_expr != null_node) {
                self.checkExpr(ws.continue_expr)
            }
            self.in_loop = old_in_loop
        }, else => {} }, else => {} }
    }

    fn checkForStmt(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.stmt |s| => switch (s) { Stmt.for_stmt |fs| => {
            // Inline for: unroll at comptime with const binding per iteration
            if (fs.is_inline) {
                self.checkInlineFor(idx)
                return
            }

            var elem_type: int = invalid_type
            const is_range = fs.range_start != null_node and fs.range_end != null_node

            if (is_range) {
                const start_type = self.checkExpr(fs.range_start)
                const end_type = self.checkExpr(fs.range_end)
                if (!self.isIntegerType(start_type) or !self.isIntegerType(end_type)) {
                    self.reportError(idx, ErrorCode.e300, "range bounds must be integers")
                }
                elem_type = self.materializeType(start_type)
            } else if (fs.iterable != null_node) {
                const iter_type = self.checkExpr(fs.iterable)
                const iter_t = self.types.get(iter_type)
                if (iter_type == STRING) {
                    elem_type = U8
                } else if (iter_t.tag == TAG_ARRAY) {
                    elem_type = switch (iter_t) { Type.array |a| => a.elem, else => invalid_type }
                } else if (iter_t.tag == TAG_SLICE) {
                    elem_type = switch (iter_t) { Type.slice |sl| => sl.elem, else => invalid_type }
                } else if (iter_t.tag == TAG_MAP) {
                    // Map iteration: elem = value type, index = key type (Zig ref: checker.zig:3108-3127)
                    const mt = switch (iter_t) { Type.map_type |m| => m, else => CotMapType { key: 0, value: 0 } }
                    elem_type = mt.value
                } else if (iter_t.tag == TAG_LIST) {
                    elem_type = switch (iter_t) { Type.list_type |l| => l.elem, else => invalid_type }
                } else {
                    self.reportError(idx, ErrorCode.e300, "cannot iterate over this type")
                }
            }

            self.pushScope()
            self.defineSymbol(makeSymbol(fs.binding, elem_type, null_node, false))
            if (@lenOf(fs.index_binding) > 0) {
                // Map iteration: index_binding = key type (Zig ref: checker.zig:3108-3127)
                var idx_type: int = I64
                if (fs.iterable != null_node) {
                    const iter_type2 = self.expr_types.get(fs.iterable)
                    if (iter_type2 != 0) {
                        const iter_t2 = self.types.get(iter_type2)
                        if (iter_t2.tag == TAG_MAP) {
                            idx_type = switch (iter_t2) { Type.map_type |m| => m.key, else => I64 }
                        }
                    }
                }
                self.defineSymbol(makeSymbol(fs.index_binding, idx_type, null_node, false))
            }
            self.warnEmptyBlock(idx, fs.body)
            const old_in_loop = self.in_loop
            self.in_loop = true
            self.checkStmt(fs.body)
            self.in_loop = old_in_loop
            self.popScope()
        }, else => {} }, else => {} }
    }

    /// Inline for: evaluate range at comptime, unroll body with const binding per iteration.
    fn checkInlineFor(idx: int) void {
        var binding = ""
        var index_binding = ""
        var start_n = null_node
        var end_n = null_node
        var body_n = null_node
        switch (self.ast.getNode(idx)) { Node.stmt |s| => switch (s) { Stmt.for_stmt |fs| => { binding = fs.binding; index_binding = fs.index_binding; start_n = fs.range_start; end_n = fs.range_end; body_n = fs.body }, else => {} }, else => {} }
        const is_range = start_n != null_node and end_n != null_node
        if (is_range) {
            // Evaluate range bounds at comptime
            const sv = self.evalConstExpr(start_n)
            if (sv.0 == 0) {
                self.reportError(idx, ErrorCode.e300, "inline for range start must be comptime-known")
                return
            }
            const ev = self.evalConstExpr(end_n)
            if (ev.0 == 0) {
                self.reportError(idx, ErrorCode.e300, "inline for range end must be comptime-known")
                return
            }
            // Unroll: check body once per iteration with const binding
            var i = sv.1
            while (i < ev.1) {
                self.pushScope()
                self.defineSymbol(makeConstSymbol(binding, I64, null_node, i))
                if (@lenOf(index_binding) > 0) {
                    self.defineSymbol(makeConstSymbol(index_binding, I64, null_node, i - sv.1))
                }
                self.checkStmt(body_n)
                self.popScope()
                i += 1
            }
            return
        }
        // Non-range inline for (comptime array iteration) — not yet supported
        self.reportError(idx, ErrorCode.e300, "inline for requires comptime-known range")
    }

    fn checkBlockStmt(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.stmt |s| => switch (s) { Stmt.block_stmt |bs| => {
            const scope_idx = self.pushScope()
            // Pre-pass: collect block-scoped type declarations
            self.collectBlockScopedTypes(bs.stmts)
            self.checkStmtsWithReachability(bs.stmts)
            self.checkScopeUnused(scope_idx)
            self.popScope()
        }, else => {} }, else => {} }
    }

    /// Pre-pass: collect struct/enum/union/type_alias/error_set declarations
    /// from a block's statements before checking other statements.
    /// Zig ref: checker.zig:270-281
    fn collectBlockScopedTypes(stmts: List(int)) void {
        for i in 0..stmts.count {
            const stmt_idx = stmts.get(i)
            // Block-scoped types are wrapped as expr_stmt(decl_node)
            const inner = nodeExprStmtExpr(self.ast, stmt_idx)
            if (inner == null_node) { continue }
            const inner_tag = nodeTag(self.ast, inner)
            if (inner_tag == "struct_decl") { self.collectStructDecl(inner) }
            else if (inner_tag == "enum_decl") { self.collectEnumDecl(inner) }
            else if (inner_tag == "union_decl") { self.collectUnionDecl(inner) }
            else if (inner_tag == "type_alias") { self.collectTypeAlias(inner) }
            else if (inner_tag == "error_set_decl") { self.collectErrorSetDecl(inner) }
        }
    }

    fn checkDestructureStmt(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.stmt |s| => switch (s) { Stmt.destructure_stmt |dts| => {
            const val_type = self.checkExpr(dts.value)
            const val_t = self.types.get(val_type)

            if (val_t.tag != TAG_TUPLE) {
                self.reportError(idx, ErrorCode.e300, "destructuring requires a tuple value")
                return
            }

            const tup = switch (val_t) { Type.tuple |t| => t, else => TupleType { elem_count: 0, elem_types: 0 } }
            if (dts.bindings.count != tup.elem_count) {
                self.reportError(idx, ErrorCode.e300, "destructuring count mismatch")
                return
            }

            for i in 0..dts.bindings.count {
                const bind_idx = dts.bindings.get(i)
                const b_node = self.ast.getNode(bind_idx)
                switch (b_node) { Node.expr |e| => switch (e) { Expr.destructure_bind |db| => {
                    var elem_type = tup.getElemType(i)
                    elem_type = self.materializeType(elem_type)
                    // Per-binding type annotation (Zig ref: checker.zig:2946-2986)
                    if (db.type_expr != null_node) {
                        const annotated = self.resolveTypeExpr(db.type_expr)
                        if (!self.types.isAssignable(elem_type, annotated)) {
                            self.reportError(bind_idx, ErrorCode.e300, "type mismatch in destructuring")
                        }
                        elem_type = annotated
                    }
                    self.defineSymbol(makeSymbol(db.name, elem_type, idx, !dts.is_const))
                }, else => {} }, else => {} }
            }
        }, else => {} }, else => {} }
    }

    fn checkBlockBody(idx: int) void {
        if (idx == null_node) { return }
        const tag = nodeTag(self.ast, idx)
        if (tag == "block_stmt") { self.checkBlockStmt(idx) }
        else if (tag == "block_expr") { self.checkBlockExprVoid(idx) }
        else { self.checkStmt(idx) }
    }

    fn checkBlockExprVoid(idx: int) void {
        const node = self.ast.getNode(idx)
        switch (node) { Node.expr |e| => switch (e) { Expr.block_expr |be| => {
            self.pushScope()
            for i in 0..be.stmts.count {
                self.checkStmt(be.stmts.get(i))
            }
            if (be.result_expr != null_node) {
                self.checkExpr(be.result_expr)
            }
            self.popScope()
        }, else => {} }, else => {} }
    }

    // ---- Expression checking ----

    fn checkExpr(idx: int) int {
        if (idx == null_node) { return invalid_type }

        // During generic instantiation, skip cache — shared AST nodes need fresh checking
        if (!self.hasTypeSubstitution() and self.expr_types.has(idx) != 0) {
            return self.expr_types.get(idx)
        }

        const result = self.checkExprInner(idx)
        self.expr_types.set(idx, result)
        return result
    }

    fn checkExprInner(idx: int) int {
        const tag = nodeTag(self.ast, idx)
        if (tag == "ident") { return self.checkIdentifier(idx) }
        if (tag == "literal") { return self.checkLiteral(idx) }
        if (tag == "binary") { return self.checkBinary(idx) }
        if (tag == "unary") { return self.checkUnary(idx) }
        if (tag == "call") { return self.checkCall(idx) }
        if (tag == "index_expr") { return self.checkIndex(idx) }
        if (tag == "field_access") { return self.checkFieldAccess(idx) }
        if (tag == "struct_init") { return self.checkStructInit(idx) }
        if (tag == "new_expr") { return self.checkNewExpr(idx) }
        if (tag == "array_literal") { return self.checkArrayLiteral(idx) }
        if (tag == "paren") {
            const node = self.ast.getNode(idx)
            switch (node) { Node.expr |e| => switch (e) { Expr.paren |p| => { return self.checkExpr(p.inner) }, else => {} }, else => {} }
            return invalid_type
        }
        if (tag == "if_expr") { return self.checkIfExpr(idx) }
        if (tag == "switch_expr") { return self.checkSwitchExpr(idx) }
        if (tag == "block_expr") { return self.checkBlockExpr(idx) }
        if (tag == "builtin_call") { return self.checkBuiltinCall(idx) }
        if (tag == "string_interp") { return self.checkStringInterp(idx) }
        if (tag == "try_expr") { return self.checkTryExpr(idx) }
        if (tag == "catch_expr") { return self.checkCatchExpr(idx) }
        if (tag == "closure_expr") { return self.checkClosureExpr(idx) }
        if (tag == "error_literal") { return self.current_return_type }
        if (tag == "addr_of") { return self.checkAddrOf(idx) }
        if (tag == "deref") { return self.checkDeref(idx) }
        if (tag == "tuple_literal") { return self.checkTupleLiteral(idx) }
        if (tag == "slice_expr") { return self.checkSliceExpr(idx) }
        if (tag == "zero_init") { return self.checkZeroInit() }
        if (tag == "await_expr") { return self.checkAwaitExpr(idx) }
        return invalid_type
    }

    fn checkIdentifier(idx: int) int {
        var name = ""
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.ident |id| => { name = id.name }, else => {} }, else => {} }

        // Check type registry (enum/union used as expression for variant access)
        const type_idx = self.types.lookupByName(name)
        if (type_idx >= 0) {
            const t = self.types.get(type_idx)
            if (t.tag == TAG_ENUM or t.tag == TAG_UNION or t.tag == TAG_ERROR_SET) {
                return type_idx
            }
            // Type name used as expression (Zig ref: checker.zig:1540-1547)
            if (t.tag == TAG_STRUCT) {
                self.reportError(idx, ErrorCode.e300, "type '${name}' used as expression")
                return invalid_type
            }
        }

        const sym_idx = self.lookupSymbol(name)
        if (sym_idx >= 0) {
            const sym = self.getSymbol(sym_idx)
            // Generic function used without type args (Zig ref: checker.zig:1550-1553)
            if (self.generic_functions.has(name) != 0 and !self.hasTypeSubstitution()) {
                self.reportError(idx, ErrorCode.e300, "generic function '${name}' requires type arguments")
                return invalid_type
            }
            return sym.type_idx
        }
        // Try to suggest a similar name
        const suggestion = self.findSimilarName(name)
        if (suggestion) |s| {
            self.reportError(idx, ErrorCode.e301, "undefined identifier '${name}', did you mean '${s}'?")
        } else {
            self.reportError(idx, ErrorCode.e301, "undefined identifier '${name}'")
        }
        return invalid_type
    }

    fn checkLiteral(idx: int) int {
        var kind = 0
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.literal |lit| => { kind = lit.kind }, else => {} }, else => {} }
        if (kind == @intFromEnum(LiteralKind.@"int")) { return UNTYPED_INT }
        if (kind == @intFromEnum(LiteralKind.@"float")) { return UNTYPED_FLOAT }
        if (kind == @intFromEnum(LiteralKind.@"string")) { return STRING }
        if (kind == @intFromEnum(LiteralKind.char)) { return U8 }
        if (kind == @intFromEnum(LiteralKind.true_lit) or kind == @intFromEnum(LiteralKind.false_lit)) { return UNTYPED_BOOL }
        if (kind == @intFromEnum(LiteralKind.null_lit) or kind == @intFromEnum(LiteralKind.undefined_lit)) { return UNTYPED_NULL }
        if (kind == @intFromEnum(LiteralKind.unreachable_lit)) { return NORETURN }
        return invalid_type
    }

    fn getLiteralKind(idx: int) int {
        if (nodeTag(self.ast, idx) != "literal") { return -1 }
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.literal |lit| => { return lit.kind }, else => {} }, else => {} }
        return -1
    }

    fn checkBinary(idx: int) int {
        var op = 0
        var left_n = null_node
        var right_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.binary |bin| => { op = bin.op; left_n = bin.left; right_n = bin.right }, else => {} }, else => {} }
        const left_type = self.checkExpr(left_n)
        const right_type = self.checkExpr(right_n)
        const left_t = self.types.get(left_type)
        const right_t = self.types.get(right_type)

        // Concat: ++
        if (op == @intFromEnum(Token.concat)) {
            if (left_type == STRING and right_type == STRING) { return STRING }
            // [N]T ++ [M]T → [N+M]T (array concat)
            if (left_t.tag == TAG_ARRAY and right_t.tag == TAG_ARRAY) {
                const la = switch (left_t) { Type.array |a| => a, else => ArrayType { elem: invalid_type, length: 0 } }
                const ra = switch (right_t) { Type.array |a| => a, else => ArrayType { elem: invalid_type, length: 0 } }
                if (la.elem == ra.elem) {
                    return self.types.makeArray(la.elem, la.length + ra.length)
                }
                self.reportError(idx, ErrorCode.e300, "'++' requires matching element types")
                return invalid_type
            }
            // []T ++ []T → []T (slice concat)
            if (left_t.tag == TAG_SLICE and right_t.tag == TAG_SLICE) {
                const ls = switch (left_t) { Type.slice |s| => s, else => SliceType { elem: invalid_type } }
                const rs = switch (right_t) { Type.slice |s| => s, else => SliceType { elem: invalid_type } }
                if (ls.elem == rs.elem) { return left_type }
                self.reportError(idx, ErrorCode.e300, "'++' requires matching element types")
                return invalid_type
            }
            self.reportError(idx, ErrorCode.e300, "'++' requires two strings, arrays, or slices of the same type")
            return invalid_type
        }

        // Orelse
        if (op == @intFromEnum(Token.kw_orelse)) {
            if (left_t.tag == TAG_OPTIONAL) {
                return switch (left_t) { Type.optional |o| => o.elem, else => left_type }
            }
            return left_type
        }

        // Add: string/array/slice concat in @safe, pointer arithmetic, numeric
        if (op == @intFromEnum(Token.add)) {
            if (left_type == STRING and right_type == STRING) {
                if (self.safe_mode) { return STRING }
                self.reportError(idx, ErrorCode.e300, "'+' cannot concatenate strings; use '++'")
                return invalid_type
            }
            // Array + Array: @safe desugars to ++
            if (left_t.tag == TAG_ARRAY and right_t.tag == TAG_ARRAY) {
                const la = switch (left_t) { Type.array |a| => a, else => ArrayType { elem: invalid_type, length: 0 } }
                const ra = switch (right_t) { Type.array |a| => a, else => ArrayType { elem: invalid_type, length: 0 } }
                if (la.elem == ra.elem) {
                    if (self.safe_mode) { return self.types.makeArray(la.elem, la.length + ra.length) }
                    self.reportError(idx, ErrorCode.e300, "'+' cannot concatenate arrays; use '++'")
                    return invalid_type
                }
            }
            // Slice + Slice: @safe desugars to ++
            if (left_t.tag == TAG_SLICE and right_t.tag == TAG_SLICE) {
                const ls = switch (left_t) { Type.slice |s| => s, else => SliceType { elem: invalid_type } }
                const rs = switch (right_t) { Type.slice |s| => s, else => SliceType { elem: invalid_type } }
                if (ls.elem == rs.elem) {
                    if (self.safe_mode) { return left_type }
                    self.reportError(idx, ErrorCode.e300, "'+' cannot concatenate slices; use '++'")
                    return invalid_type
                }
            }
            // Pointer arithmetic: ptr + int or int + ptr
            if (left_t.tag == TAG_POINTER and self.isIntegerType(right_type)) { return left_type }
            if (self.isIntegerType(left_type) and right_t.tag == TAG_POINTER) { return right_type }
            if (!self.isNumericType(left_type) or !self.isNumericType(right_type)) {
                self.reportError(idx, ErrorCode.e300, "invalid operation")
                return invalid_type
            }
            return TypeRegistry.commonType(left_type, right_type)
        }

        // Sub: pointer arithmetic, numeric
        if (op == @intFromEnum(Token.sub)) {
            if (left_t.tag == TAG_POINTER and self.isIntegerType(right_type)) { return left_type }
            if (!self.isNumericType(left_type) or !self.isNumericType(right_type)) {
                self.reportError(idx, ErrorCode.e300, "invalid operation")
                return invalid_type
            }
            return TypeRegistry.commonType(left_type, right_type)
        }

        // Mul, Quo, Rem
        if (op == @intFromEnum(Token.mul) or op == @intFromEnum(Token.quo) or
            op == @intFromEnum(Token.rem)) {
            if (!self.isNumericType(left_type) or !self.isNumericType(right_type)) {
                self.reportError(idx, ErrorCode.e300, "invalid operation")
                return invalid_type
            }
            return TypeRegistry.commonType(left_type, right_type)
        }

        // Comparison operators → bool (with validation)
        if (op == @intFromEnum(Token.eql) or op == @intFromEnum(Token.neq) or
            op == @intFromEnum(Token.lss) or op == @intFromEnum(Token.leq) or
            op == @intFromEnum(Token.gtr) or op == @intFromEnum(Token.geq)) {
            if (!self.isComparable(left_type, right_type)) {
                self.reportError(idx, ErrorCode.e300, "invalid comparison")
                return invalid_type
            }
            return BOOL
        }

        // Logical AND/OR → bool (validate operands are bool)
        if (op == @intFromEnum(Token.kw_and) or op == @intFromEnum(Token.kw_or) or
            op == @intFromEnum(Token.land)) {
            if (!self.isBoolType(left_type) or !self.isBoolType(right_type)) {
                self.reportError(idx, ErrorCode.e300, "invalid operation")
                return invalid_type
            }
            return BOOL
        }

        // Logical OR (||): also handles error set merge
        if (op == @intFromEnum(Token.lor)) {
            // Error set merge: FileError || NetError
            if (left_t.tag == TAG_ERROR_SET and right_t.tag == TAG_ERROR_SET) {
                return self.mergeErrorSets(left_type, right_type)
            }
            // Bool logical OR
            if (self.isBoolType(left_type) and self.isBoolType(right_type)) { return BOOL }
            self.reportError(idx, ErrorCode.e300, "invalid operation")
            return invalid_type
        }

        // Bitwise (require integer operands)
        if (op == @intFromEnum(Token.@"and") or op == @intFromEnum(Token.@"or") or
            op == @intFromEnum(Token.xor) or op == @intFromEnum(Token.shl) or
            op == @intFromEnum(Token.shr)) {
            if (!self.isIntegerType(left_type) or !self.isIntegerType(right_type)) {
                self.reportError(idx, ErrorCode.e300, "invalid operation")
                return invalid_type
            }
            return TypeRegistry.commonType(left_type, right_type)
        }

        return invalid_type
    }

    fn checkUnary(idx: int) int {
        var op = 0
        var operand_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.unary |u| => { op = u.op; operand_n = u.operand }, else => {} }, else => {} }
        const operand_type = self.checkExpr(operand_n)

        if (op == @intFromEnum(Token.sub)) {
            if (!self.isNumericType(operand_type)) {
                self.reportError(idx, ErrorCode.e303, "unary '-' requires numeric operand")
                return invalid_type
            }
            return operand_type
        }
        if (op == @intFromEnum(Token.lnot) or op == @intFromEnum(Token.kw_not)) {
            if (!self.isBoolType(operand_type)) {
                self.reportError(idx, ErrorCode.e303, "unary '!' requires bool operand")
                return invalid_type
            }
            return BOOL
        }
        if (op == @intFromEnum(Token.@"not")) {
            if (!self.isIntegerType(operand_type)) {
                self.reportError(idx, ErrorCode.e303, "unary '~' requires integer operand")
                return invalid_type
            }
            return operand_type
        }
        // .? optional unwrap (period_question token)
        if (op == @intFromEnum(Token.period_question)) {
            const ot = self.types.get(operand_type)
            if (ot.tag == TAG_OPTIONAL) {
                return switch (ot) { Type.optional |o| => o.elem, else => invalid_type }
            }
            self.reportError(idx, ErrorCode.e303, "'.?' requires optional operand")
            return invalid_type
        }
        return invalid_type
    }

    fn checkCall(idx: int) int {
        var callee_n = null_node
        var call_args: List(int) = .{}
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.call |c| => { callee_n = c.callee; call_args = c.args }, else => {} }, else => {} }
        const args_count = call_args.count

        // Check for built-in function calls: print, println, etc.
        if (nodeTag(self.ast, callee_n) == "ident") {
            var name = ""
            switch (self.ast.getNode(callee_n)) { Node.expr |ce| => switch (ce) { Expr.ident |cid| => { name = cid.name }, else => {} }, else => {} }
            if (name == "print" or name == "println" or
                name == "eprint" or name == "eprintln") {
                // Check args but always returns void
                for ai in 0..args_count {
                    self.checkExpr(call_args.get(ai))
                }
                return VOID
            }
            if (name == "len") {
                if (args_count >= 1) {
                    self.checkExpr(call_args.get(0))
                }
                return INT
            }
            // Generic function instantiation: max(i64) where max is generic
            if (self.generic_functions.has(name) != 0) {
                return self.instantiateGenericFunc(idx, name)
            }
        }

        const callee_type = self.checkExpr(callee_n)

        // Resolve method call
        var func_type_idx = callee_type
        var is_method = false
        if (nodeTag(self.ast, callee_n) == "field_access") {
            const mi = self.resolveMethodFromFieldAccess(callee_n)
            if (mi >= 0) {
                const method_info = self.types.getMethodInfo(mi)
                func_type_idx = method_info.func_type
                is_method = true
            }
        }

        const ft = self.types.get(func_type_idx)
        if (ft.tag != TAG_FUNC) {
            // Not callable — might still work if it's a constructor etc.
            self.reportError(idx, ErrorCode.e305, "not callable")
            return invalid_type
        }

        const func_info = switch (ft) {
            Type.func |f| => f,
            else => FuncType { param_count: 0, params: 0, return_type: VOID },
        }

        // Check argument count (subtract self for instance methods)
        var expected = func_info.param_count
        if (is_method and expected > 0) {
            expected -= 1
        }
        if (args_count != expected) {
            self.reportError(idx, ErrorCode.e304, "wrong number of arguments")
            return func_info.return_type
        }

        // Check argument types (skip if param types unknown — fn ptr with params=0)
        if (func_info.params != 0) {
            const param_offset = if (is_method) { 1 } else { 0 }
            for ai in 0..args_count {
                // Zig Sema pattern: set expected_type from param type for result location inference
                const saved_expected = self.expected_type
                const param = func_info.getParam(ai + param_offset)
                self.expected_type = param.type_idx
                const arg_type = self.checkExpr(call_args.get(ai))
                self.expected_type = saved_expected
                if (!self.types.isAssignable(arg_type, param.type_idx)) {
                    // @safe coercion: Struct arg → *Struct param (safeWrapType wraps struct params)
                    const pt = self.types.get(param.type_idx)
                    var is_safe_struct = false
                    if (self.safe_mode and pt.tag == TAG_POINTER) {
                        const ptr_elem = switch (pt) { Type.pointer |p| => p.elem, else => invalid_type }
                        if (self.types.get(ptr_elem).tag == TAG_STRUCT and self.types.isAssignable(arg_type, ptr_elem)) {
                            is_safe_struct = true
                        }
                    }
                    // @safe reverse coercion: *Struct arg → Struct param (generic methods keep T as value)
                    const at = self.types.get(arg_type)
                    var is_safe_deref = false
                    if (self.safe_mode and at.tag == TAG_POINTER) {
                        const arg_elem = switch (at) { Type.pointer |p| => p.elem, else => invalid_type }
                        if (self.types.get(arg_elem).tag == TAG_STRUCT and self.types.isAssignable(arg_elem, param.type_idx)) {
                            is_safe_deref = true
                        }
                    }
                    if (!is_safe_struct and !is_safe_deref) {
                        self.reportError(idx, ErrorCode.e300, "type mismatch")
                    }
                }
            }
        } else {
            // Function pointer with unknown param types: just check arg expressions
            for ai in 0..args_count {
                self.checkExpr(call_args.get(ai))
            }
        }

        return func_info.return_type
    }

    fn resolveMethodFromFieldAccess(callee_idx: int) int {
        var base_n = null_node
        var field_name = ""
        switch (self.ast.getNode(callee_idx)) { Node.expr |e| => switch (e) { Expr.field_access |fa| => { base_n = fa.base; field_name = fa.field }, else => {} }, else => {} }

        if (self.expr_types.has(base_n) == 0) { return -1 }
        var base_type = self.expr_types.get(base_n)

        // Auto-deref pointers
        while (self.types.get(base_type).tag == TAG_POINTER) {
            base_type = switch (self.types.get(base_type)) { Type.pointer |p| => p.elem, else => base_type }
        }

        const type_name = self.types.typeName(base_type)
        if (type_name == "unknown") { return -1 }
        return self.types.lookupMethod(type_name, field_name)
    }

    fn checkIndex(idx: int) int {
        var base_n = null_node
        var idx_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.index_expr |ie| => { base_n = ie.base; idx_n = ie.idx }, else => {} }, else => {} }
        var base_type = self.checkExpr(base_n)
        self.checkExpr(idx_n)

        // Auto-deref
        while (self.types.get(base_type).tag == TAG_POINTER) {
            base_type = switch (self.types.get(base_type)) { Type.pointer |p| => p.elem, else => base_type }
        }

        if (base_type == STRING) { return U8 }
        const bt = self.types.get(base_type)
        if (bt.tag == TAG_ARRAY) { return switch (bt) { Type.array |a| => a.elem, else => invalid_type } }
        if (bt.tag == TAG_SLICE) { return switch (bt) { Type.slice |s| => s.elem, else => invalid_type } }
        if (bt.tag == TAG_LIST) { return switch (bt) { Type.list_type |l| => l.elem, else => invalid_type } }

        self.reportError(idx, ErrorCode.e303, "cannot index this type")
        return invalid_type
    }

    fn checkSliceExpr(idx: int) int {
        var base_n = null_node
        var start_n = null_node
        var end_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.slice_expr |se| => { base_n = se.base; start_n = se.start; end_n = se.end }, else => {} }, else => {} }
        var base_type = self.checkExpr(base_n)
        if (start_n != null_node) { self.checkExpr(start_n) }
        if (end_n != null_node) { self.checkExpr(end_n) }

        if (base_type == STRING) { return STRING }
        const bt = self.types.get(base_type)
        if (bt.tag == TAG_ARRAY) {
            return self.types.makeSlice(switch (bt) { Type.array |a| => a.elem, else => invalid_type })
        }
        if (bt.tag == TAG_SLICE) { return base_type }
        self.reportError(idx, ErrorCode.e303, "cannot slice this type")
        return invalid_type
    }

    fn checkFieldAccess(idx: int) int {
        var base_n = null_node
        var field_name = ""
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.field_access |fa| => { base_n = fa.base; field_name = fa.field }, else => {} }, else => {} }

        // Zig Sema pattern: .variant shorthand in switch — resolve from switch subject type
        if (base_n == null_node) {
            if (self.current_switch_enum_type != invalid_type) {
                const enum_info = self.types.get(self.current_switch_enum_type)
                if (enum_info.tag == TAG_ENUM) {
                    const et = switch (enum_info) { Type.enum_type |e| => e, else => EnumType { name: "", variant_count: 0, variants: 0, backing_type: 0 } }
                    for vi in 0..et.variant_count {
                        const ev = et.getVariant(vi)
                        if (ev.name == field_name) {
                            return self.current_switch_enum_type
                        }
                    }
                    const sw_suggestion = self.findSimilarVariant(field_name, self.current_switch_enum_type)
                    if (sw_suggestion) |ss| {
                        self.reportError(idx, ErrorCode.e306, "undefined variant '${field_name}', did you mean '${ss}'?")
                    } else {
                        self.reportError(idx, ErrorCode.e306, "undefined variant")
                    }
                }
            }
            return invalid_type
        }

        // Nested type namespace: TypeName.Nested
        if (nodeTag(self.ast, base_n) == "ident") {
            var base_name = ""
            switch (self.ast.getNode(base_n)) { Node.expr |be| => switch (be) { Expr.ident |bid| => { base_name = bid.name }, else => {} }, else => {} }
            const qualified = "${base_name}_${field_name}"

            // Check named types
            const nested_type = self.types.lookupByName(qualified)
            if (nested_type >= 0) { return nested_type }

            // Check scope for associated constants and static methods
            const sym_idx = self.lookupSymbol(qualified)
            if (sym_idx >= 0) {
                const sym = self.getSymbol(sym_idx)
                if (sym.is_func) {
                    // Store base type in expr_types for method call resolution
                    const base_type_idx = self.types.lookupByName(base_name)
                    if (base_type_idx >= 0) {
                        self.expr_types.set(base_n, base_type_idx)
                    }
                    return sym.type_idx
                }
                if (sym.type_idx != invalid_type) { return sym.type_idx }
            }
        }

        var base_type = self.checkExpr(base_n)

        // Auto-deref pointers
        while (self.types.get(base_type).tag == TAG_POINTER) {
            base_type = switch (self.types.get(base_type)) { Type.pointer |p| => p.elem, else => base_type }
        }

        const base = self.types.get(base_type)

        // Struct field access
        if (base.tag == TAG_STRUCT) {
            const st = switch (base) { Type.struct_type |s| => s, else => StructType { name: "", field_count: 0, fields: 0, size: 0, alignment: 0, layout: 0 } }
            // Search fields
            for fi in 0..st.field_count {
                const sf = st.getField(fi)
                if (sf.name == field_name) {
                    return sf.type_idx
                }
            }
            // Check methods
            const mi = self.types.lookupMethod(st.name, field_name)
            if (mi >= 0) {
                return self.types.getMethodInfo(mi).func_type
            }
            // "did you mean" for fields (Zig ref: checker.zig:3838-3897)
            const field_suggestion = self.findSimilarField(field_name, base_type)
            if (field_suggestion) |fs| {
                self.reportError(idx, ErrorCode.e306, "no field '${field_name}', did you mean '${fs}'?")
            } else {
                self.reportError(idx, ErrorCode.e306, "field not found")
            }
            return invalid_type
        }

        // Enum variant access
        if (base.tag == TAG_ENUM) {
            const et = switch (base) { Type.enum_type |e| => e, else => EnumType { name: "", variant_count: 0, variants: 0, backing_type: 0 } }
            for vi in 0..et.variant_count {
                const ev = et.getVariant(vi)
                if (ev.name == field_name) {
                    return base_type
                }
            }
            // Check methods
            const mi = self.types.lookupMethod(et.name, field_name)
            if (mi >= 0) {
                return self.types.getMethodInfo(mi).func_type
            }
            const variant_suggestion = self.findSimilarVariant(field_name, base_type)
            if (variant_suggestion) |vs| {
                self.reportError(idx, ErrorCode.e306, "no variant '${field_name}', did you mean '${vs}'?")
            } else {
                self.reportError(idx, ErrorCode.e306, "field not found")
            }
            return invalid_type
        }

        // Union variant access
        if (base.tag == TAG_UNION) {
            const ut = switch (base) { Type.union_type |u| => u, else => UnionType { name: "", variant_count: 0, variants: 0, tag_type: 0 } }
            if (field_name == "tag") { return I64 }
            // Check if base is a type name (constructor) vs value (extraction)
            var is_type_access = false
            if (nodeTag(self.ast, base_n) == "ident") {
                var ident_name = ""
                switch (self.ast.getNode(base_n)) { Node.expr |be| => switch (be) { Expr.ident |bid| => { ident_name = bid.name }, else => {} }, else => {} }
                const sym_idx = self.lookupSymbol(ident_name)
                if (sym_idx >= 0) {
                    if (self.getSymbol(sym_idx).is_type) {
                        is_type_access = true
                    }
                }
            }
            for vi in 0..ut.variant_count {
                const uv = ut.getVariant(vi)
                if (uv.name == field_name) {
                    if (uv.payload_type == invalid_type) { return base_type }
                    if (!is_type_access) {
                        // Payload extraction: r.Ok returns the payload type
                        return uv.payload_type
                    }
                    // Constructor: Result.Ok returns function type (payload → union)
                    const ctor_params = alloc(0, @sizeOf(FuncParam))
                    const fp = @intToPtr(*FuncParam, ctor_params)
                    fp.name = "payload"
                    fp.type_idx = uv.payload_type
                    return self.types.add(Type.func(FuncType {
                        param_count: 1,
                        params: ctor_params,
                        return_type: base_type,
                    }))
                }
            }
            const union_suggestion = self.findSimilarVariant(field_name, base_type)
            if (union_suggestion) |us| {
                self.reportError(idx, ErrorCode.e306, "no variant '${field_name}', did you mean '${us}'?")
            } else {
                self.reportError(idx, ErrorCode.e306, "field not found")
            }
            return invalid_type
        }

        // Slice fields: .ptr, .len (Zig ref: checker.zig:2395-2437)
        if (base.tag == TAG_SLICE or base_type == STRING) {
            if (field_name == "len") { return I64 }
            if (field_name == "ptr") {
                if (base.tag == TAG_SLICE) {
                    const sl = switch (base) { Type.slice |s| => s, else => SliceType { elem: invalid_type } }
                    return self.types.makePointer(sl.elem)
                }
                return self.types.makePointer(U8)  // string ptr → *u8
            }
            // String methods
            if (base_type == STRING) {
                const mi = self.types.lookupMethod("string", field_name)
                if (mi >= 0) {
                    return self.types.getMethodInfo(mi).func_type
                }
            }
        }

        // Map methods — return proper func types (Zig ref: checker.zig:2395-2437)
        if (base.tag == TAG_MAP) {
            const mt = switch (base) { Type.map_type |m| => m, else => CotMapType { key: 0, value: 0 } }
            if (field_name == "get") {
                var params: List(FuncParam) = .{}
                params.append(FuncParam { name: "key", type_idx: mt.key })
                return self.types.makeFunc(params, mt.value)
            }
            if (field_name == "set") {
                var params: List(FuncParam) = .{}
                params.append(FuncParam { name: "key", type_idx: mt.key })
                params.append(FuncParam { name: "value", type_idx: mt.value })
                return self.types.makeFunc(params, VOID)
            }
            if (field_name == "has") {
                var params: List(FuncParam) = .{}
                params.append(FuncParam { name: "key", type_idx: mt.key })
                return self.types.makeFunc(params, BOOL)
            }
            if (field_name == "count") { return I64 }
            if (field_name == "capacity") { return I64 }
        }
        // List methods — return proper func types
        if (base.tag == TAG_LIST) {
            const lt = switch (base) { Type.list_type |l| => l, else => CotListType { elem: 0 } }
            if (field_name == "get") {
                var params: List(FuncParam) = .{}
                params.append(FuncParam { name: "index", type_idx: I64 })
                return self.types.makeFunc(params, lt.elem)
            }
            if (field_name == "append") {
                var params: List(FuncParam) = .{}
                params.append(FuncParam { name: "value", type_idx: lt.elem })
                return self.types.makeFunc(params, VOID)
            }
            if (field_name == "len" or field_name == "count") { return I64 }
        }

        self.reportError(idx, ErrorCode.e306, "field not found")
        return invalid_type
    }

    // .{} zero-init: infer type from expected context (Zig pattern).
    // Without this, `var x: MyStruct = .{}` would fail because zero_init
    // returned VOID, which doesn't match the type annotation.
    fn checkZeroInit() int {
        if (self.expected_type != invalid_type) { return self.expected_type }
        return VOID
    }

    fn checkStructInit(idx: int) int {
        var type_name = ""
        var si_fields: List(int) = .{}
        var si_type_args: List(int) = .{}
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.struct_init |si| => { type_name = si.type_name; si_fields = si.fields; si_type_args = si.type_args }, else => {} }, else => {} }
        const fi_count = si_fields.count

        // Check for type arguments (generic struct init)
        const ta_count = si_type_args.count
        if (ta_count > 0) {
            const struct_type_idx = self.resolveGenericStructInit(idx, type_name, fi_count, ta_count, si_type_args)
            self.validateStructFields(idx, struct_type_idx, si_fields)
            return struct_type_idx
        }

        // Anonymous struct literal: resolve from expected_type
        if (@lenOf(type_name) == 0) {
            if (self.expected_type != invalid_type and self.types.get(self.expected_type).tag == TAG_STRUCT) {
                self.validateStructFields(idx, self.expected_type, si_fields)
                return self.expected_type
            }
            self.reportError(idx, ErrorCode.e300, "cannot infer type for anonymous struct literal")
            return invalid_type
        }

        const struct_type_idx = self.types.lookupByName(type_name)
        if (struct_type_idx < 0) {
            self.reportError(idx, ErrorCode.e301, "undefined type")
            return invalid_type
        }
        const st = self.types.get(struct_type_idx)
        if (st.tag != TAG_STRUCT) {
            self.reportError(idx, ErrorCode.e300, "not a struct type")
            return invalid_type
        }

        self.validateStructFields(idx, struct_type_idx, si_fields)
        return struct_type_idx
    }

    /// Validate field initializers against struct type definition.
    /// Port from Zig checker lines 2467-2489.
    fn validateStructFields(idx: int, struct_type_idx: int, fields: List(int)) void {
        const st_t = self.types.get(struct_type_idx)
        if (st_t.tag != TAG_STRUCT) { return }
        const st = switch (st_t) { Type.struct_type |s| => s, else => StructType { name: "", field_count: 0, fields: 0, size: 0, alignment: 0, layout: 0 } }
        const fi_count = fields.count

        // Check each field initializer: name exists and value type matches
        for fi in 0..fi_count {
            const fi_idx = fields.get(fi)
            var fname = ""
            var value_n = null_node
            switch (self.ast.getNode(fi_idx)) { Node.expr |e| => switch (e) { Expr.field_init_node |fin| => { fname = fin.name; value_n = fin.value }, else => {} }, else => {} }
            const val_type = self.checkExpr(value_n)

            var found = false
            for si in 0..st.field_count {
                const sf = st.getField(si)
                if (sf.name == fname) {
                    found = true
                    if (!self.types.isAssignable(val_type, sf.type_idx)) {
                        // @safe coercion: *Struct → Struct in field init
                        var is_safe_deref = false
                        if (self.safe_mode) {
                            const vt = self.types.get(val_type)
                            if (vt.tag == TAG_POINTER) {
                                const ptr_elem = switch (vt) { Type.pointer |p| => p.elem, else => invalid_type }
                                if (self.types.isAssignable(ptr_elem, sf.type_idx)) {
                                    is_safe_deref = true
                                }
                            }
                        }
                        if (!is_safe_deref) {
                            self.reportError(fi_idx, ErrorCode.e300, "type mismatch in field")
                        }
                    }
                }
            }
            if (!found) {
                self.reportError(fi_idx, ErrorCode.e306, "unknown field")
            }
        }

        // Check that all required fields (no default) are provided
        for si in 0..st.field_count {
            const sf = st.getField(si)
            if (sf.default_value != null_node) { continue }  // has default, ok to omit
            var provided = false
            for fi in 0..fi_count {
                const fi_idx = fields.get(fi)
                var fname = ""
                switch (self.ast.getNode(fi_idx)) { Node.expr |e| => switch (e) { Expr.field_init_node |fin| => { fname = fin.name }, else => {} }, else => {} }
                if (sf.name == fname) {
                    provided = true
                }
            }
            if (!provided) {
                self.reportError(idx, ErrorCode.e300, "missing field in struct init")
            }
        }
    }

    fn checkNewExpr(idx: int) int {
        var type_name = ""
        var ne_fields: List(int) = .{}
        var ne_type_args: List(int) = .{}
        var ne_ctor_args: List(int) = .{}
        var is_ctor = false
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.new_expr |ne| => { type_name = ne.type_name; ne_fields = ne.fields; ne_type_args = ne.type_args; ne_ctor_args = ne.constructor_args; is_ctor = ne.is_constructor }, else => {} }, else => {} }
        const fi_count = ne_fields.count
        const ta_count = ne_type_args.count

        // Check for type arguments (generic new expr)
        if (ta_count > 0) {
            const struct_type_idx = self.resolveGenericNewExpr(idx, type_name, fi_count, ta_count, ne_type_args)
            self.validateStructFields(idx, struct_type_idx, ne_fields)
            return self.types.makePointer(struct_type_idx)
        }

        const struct_type_idx = self.types.lookupByName(type_name)
        if (struct_type_idx < 0) {
            self.reportError(idx, ErrorCode.e301, "undefined type")
            return invalid_type
        }
        const st = self.types.get(struct_type_idx)
        if (st.tag != TAG_STRUCT) {
            self.reportError(idx, ErrorCode.e300, "new requires a struct type")
            return invalid_type
        }

        // Constructor sugar: new Point(10, 20) calls init()
        // Zig ref: checker.zig:2548-2570
        if (is_ctor) {
            const ca_count = ne_ctor_args.count
            // Check arg expressions first
            var arg_types: List(int) = .{}
            for ci in 0..ca_count {
                arg_types.append(self.checkExpr(ne_ctor_args.get(ci)))
            }
            // Validate against init method
            const init_mi = self.types.lookupMethod(type_name, "init")
            if (init_mi >= 0) {
                const init_info = self.types.getMethodInfo(init_mi)
                const init_ft = self.types.get(init_info.func_type)
                if (init_ft.tag == TAG_FUNC) {
                    const ft = switch (init_ft) { Type.func |f| => f, else => FuncType { param_count: 0, params: 0, return_type: VOID } }
                    // param_count includes self, so expected args = param_count - 1
                    const expected_args = ft.param_count - 1
                    if (ca_count != expected_args) {
                        self.reportError(idx, ErrorCode.e300, "init() expects ${expected_args} arguments, got ${ca_count}")
                    }
                }
            }
            return self.types.makePointer(struct_type_idx)
        }

        // Validate field initializers
        self.validateStructFields(idx, struct_type_idx, ne_fields)

        // Return pointer to struct (heap-allocated)
        return self.types.makePointer(struct_type_idx)
    }

    fn checkArrayLiteral(idx: int) int {
        var al_elements: List(int) = .{}
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.array_literal |al| => { al_elements = al.elements }, else => {} }, else => {} }
        const count = al_elements.count
        if (count == 0) {
            self.reportError(idx, ErrorCode.e300, "cannot infer type of empty array")
            return invalid_type
        }
        const first_type = self.checkExpr(al_elements.get(0))
        for i in 1..count {
            self.checkExpr(al_elements.get(i))
        }
        return self.types.makeArray(first_type, count)
    }

    fn checkTupleLiteral(idx: int) int {
        var tl_elements: List(int) = .{}
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.tuple_literal |tl| => { tl_elements = tl.elements }, else => {} }, else => {} }
        const count = tl_elements.count
        if (count < 2) {
            self.reportError(idx, ErrorCode.e300, "tuple requires at least 2 elements")
            return invalid_type
        }
        // Collect element types for proper tuple type (Zig ref: checker.zig:2585-2594)
        var elem_types: List(int) = .{}
        for i in 0..count {
            const et = self.checkExpr(tl_elements.get(i))
            elem_types.append(self.materializeType(et))
        }
        return self.types.makeTuple(elem_types)
    }

    fn checkIfExpr(idx: int) int {
        var cond_n = null_node
        var then_n = null_node
        var else_n = null_node
        var capture = ""
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.if_expr |ie| => { cond_n = ie.condition; then_n = ie.then_branch; else_n = ie.else_branch; capture = ie.capture }, else => {} }, else => {} }

        const cond_type = self.checkExpr(cond_n)

        // Optional capture
        if (@lenOf(capture) > 0) {
            const cond_t = self.types.get(cond_type)
            if (cond_t.tag == TAG_OPTIONAL) {
                const elem_type = switch (cond_t) { Type.optional |o| => o.elem, else => invalid_type }
                self.pushScope()
                self.defineSymbol(makeSymbol(capture, elem_type, null_node, false))
                const then_type = self.checkExpr(then_n)
                self.popScope()
                if (else_n != null_node) { self.checkExpr(else_n) }
                return then_type
            }
        }

        // Comptime dead branch elimination
        const cv = self.evalConstExpr(cond_n)
        if (cv.0 != 0) {
            if (cv.1 != 0) { return self.checkExpr(then_n) }
            if (else_n != null_node) { return self.checkExpr(else_n) }
            return VOID
        }

        const then_type = self.checkExpr(then_n)
        if (else_n != null_node) {
            self.checkExpr(else_n)
        }
        return then_type
    }

    fn checkSwitchExpr(idx: int) int {
        var subject_n = null_node
        var sw_cases: List(int) = .{}
        var else_body_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.switch_expr |sw| => { subject_n = sw.subject; sw_cases = sw.cases; else_body_n = sw.else_body }, else => {} }, else => {} }
        const cases_count = sw_cases.count

        const subject_type = self.checkExpr(subject_n)
        const subject_t = self.types.get(subject_type)
        const is_union = subject_t.tag == TAG_UNION
        const is_enum = subject_t.tag == TAG_ENUM

        // Set current enum type for .variant shorthand resolution
        const old_switch_enum = self.current_switch_enum_type
        if (is_enum) {
            self.current_switch_enum_type = subject_type
        }

        // Zig result location: use expected_type so untyped literals materialize correctly
        var result_type: int = if (self.expected_type != invalid_type) { self.expected_type } else { VOID }
        var first = self.expected_type != invalid_type  // skip first-arm inference if expected type known

        for ci in 0..cases_count {
            const case_idx = sw_cases.get(ci)
            var sc_patterns: List(int) = .{}
            var sc_body = null_node
            var capture = ""
            var guard_n = null_node
            switch (self.ast.getNode(case_idx)) { Node.expr |ce| => switch (ce) { Expr.switch_case_node |sc| => { sc_patterns = sc.patterns; sc_body = sc.body; capture = sc.capture; guard_n = sc.guard }, else => {} }, else => {} }
            const patterns_count = sc_patterns.count
            const body_n = sc_body

            // Check pattern expressions
            for pi in 0..patterns_count {
                self.checkExpr(sc_patterns.get(pi))
            }

            // Check guard expression (must be boolean)
            if (guard_n != null_node) {
                self.checkExpr(guard_n)
            }

            // If union switch with capture, define capture variable in a new scope
            if (is_union and @lenOf(capture) > 0) {
                const payload_type = self.resolveUnionCaptureType(subject_type, case_idx, patterns_count)
                self.pushScope()
                self.defineSymbol(makeSymbol(capture, payload_type, null_node, false))
                const body_type = self.checkExpr(body_n)
                self.popScope()
                if (!first) {
                    result_type = self.materializeType(body_type)
                    first = true
                }
            } else {
                const body_type = self.checkExpr(body_n)
                if (!first) {
                    result_type = self.materializeType(body_type)
                    first = true
                }
            }
        }
        if (else_body_n != null_node) {
            self.checkExpr(else_body_n)
        }

        // Enum switch exhaustiveness check (Zig pattern: must be exhaustive or have else)
        // Port from Zig checker lines 2666-2698.
        if (is_enum and else_body_n == null_node) {
            const et = switch (subject_t) { Type.enum_type |e| => e, else => EnumType { name: "", variant_count: 0, variants: 0, backing_type: 0 } }
            // Build coverage set: track which variants are covered by unguarded cases.
            // Use a parallel list of variant names (Map would be cleaner but we track by name).
            var covered: List(string) = .{}
            for ci in 0..cases_count {
                const case_idx = sw_cases.get(ci)
                var ex_patterns: List(int) = .{}
                var ex_guard = null_node
                switch (self.ast.getNode(case_idx)) { Node.expr |ce| => switch (ce) { Expr.switch_case_node |sc| => { ex_patterns = sc.patterns; ex_guard = sc.guard }, else => {} }, else => {} }
                if (ex_guard != null_node) { continue }  // guarded cases don't guarantee coverage
                const pat_count = ex_patterns.count
                for pi in 0..pat_count {
                    const pat_idx = ex_patterns.get(pi)
                    if (nodeTag(self.ast, pat_idx) == "field_access") {
                        var variant_name = ""
                        switch (self.ast.getNode(pat_idx)) { Node.expr |pe| => switch (pe) { Expr.field_access |fa| => { variant_name = fa.field }, else => {} }, else => {} }
                        // Dedup: only add if not already covered
                        var already_covered = false
                        for ci2 in 0..covered.count {
                            if (covered.get(ci2) == variant_name) {
                                already_covered = true
                            }
                        }
                        if (!already_covered) {
                            covered.append(variant_name)
                        }
                    }
                }
            }
            if (covered.count < et.variant_count) {
                // List missing variant names (Zig ref: checker.zig:2695-2714)
                var missing: List(string) = .{}
                for vi in 0..et.variant_count {
                    const ev = et.getVariant(vi)
                    var is_covered = false
                    for ci2 in 0..covered.count {
                        if (covered.get(ci2) == ev.name) { is_covered = true }
                    }
                    if (!is_covered) { missing.append(ev.name) }
                }
                if (missing.count > 0) {
                    var msg = "non-exhaustive switch, missing: "
                    for mi in 0..missing.count {
                        if (mi > 0) { msg = "${msg}, " }
                        msg = "${msg}.${missing.get(mi)}"
                    }
                    self.reportError(idx, ErrorCode.e300, msg)
                } else {
                    self.reportError(idx, ErrorCode.e300, "non-exhaustive enum switch requires else branch")
                }
            }
        }

        self.current_switch_enum_type = old_switch_enum
        return result_type
    }

    /// Resolve the payload type for a union switch case capture from its patterns.
    /// Port from Zig checker lines 2704-2718.
    fn resolveUnionCaptureType(subject_type: int, case_idx: int, patterns_count: int) int {
        if (patterns_count == 0) { return VOID }
        const subject_t = self.types.get(subject_type)
        if (subject_t.tag != TAG_UNION) { return VOID }
        const ut = switch (subject_t) { Type.union_type |u| => u, else => UnionType { name: "", variant_count: 0, variants: 0, tag_type: 0 } }

        // Use first pattern to determine the variant
        var uc_patterns: List(int) = .{}
        switch (self.ast.getNode(case_idx)) { Node.expr |ce| => switch (ce) { Expr.switch_case_node |sc| => { uc_patterns = sc.patterns }, else => {} }, else => {} }
        if (uc_patterns.count == 0) { return VOID }
        const pat_idx = uc_patterns.get(0)
        if (nodeTag(self.ast, pat_idx) != "field_access") { return VOID }
        var field_name = ""
        switch (self.ast.getNode(pat_idx)) { Node.expr |pe| => switch (pe) { Expr.field_access |fa| => { field_name = fa.field }, else => {} }, else => {} }
        for vi in 0..ut.variant_count {
            const uv = ut.getVariant(vi)
            if (uv.name == field_name) {
                return uv.payload_type
            }
        }
        return VOID
    }

    fn checkBlockExpr(idx: int) int {
        var blk_stmts: List(int) = .{}
        var result_expr = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.block_expr |blk| => { blk_stmts = blk.stmts; result_expr = blk.result_expr }, else => {} }, else => {} }
        const stmts_count = blk_stmts.count

        self.pushScope()
        for i in 0..stmts_count {
            self.checkStmt(blk_stmts.get(i))
        }
        var result: int = VOID
        if (result_expr != null_node) {
            result = self.checkExpr(result_expr)
        }
        self.popScope()
        return result
    }

    /// Port from Zig checker.zig:1830-2204 — per-builtin type validation.
    /// Check a builtin call. Split into sub-functions to avoid
    /// stack frame overflow with many switch arms.
    /// Type-check a builtin call expression.
    /// Port of Zig checker.zig checkBuiltinCall — single switch on bc.kind.
    fn checkBuiltinCall(idx: int) int {
        // Extract the BuiltinCallExpr from the node
        var bc_kind = 0
        var type_arg = null_node
        var args: List(int) = .{}
        switch (self.ast.getNode(idx)) {
            Node.expr |e| => switch (e) {
                Expr.builtin_call |bc| => {
                    bc_kind = bc.kind
                    type_arg = bc.type_arg
                    args = bc.args
                },
                else => {},
            },
            else => {},
        }
        const kind = @as(BuiltinKind, @enumFromInt(bc_kind))
        const argc = args.count

        // --- Type introspection ---

        if (kind == BuiltinKind.size_of or kind == BuiltinKind.align_of) {
            const ti = self.resolveTypeArg(type_arg)
            if (ti == invalid_type) {
                self.reportError(idx, ErrorCode.e300, "requires valid type")
                return invalid_type
            }
            return I64
        }
        if (kind == BuiltinKind.enum_len) {
            const ti = self.resolveTypeArg(type_arg)
            if (ti == invalid_type) {
                self.reportError(idx, ErrorCode.e300, "@enumLen requires valid type")
                return invalid_type
            }
            if (self.types.get(ti).tag != TAG_ENUM) {
                self.reportError(idx, ErrorCode.e300, "@enumLen requires enum type")
                return invalid_type
            }
            return I64
        }
        if (kind == BuiltinKind.has_field) {
            const ti = self.resolveTypeArg(type_arg)
            if (ti == invalid_type) {
                self.reportError(idx, ErrorCode.e300, "@hasField requires valid type")
                return invalid_type
            }
            if (argc >= 1) {
                self.checkExpr(args.get(0))
                if (!self.isStringLiteral(args.get(0))) {
                    self.reportError(idx, ErrorCode.e300, "@hasField requires string literal field name")
                    return invalid_type
                }
            }
            return BOOL
        }
        if (kind == BuiltinKind.type_of) {
            if (argc >= 1) {
                return self.checkExpr(args.get(0))
            }
            return invalid_type
        }
        if (kind == BuiltinKind.field) {
            return self.checkBuiltinField(idx, args, argc)
        }
        if (kind == BuiltinKind.offset_of) {
            return self.checkBuiltinOffsetOf(idx, type_arg, args, argc)
        }

        // --- Comptime reflection ---

        if (kind == BuiltinKind.type_name) {
            const ti = self.resolveTypeArg(type_arg)
            if (ti == invalid_type) {
                self.reportError(idx, ErrorCode.e300, "@typeName requires valid type")
                return invalid_type
            }
            return STRING
        }
        if (kind == BuiltinKind.enum_name) {
            const ti = self.resolveTypeArg(type_arg)
            if (ti == invalid_type) {
                self.reportError(idx, ErrorCode.e300, "@enumName requires valid type")
                return invalid_type
            }
            if (self.types.get(ti).tag != TAG_ENUM) {
                self.reportError(idx, ErrorCode.e300, "@enumName requires enum type")
                return invalid_type
            }
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return STRING
        }
        if (kind == BuiltinKind.type_info) {
            const ti = self.resolveTypeArg(type_arg)
            if (ti == invalid_type) {
                self.reportError(idx, ErrorCode.e300, "@typeInfo requires valid type")
                return invalid_type
            }
            return I64
        }

        // --- Math unary ---

        if (kind == BuiltinKind.abs or kind == BuiltinKind.ceil or kind == BuiltinKind.floor
            or kind == BuiltinKind.trunc or kind == BuiltinKind.round or kind == BuiltinKind.sqrt) {
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                if (!self.isFloatType(at)) {
                    self.reportError(idx, ErrorCode.e300, "math builtin requires float argument")
                    return invalid_type
                }
            }
            return F64
        }

        // --- Math binary ---

        if (kind == BuiltinKind.fmin or kind == BuiltinKind.fmax) {
            var a1_float = false
            var a2_float = false
            if (argc >= 1) {
                a1_float = self.isFloatType(self.checkExpr(args.get(0)))
            }
            if (argc >= 2) {
                a2_float = self.isFloatType(self.checkExpr(args.get(1)))
            }
            if (!a1_float or !a2_float) {
                self.reportError(idx, ErrorCode.e300, "@fmin/@fmax require float arguments")
                return invalid_type
            }
            return F64
        }
        if (kind == BuiltinKind.min or kind == BuiltinKind.max) {
            var a_type: int = I64
            var b_type: int = I64
            if (argc >= 1) {
                a_type = self.checkExpr(args.get(0))
            }
            if (argc >= 2) {
                b_type = self.checkExpr(args.get(1))
            }
            if (!self.isNumericType(a_type) or !self.isNumericType(b_type)) {
                self.reportError(idx, ErrorCode.e300, "@min/@max requires numeric types")
                return invalid_type
            }
            return TypeRegistry.commonType(a_type, b_type)
        }

        // --- Casts ---

        if (kind == BuiltinKind.int_cast) {
            const tt = self.resolveTypeArg(type_arg)
            if (!self.isIntegerType(tt)) {
                self.reportError(idx, ErrorCode.e300, "@intCast target must be integer type")
                return invalid_type
            }
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return tt
        }
        if (kind == BuiltinKind.float_cast) {
            const tt = self.resolveTypeArg(type_arg)
            if (!self.isFloatType(tt)) {
                self.reportError(idx, ErrorCode.e300, "@floatCast target must be float type")
                return invalid_type
            }
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return tt
        }
        if (kind == BuiltinKind.float_from_int) {
            const tt = self.resolveTypeArg(type_arg)
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return tt
        }
        if (kind == BuiltinKind.int_from_float) {
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                if (!self.isFloatType(at)) {
                    self.reportError(idx, ErrorCode.e300, "@intFromFloat operand must be a float type")
                }
            }
            return I64
        }
        if (kind == BuiltinKind.ptr_cast) {
            const tt = self.resolveTypeArg(type_arg)
            if (self.types.get(tt).tag != TAG_POINTER) {
                self.reportError(idx, ErrorCode.e300, "@ptrCast target must be pointer")
                return invalid_type
            }
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return tt
        }
        if (kind == BuiltinKind.int_to_ptr) {
            const tt = self.resolveTypeArg(type_arg)
            if (self.types.get(tt).tag != TAG_POINTER) {
                self.reportError(idx, ErrorCode.e300, "@intToPtr target must be pointer")
                return invalid_type
            }
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return tt
        }
        if (kind == BuiltinKind.ptr_to_int) {
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                const ai = self.types.get(at)
                if (ai.tag != TAG_POINTER and at != I64) {
                    self.reportError(idx, ErrorCode.e300, "@ptrToInt operand must be a pointer")
                    return invalid_type
                }
            }
            return I64
        }
        if (kind == BuiltinKind.bit_cast) {
            const tt = self.resolveTypeArg(type_arg)
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                const ti = self.types.get(tt)
                const ai = self.types.get(at)
                if (ti.tag == TAG_POINTER or ti.tag == TAG_ENUM) {
                    self.reportError(idx, ErrorCode.e300, "@bitCast target cannot be pointer or enum type")
                    return invalid_type
                }
                if (ai.tag == TAG_POINTER or ai.tag == TAG_ENUM) {
                    self.reportError(idx, ErrorCode.e300, "@bitCast source cannot be pointer or enum type")
                    return invalid_type
                }
                if (self.types.sizeOf(tt) != self.types.sizeOf(at)) {
                    self.reportError(idx, ErrorCode.e300, "@bitCast requires same-size types")
                    return invalid_type
                }
            }
            return tt
        }
        if (kind == BuiltinKind.truncate) {
            const tt = self.resolveTypeArg(type_arg)
            if (!self.isIntegerType(tt)) {
                self.reportError(idx, ErrorCode.e300, "@truncate target must be integer type")
                return invalid_type
            }
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return tt
        }
        if (kind == BuiltinKind.@"as") {
            const tt = self.resolveTypeArg(type_arg)
            // Propagate expected type to inner expression (enables 1-arg @enumFromInt)
            const saved = self.expected_type
            self.expected_type = tt
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            self.expected_type = saved
            return tt
        }
        if (kind == BuiltinKind.align_cast) {
            if (type_arg != null_node) {
                self.resolveTypeExpr(type_arg)
            }
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return I64
        }
        if (kind == BuiltinKind.const_cast) {
            if (argc >= 1) {
                return self.checkExpr(args.get(0))
            }
            return invalid_type
        }

        // --- Enum/error/bool conversions ---

        if (kind == BuiltinKind.int_from_enum) {
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                if (self.types.get(at).tag != TAG_ENUM) {
                    self.reportError(idx, ErrorCode.e300, "@intFromEnum requires enum argument")
                    return invalid_type
                }
            }
            return I64
        }
        if (kind == BuiltinKind.enum_from_int) {
            var tt = invalid_type
            if (type_arg != null_node) {
                tt = self.resolveTypeExpr(type_arg)
            } else if (self.expected_type != invalid_type) {
                tt = self.expected_type
            } else {
                self.reportError(idx, ErrorCode.e300, "@enumFromInt requires type argument or type context")
                return invalid_type
            }
            if (self.types.get(tt).tag != TAG_ENUM) {
                self.reportError(idx, ErrorCode.e300, "@enumFromInt target must be enum type")
                return invalid_type
            }
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return tt
        }
        if (kind == BuiltinKind.tag_name) {
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                const ai = self.types.get(at)
                if (ai.tag != TAG_ENUM and ai.tag != TAG_UNION) {
                    self.reportError(idx, ErrorCode.e300, "@tagName requires enum or union argument")
                    return invalid_type
                }
            }
            return STRING
        }
        if (kind == BuiltinKind.error_name) {
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                const ai = self.types.get(at)
                if (ai.tag != TAG_ERROR_SET and ai.tag != TAG_ERROR_UNION) {
                    self.reportError(idx, ErrorCode.e300, "@errorName operand must be error type")
                    return invalid_type
                }
            }
            return STRING
        }
        if (kind == BuiltinKind.int_from_bool) {
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                if (at != BOOL and at != UNTYPED_BOOL) {
                    self.reportError(idx, ErrorCode.e300, "@intFromBool requires bool argument")
                    return invalid_type
                }
            }
            return I64
        }

        // --- String construction + decomposition ---

        if (kind == BuiltinKind.@"string") {
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            if (argc >= 2) {
                self.checkExpr(args.get(1))
            }
            return STRING
        }
        if (kind == BuiltinKind.ptr_of) {
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                if (at != STRING) {
                    self.reportError(idx, ErrorCode.e300, "@ptrOf requires string argument")
                    return invalid_type
                }
            }
            return I64
        }
        if (kind == BuiltinKind.len_of) {
            if (argc >= 1) {
                const at = self.checkExpr(args.get(0))
                if (at != STRING) {
                    self.reportError(idx, ErrorCode.e300, "@lenOf requires string argument")
                    return invalid_type
                }
            }
            return I64
        }

        // --- Bit manipulation ---

        if (kind == BuiltinKind.ctz or kind == BuiltinKind.clz or kind == BuiltinKind.pop_count) {
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return I64
        }

        // --- Assertions ---

        if (kind == BuiltinKind.assert) {
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return VOID
        }
        if (kind == BuiltinKind.assert_eq) {
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            if (argc >= 2) {
                self.checkExpr(args.get(1))
            }
            return VOID
        }

        // --- Control ---

        if (kind == BuiltinKind.trap) {
            return NORETURN
        }
        if (kind == BuiltinKind.panic) {
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return NORETURN
        }

        // --- Comptime ---

        if (kind == BuiltinKind.compile_error) {
            var msg = "compile error"
            if (argc >= 1) {
                switch (self.ast.getNode(args.get(0))) {
                    Node.expr |ae| => switch (ae) {
                        Expr.literal |lit| => {
                            if (lit.kind == @intFromEnum(LiteralKind.@"string")) {
                                msg = lit.value
                            }
                        },
                        else => {},
                    },
                    else => {},
                }
            }
            self.reportError(idx, ErrorCode.e300, msg)
            return NORETURN
        }
        if (kind == BuiltinKind.embed_file) {
            if (argc >= 1) {
                if (!self.isStringLiteral(args.get(0))) {
                    self.reportError(idx, ErrorCode.e300, "@embedFile requires a string literal path")
                }
            }
            return STRING
        }
        if (kind == BuiltinKind.target_os or kind == BuiltinKind.target_arch or kind == BuiltinKind.target) {
            return STRING
        }

        // --- ARC management ---

        if (kind == BuiltinKind.arc_retain or kind == BuiltinKind.arc_release) {
            if (argc >= 1) {
                self.checkExpr(args.get(0))
            }
            return VOID
        }

        // Default: check all args, return invalid
        for ai in 0..argc {
            self.checkExpr(args.get(ai))
        }
        return invalid_type
    }

    /// Helper: resolve a type argument node, returning invalid_type if null_node.
    fn resolveTypeArg(type_arg: int) int {
        if (type_arg != null_node) {
            return self.resolveTypeExpr(type_arg)
        }
        return invalid_type
    }

    /// Helper: check if a node is a string literal.
    fn isStringLiteral(node_idx: int) bool {
        switch (self.ast.getNode(node_idx)) {
            Node.expr |ae| => switch (ae) {
                Expr.literal |lit| => {
                    return lit.kind == @intFromEnum(LiteralKind.@"string")
                },
                else => { return false },
            },
            else => { return false },
        }
    }

    /// @field(value, "name") — comptime field access. Zig Sema.zig:26769.
    fn checkBuiltinField(idx: int, args: List(int), argc: int) int {
        if (argc < 2) {
            self.reportError(idx, ErrorCode.e300, "@field requires two arguments")
            return invalid_type
        }
        var base_type = self.checkExpr(args.get(0))
        // Auto-deref pointers (Zig pattern)
        while (self.types.get(base_type).tag == TAG_POINTER) {
            base_type = self.types.pointerElem(base_type)
        }
        self.checkExpr(args.get(1))
        const info = self.types.get(base_type)
        if (info.tag != TAG_STRUCT) {
            self.reportError(idx, ErrorCode.e300, "@field requires struct type")
            return invalid_type
        }
        // Get field name from string literal
        var field_name = ""
        var is_str = false
        switch (self.ast.getNode(args.get(1))) {
            Node.expr |ae| => switch (ae) {
                Expr.literal |lit| => {
                    if (lit.kind == @intFromEnum(LiteralKind.@"string")) {
                        field_name = lit.value
                        is_str = true
                    }
                },
                else => {},
            },
            else => {},
        }
        if (!is_str) {
            self.reportError(idx, ErrorCode.e300, "@field requires string literal field name")
            return invalid_type
        }
        const st = switch (info) {
            Type.struct_type |s| => s,
            else => StructType { name: "", field_count: 0, fields: 0, size: 0, alignment: 0, layout: 0 },
        }
        for fi in 0..st.field_count {
            const sf = st.getField(fi)
            if (sf.name == field_name) {
                return sf.type_idx
            }
        }
        self.reportError(idx, ErrorCode.e300, "struct has no field with this name")
        return invalid_type
    }

    /// @offsetOf(T, "field") — comptime struct field offset. Zig Sema.zig:23060.
    fn checkBuiltinOffsetOf(idx: int, type_arg: int, args: List(int), argc: int) int {
        const ti = self.resolveTypeArg(type_arg)
        const info = self.types.get(ti)
        if (info.tag != TAG_STRUCT) {
            self.reportError(idx, ErrorCode.e300, "@offsetOf requires struct type")
            return invalid_type
        }
        if (argc < 1) {
            self.reportError(idx, ErrorCode.e300, "@offsetOf requires field name argument")
            return invalid_type
        }
        self.checkExpr(args.get(0))
        // Get field name from string literal
        var field_name = ""
        var is_str = false
        switch (self.ast.getNode(args.get(0))) {
            Node.expr |ae| => switch (ae) {
                Expr.literal |lit| => {
                    if (lit.kind == @intFromEnum(LiteralKind.@"string")) {
                        field_name = lit.value
                        is_str = true
                    }
                },
                else => {},
            },
            else => {},
        }
        if (!is_str) {
            self.reportError(idx, ErrorCode.e300, "@offsetOf requires string literal field name")
            return invalid_type
        }
        const st = switch (info) {
            Type.struct_type |s| => s,
            else => StructType { name: "", field_count: 0, fields: 0, size: 0, alignment: 0, layout: 0 },
        }
        var found = false
        for fi in 0..st.field_count {
            const sf = st.getField(fi)
            if (sf.name == field_name) {
                found = true
            }
        }
        if (!found) {
            self.reportError(idx, ErrorCode.e300, "struct has no field with this name")
            return invalid_type
        }
        return I64
    }

    fn checkStringInterp(idx: int) int {
        var si_segments: List(int) = .{}
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.string_interp |si| => { si_segments = si.segments }, else => {} }, else => {} }
        const count = si_segments.count
        for i in 0..count {
            self.checkExpr(si_segments.get(i))
        }
        return STRING
    }

    fn checkTryExpr(idx: int) int {
        var try_operand = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.try_expr |te| => { try_operand = te.operand }, else => {} }, else => {} }
        const operand_type = self.checkExpr(try_operand)
        const ot = self.types.get(operand_type)
        if (ot.tag == TAG_ERROR_UNION) {
            return switch (ot) { Type.error_union |eu| => eu.elem, else => invalid_type }
        }
        self.reportError(idx, ErrorCode.e300, "try requires error union type")
        return invalid_type
    }

    /// Check an await expression. Validates operand is Future(T), returns T.
    /// Zig ref: checker.zig:2781-2792
    fn checkAwaitExpr(idx: int) int {
        var operand_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.await_expr |ae| => { operand_n = ae.operand }, else => {} }, else => {} }
        const operand_type = self.checkExpr(operand_n)
        const ot = self.types.get(operand_type)
        if (ot.tag == TAG_FUTURE) {
            return switch (ot) { Type.future |f| => f.result_type, else => invalid_type }
        }
        self.reportError(idx, ErrorCode.e300, "await requires Future type")
        return invalid_type
    }

    fn checkCatchExpr(idx: int) int {
        var operand_n = null_node
        var capture = ""
        var fallback_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.catch_expr |ce| => { operand_n = ce.operand; capture = ce.capture; fallback_n = ce.fallback }, else => {} }, else => {} }

        const operand_type = self.checkExpr(operand_n)
        const ot = self.types.get(operand_type)
        if (ot.tag != TAG_ERROR_UNION) {
            self.reportError(idx, ErrorCode.e300, "catch requires error union type")
            return self.checkExpr(fallback_n)
        }
        const elem_type = switch (ot) { Type.error_union |eu| => eu.elem, else => invalid_type }

        if (@lenOf(capture) > 0) {
            // Catch capture: catch |err| — bind err to error set type (Zig checker.zig:2793)
            const eu = switch (ot) { Type.error_union |eu| => eu, else => ErrorUnionType { elem: invalid_type, error_set: invalid_type } }
            const err_type = if (eu.error_set != invalid_type) { eu.error_set } else { I64 }
            self.pushScope()
            self.defineSymbol(makeSymbol(capture, err_type, null_node, false))
            self.checkExpr(fallback_n)
            self.popScope()
        } else {
            self.checkExpr(fallback_n)
        }
        return elem_type
    }

    fn checkAddrOf(idx: int) int {
        var ao_operand = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.addr_of |ao| => { ao_operand = ao.operand }, else => {} }, else => {} }
        const operand_type = self.checkExpr(ao_operand)
        return self.types.makePointer(operand_type)
    }

    fn checkDeref(idx: int) int {
        var dr_operand = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.deref |dr| => { dr_operand = dr.operand }, else => {} }, else => {} }
        const operand_type = self.checkExpr(dr_operand)
        if (self.types.isPointer(operand_type)) {
            return self.types.pointerElem(operand_type)
        }
        self.reportError(idx, ErrorCode.e300, "cannot dereference non-pointer")
        return invalid_type
    }

    fn checkClosureExpr(idx: int) int {
        var cl_params: List(int) = .{}
        var ret_type_n = null_node
        var body_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.closure_expr |cl| => { cl_params = cl.params; ret_type_n = cl.return_type; body_n = cl.body }, else => {} }, else => {} }
        const params_count = cl_params.count

        // Build function type from closure signature
        const params_ptr = alloc(0, params_count * @sizeOf(FuncParam))
        for pi in 0..params_count {
            const param_idx = cl_params.get(pi)
            var pname = ""
            var ptype: int = invalid_type
            if (nodeTag(self.ast, param_idx) == "field_def") {
                var ptype_n = null_node
                switch (self.ast.getNode(param_idx)) { Node.expr |pe| => switch (pe) { Expr.field_def |fd| => { pname = fd.name; ptype_n = fd.type_expr }, else => {} }, else => {} }
                ptype = self.resolveTypeExpr(ptype_n)
                ptype = self.safeWrapType(ptype)
            }
            const fp = @intToPtr(*FuncParam, params_ptr + pi * @sizeOf(FuncParam))
            fp.name = pname
            fp.type_idx = ptype
        }

        var ret_type: int = VOID
        if (ret_type_n != null_node) {
            ret_type = self.resolveTypeExpr(ret_type_n)
        }

        const func_type = self.types.add(Type.func(FuncType {
            param_count: params_count,
            params: params_ptr,
            return_type: ret_type,
        }))

        // Check body in a child scope with params defined
        // Reuse already-resolved param types from the func type (avoid double resolution)
        if (body_n != null_node) {
            self.pushScope()
            const old_ret = self.current_return_type
            self.current_return_type = ret_type
            for pi in 0..params_count {
                const fp = @intToPtr(*FuncParam, params_ptr + pi * @sizeOf(FuncParam))
                if (@lenOf(fp.name) > 0) {
                    self.defineSymbol(makeSymbol(fp.name, fp.type_idx, idx, false))
                }
            }
            self.checkBlockBody(body_n)
            self.current_return_type = old_ret
            self.popScope()
        }

        return func_type
    }

    // ---- Type resolution ----

    fn resolveTypeExpr(idx: int) int {
        if (idx == null_node) { return invalid_type }
        const tag = nodeTag(self.ast, idx)

        // @TypeOf in type position (Zig ref: checker.zig:3284-3289)
        if (tag == "builtin_call") {
            var bk = 0
            var barg = null_node
            switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.builtin_call |bc| => { bk = bc.kind; barg = bc.type_arg }, else => {} }, else => {} }
            if (bk == @intFromEnum(BuiltinKind.type_of) and barg != null_node) {
                return self.checkExpr(barg)
            }
        }

        // Named type (ident node used in type position)
        if (tag == "ident") {
            var name = ""
            switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.ident |id| => { name = id.name }, else => {} }, else => {} }
            // Check type substitution first (active during generic instantiation)
            if (self.hasTypeSubstitution()) {
                const sub = self.lookupTypeSub(name)
                if (sub >= 0) { return sub }
            }
            const type_idx = self.types.lookupByName(name)
            if (type_idx >= 0) { return type_idx }
            // Check scope for type aliases
            const sym_idx = self.lookupSymbol(name)
            if (sym_idx >= 0) {
                const sym = self.getSymbol(sym_idx)
                if (sym.is_type) { return sym.type_idx }
            }
            self.reportError(idx, ErrorCode.e301, "undefined type")
            return invalid_type
        }

        // generic_instance: name + type_args
        if (tag == "generic_instance") {
            var gi_name = ""
            switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.generic_instance |gi| => { gi_name = gi.name }, else => {} }, else => {} }
            return self.resolveGenericInstance(idx, gi_name)
        }

        // tuple_type: (T1, T2, ...)
        if (tag == "tuple_type") {
            var elems: List(int) = .{}
            switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.tuple_type |tt| => {
                for i in 0..tt.elements.count {
                    elems.append(self.resolveTypeExpr(tt.elements.get(i)))
                }
            }, else => {} }, else => {} }
            return self.types.makeTuple(elems)
        }

        // type_expr node: kind, data1, data2
        if (tag != "type_expr") { return invalid_type }

        var kind = 0
        var d1 = null_node
        var d2 = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.type_expr |te| => { kind = te.kind; d1 = te.data1; d2 = te.data2 }, else => {} }, else => {} }

        if (kind == TYPE_NAMED) {
            // Named type: d1 is an ident node (or null_node for void)
            return self.resolveTypeExpr(d1)
        }
        if (kind == TYPE_POINTER) {
            return self.types.makePointer(self.resolveTypeExpr(d1))
        }
        if (kind == TYPE_OPTIONAL) {
            return self.types.makeOptional(self.resolveTypeExpr(d1))
        }
        if (kind == TYPE_ERROR_UNION) {
            return self.types.makeErrorUnion(self.resolveTypeExpr(d1))
        }
        if (kind == TYPE_SLICE) {
            return self.types.makeSlice(self.resolveTypeExpr(d1))
        }
        if (kind == TYPE_FUNCTION) {
            // fn(params...) -> RetType — d1 is ret_type_n, d2 is param_count
            // Parser stores param count but not individual param types.
            // We create a func type with correct count but null params pointer.
            var ret_type: int = VOID
            if (d1 != null_node) {
                ret_type = self.resolveTypeExpr(d1)
            }
            return self.types.add(Type.func(FuncType {
                param_count: d2,
                params: 0,
                return_type: ret_type,
            }))
        }
        if (kind == TYPE_ARRAY) {
            const elem = self.resolveTypeExpr(d1)
            // Evaluate array size
            var size: int = 0
            const cv = self.evalConstExpr(d2)
            if (cv.0 != 0 and cv.1 > 0) {
                size = cv.1
            } else {
                // Try literal
                if (nodeTag(self.ast, d2) == "literal") {
                    var lit_kind = 0
                    var lit_val = ""
                    switch (self.ast.getNode(d2)) { Node.expr |e| => switch (e) { Expr.literal |lit| => { lit_kind = lit.kind; lit_val = lit.value }, else => {} }, else => {} }
                    if (lit_kind == @intFromEnum(LiteralKind.@"int")) {
                        size = parseInt(lit_val)
                    }
                }
            }
            return self.types.makeArray(elem, size)
        }

        return invalid_type
    }

    // ---- Type building ----

    fn buildStructType(idx: int, name: string) int {
        var sd_fields: List(int) = .{}
        var sd_layout: int = 0
        switch (self.ast.getNode(idx)) { Node.decl |d| => switch (d) { Decl.struct_decl |sd| => { sd_fields = sd.fields; sd_layout = sd.layout }, else => {} }, else => {} }
        const fields_count = sd_fields.count
        var total_size: int = 0
        const is_packed = sd_layout == @intFromEnum(StructLayout.@"packed")
        const is_extern = sd_layout == @intFromEnum(StructLayout.@"extern")

        // Build struct fields using raw pointer array
        const fields_ptr = alloc(0, fields_count * @sizeOf(StructField))
        for fi in 0..fields_count {
            const field_idx = sd_fields.get(fi)
            var fname = ""
            var ftype_n = null_node
            var fdefault = null_node
            switch (self.ast.getNode(field_idx)) { Node.expr |e| => switch (e) { Expr.field_def |fd| => { fname = fd.name; ftype_n = fd.type_expr; fdefault = fd.default_value }, else => {} }, else => {} }
            const ftype = self.resolveTypeExpr(ftype_n)

            const sf = @intToPtr(*StructField, fields_ptr + fi * @sizeOf(StructField))
            sf.name = fname
            sf.type_idx = ftype
            sf.offset = total_size
            sf.default_value = fdefault

            const field_size = self.types.sizeOf(ftype)
            total_size += field_size
            // Packed: no alignment padding. Extern/Auto: align to 8 bytes (Zig ref: checker.zig:3633-3674)
            if (!is_packed) {
                total_size = (total_size + 7) / 8 * 8
            }
        }

        // Packed structs have alignment 1, extern/auto have 8
        const alignment = if (is_packed) { 1 } else { 8 }

        return self.types.add(Type.struct_type(StructType {
            name: name,
            field_count: fields_count,
            fields: fields_ptr,
            size: total_size,
            alignment: alignment,
            layout: sd_layout,
        }))
    }

    fn buildEnumType(idx: int) int {
        var ed_name = ""
        var ed_backing = null_node
        var ed_variants: List(int) = .{}
        switch (self.ast.getNode(idx)) { Node.decl |d| => switch (d) { Decl.enum_decl |ed| => { ed_name = ed.name; ed_backing = ed.backing_type; ed_variants = ed.variants }, else => {} }, else => {} }
        const name = ed_name
        const backing_n = ed_backing
        const variants_count = ed_variants.count

        var backing_type: int = I32
        if (backing_n != null_node) {
            backing_type = self.resolveTypeExpr(backing_n)
        }

        const variants_ptr = alloc(0, variants_count * @sizeOf(EnumVariant))
        var next_value: int = 0
        for vi in 0..variants_count {
            const v_idx = ed_variants.get(vi)
            var vname = ""
            var value_n = null_node
            switch (self.ast.getNode(v_idx)) { Node.expr |e| => switch (e) { Expr.enum_variant_node |ev| => { vname = ev.name; value_n = ev.value }, else => {} }, else => {} }

            var value = next_value
            if (value_n != null_node) {
                const cv = self.evalConstExpr(value_n)
                if (cv.0 != 0) { value = cv.1 }
            }

            const ev = @intToPtr(*EnumVariant, variants_ptr + vi * @sizeOf(EnumVariant))
            ev.name = vname
            ev.value = value
            next_value = value + 1
        }

        return self.types.add(Type.enum_type(EnumType {
            name: name,
            variant_count: variants_count,
            variants: variants_ptr,
            backing_type: backing_type,
        }))
    }

    fn buildUnionType(idx: int) int {
        var ud_name = ""
        var ud_variants: List(int) = .{}
        switch (self.ast.getNode(idx)) { Node.decl |d| => switch (d) { Decl.union_decl |ud| => { ud_name = ud.name; ud_variants = ud.variants }, else => {} }, else => {} }
        const name = ud_name
        const variants_count = ud_variants.count

        const variants_ptr = alloc(0, variants_count * @sizeOf(UnionVariant))
        for vi in 0..variants_count {
            const v_idx = ud_variants.get(vi)
            var vname = ""
            var vtype_n = null_node
            switch (self.ast.getNode(v_idx)) { Node.expr |e| => switch (e) { Expr.union_variant_node |uv| => { vname = uv.name; vtype_n = uv.type_expr }, else => {} }, else => {} }
            var payload_type: int = invalid_type
            if (vtype_n != null_node) {
                payload_type = self.resolveTypeExpr(vtype_n)
            }

            const uv = @intToPtr(*UnionVariant, variants_ptr + vi * @sizeOf(UnionVariant))
            uv.name = vname
            uv.payload_type = payload_type
        }

        const tag_type = if (variants_count <= 256) { U8 } else { U16 }
        return self.types.add(Type.union_type(UnionType {
            name: name,
            variant_count: variants_count,
            variants: variants_ptr,
            tag_type: tag_type,
        }))
    }

    fn safeWrapType(type_idx: int) int {
        if (!self.safe_mode) { return type_idx }
        const t = self.types.get(type_idx)
        if (t.tag == TAG_STRUCT) {
            return self.types.makePointer(type_idx)
        }
        if (t.tag == TAG_ERROR_UNION) {
            const eu = switch (t) { Type.error_union |e| => e, else => ErrorUnionType { elem: invalid_type, error_set: invalid_type } }
            const elem_t = self.types.get(eu.elem)
            if (elem_t.tag == TAG_STRUCT) {
                const wrapped = self.types.makePointer(eu.elem)
                return self.types.makeErrorUnionWithSet(wrapped, eu.error_set)
            }
        }
        return type_idx
    }

    // ---- Generic instantiation ----

    /// Build cache key for generic deduplication: "List(5)" or "Pair(5;17)"
    fn buildGenericCacheKey(name: string, type_args: List(int)) string {
        var result = "${name}("
        for i in 0..type_args.count {
            if (i > 0) {
                result = "${result};${type_args.get(i)}"
            } else {
                result = "${result}${type_args.get(i)}"
            }
        }
        return "${result})"
    }

    /// Resolve a generic struct instantiation: List(int) → concrete List(5) type.
    /// Port from Zig checker lines 3291-3355.
    /// Cross-file: swaps self.ast to defining file's AST (Zig: self.tree = gen_info.tree).
    fn resolveGenericInstance(idx: int, gi_name: string) int {
        // Look up generic struct definition
        if (self.generic_structs.has(gi_name) == 0) {
            self.reportError(idx, ErrorCode.e301, "undefined generic type")
            return invalid_type
        }
        const info = @intToPtr(*GenericInfo, self.generic_structs.get(gi_name))
        const struct_node = info.node_idx

        // Read type args from generic_instance AST (CURRENT file)
        var gi_type_args: List(int) = .{}
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.generic_instance |gi| => { gi_type_args = gi.type_args }, else => {} }, else => {} }
        const ta_count = gi_type_args.count

        // Resolve each type argument in caller's context (CURRENT file's AST)
        var resolved_args: List(int) = .{}
        for i in 0..ta_count {
            const arg_node = gi_type_args.get(i)
            const arg_type = self.resolveTypeExpr(arg_node)
            resolved_args.append(arg_type)
        }

        // Swap to defining file's AST and safe_mode (Zig lines 3328-3335)
        const saved_ast = self.ast
        const saved_safe_mode = self.safe_mode
        self.ast = info.getAst()
        self.safe_mode = self.ast.safe_mode

        // Read struct definition from DEFINING file's AST
        var s_fields: List(int) = .{}
        var s_tp: List(string) = .{}
        switch (self.ast.getNode(struct_node)) { Node.decl |d| => switch (d) { Decl.struct_decl |sd| => { s_fields = sd.fields; s_tp = sd.type_params }, else => {} }, else => {} }
        const s_fields_count = s_fields.count
        const tp_count = s_tp.count

        if (ta_count != tp_count) {
            self.ast = saved_ast
            self.safe_mode = saved_safe_mode
            self.reportError(idx, ErrorCode.e300, "wrong number of type arguments")
            return invalid_type
        }

        // Build cache key and check cache
        const cache_key = self.buildGenericCacheKey(gi_name, resolved_args)
        if (self.instantiation_cache.has(cache_key) != 0) {
            self.ast = saved_ast
            self.safe_mode = saved_safe_mode
            return self.instantiation_cache.get(cache_key)
        }

        // Set up type substitution: read param names from DEFINING file's AST
        const old_sub_count = self.type_sub_keys.count
        for i in 0..tp_count {
            const tp_name = s_tp.get(i)
            self.pushTypeSub(tp_name, resolved_args.get(i))
        }

        // Build concrete struct type with substituted fields (DEFINING file's AST)
        const concrete_type = self.buildStructType(struct_node, cache_key)

        // Restore substitution
        self.type_sub_keys.count = old_sub_count
        self.type_sub_vals.count = old_sub_count

        // Restore caller's AST and safe_mode
        self.ast = saved_ast
        self.safe_mode = saved_safe_mode

        // Register and cache
        self.types.registerNamed(cache_key, concrete_type)
        self.instantiation_cache.set(cache_key, concrete_type)

        // Instantiate generic impl block methods
        self.instantiateGenericImplMethods(gi_name, cache_key, resolved_args)

        return concrete_type
    }

    /// Instantiate all methods from generic impl blocks for a concrete struct type.
    /// Two-pass: register signatures, then check bodies (so sibling methods are visible).
    /// Port from Zig checker lines 3367-3452.
    /// Cross-file: swaps self.ast to defining file's AST for each impl entry.
    /// Also isolates expr_types to avoid NodeIndex collision (Zig lines 3433-3442).
    fn instantiateGenericImplMethods(base_name: string, concrete_name: string, resolved_args: List(int)) void {
        for ei in 0..self.generic_impl_entries.count {
            const entry = @intToPtr(*GenericImplEntry, self.generic_impl_entries.items + ei * @sizeOf(GenericImplEntry))
            if (entry.base_name != base_name) { continue }
            if (entry.tp_count != resolved_args.count) { continue }

            const impl_idx = entry.node_idx

            // Swap to defining file's AST and safe_mode (Zig lines 3379-3387)
            const saved_ast = self.ast
            const saved_safe_mode = self.safe_mode
            self.ast = entry.getAst()
            self.safe_mode = self.ast.safe_mode

            // Extract impl_block fields from DEFINING file's AST
            var impl_methods: List(int) = .{}
            var impl_tp: List(string) = .{}
            switch (self.ast.getNode(impl_idx)) { Node.decl |d| => switch (d) { Decl.impl_block |ib| => { impl_methods = ib.methods; impl_tp = ib.type_params }, else => {} }, else => {} }
            const methods_count = impl_methods.count

            // Cross-file expr_types isolation (Zig lines 3433-3442):
            // Foreign AST NodeIndexes collide with host file's NodeIndex space.
            // Save host expr_types, use fresh map, restore after.
            const is_cross_file = (entry.ast_ptr != @ptrToInt(saved_ast))
            var saved_expr_types = self.expr_types
            if (is_cross_file) {
                var fresh_et: Map(int, int) = .{}
                self.expr_types = fresh_et
            }

            // Set up type substitution from DEFINING file's AST
            const old_sub_count = self.type_sub_keys.count
            for i in 0..entry.tp_count {
                const tp_name = impl_tp.get(i)
                self.pushTypeSub(tp_name, resolved_args.get(i))
            }

            // Pass 1: Register all method signatures
            for mi in 0..methods_count {
                const method_idx = impl_methods.get(mi)
                if (nodeTag(self.ast, method_idx) != "fn_decl") { continue }

                var method_name = ""
                switch (self.ast.getNode(method_idx)) { Node.decl |md| => switch (md) { Decl.fn_decl |mf| => { method_name = mf.name }, else => {} }, else => {} }
                const synth_name = "${concrete_name}_${method_name}"
                const func_type = self.buildFuncType(method_idx)

                // Define in global scope
                const old_scope = self.current_scope
                self.current_scope = self.global_scope
                if (!self.isDefined(synth_name)) {
                    self.defineSymbol(makeFuncSymbol(synth_name, func_type, method_idx))
                }
                self.current_scope = old_scope

                // Register method
                self.types.registerMethod(concrete_name, MethodInfo {
                    name: method_name,
                    func_name: synth_name,
                    func_type: func_type,
                    receiver_is_ptr: true,
                    is_static: false,
                })
            }

            // Pass 2: Check all method bodies
            for mi in 0..methods_count {
                const method_idx = impl_methods.get(mi)
                if (nodeTag(self.ast, method_idx) != "fn_decl") { continue }

                var method_name2 = ""
                switch (self.ast.getNode(method_idx)) { Node.decl |md| => switch (md) { Decl.fn_decl |mf| => { method_name2 = mf.name }, else => {} }, else => {} }
                const synth_name = "${concrete_name}_${method_name2}"
                self.checkFnDeclBody(method_idx, synth_name)
            }

            // Restore substitution
            self.type_sub_keys.count = old_sub_count
            self.type_sub_vals.count = old_sub_count

            // Restore expr_types for cross-file
            if (is_cross_file) {
                self.expr_types = saved_expr_types
            }

            // Restore caller's AST and safe_mode
            self.ast = saved_ast
            self.safe_mode = saved_safe_mode
        }
    }

    /// Instantiate a generic function: max(i64) → concrete max(5) func.
    /// Port from Zig checker lines 3434-3540.
    /// Cross-file: swaps self.ast to defining file's AST.
    fn instantiateGenericFunc(idx: int, name: string) int {
        // Look up generic function definition
        const info = @intToPtr(*GenericInfo, self.generic_functions.get(name))
        const fn_node = info.node_idx

        // Read call args from CURRENT file's AST
        var call_args: List(int) = .{}
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.call |c| => { call_args = c.args }, else => {} }, else => {} }
        const call_args_count = call_args.count

        // Resolve each type argument from CURRENT file's AST
        var resolved_args: List(int) = .{}
        for i in 0..call_args_count {
            const arg_node = call_args.get(i)
            const arg_type = self.resolveTypeExpr(arg_node)
            if (arg_type == invalid_type) {
                // Try as identifier in type registry
                if (nodeTag(self.ast, arg_node) == "ident") {
                    var arg_name = ""
                    switch (self.ast.getNode(arg_node)) { Node.expr |ae| => switch (ae) { Expr.ident |aid| => { arg_name = aid.name }, else => {} }, else => {} }
                    const tidx = self.types.lookupByName(arg_name)
                    if (tidx >= 0) {
                        resolved_args.append(tidx)
                        continue
                    }
                }
                self.reportError(idx, ErrorCode.e300, "expected type argument")
                return invalid_type
            }
            resolved_args.append(arg_type)
        }

        // Swap to defining file's AST and safe_mode (Zig lines 3506-3513)
        const saved_ast = self.ast
        const saved_safe_mode = self.safe_mode
        self.ast = info.getAst()
        self.safe_mode = self.ast.safe_mode

        // Extract fn_decl fields from DEFINING file's AST
        var fn_params: List(int) = .{}
        var fn_tp: List(string) = .{}
        var fn_tp_bounds: List(string) = .{}
        switch (self.ast.getNode(fn_node)) { Node.decl |d| => switch (d) { Decl.fn_decl |fd| => { fn_params = fd.params; fn_tp = fd.type_params; fn_tp_bounds = fd.type_param_bounds }, else => {} }, else => {} }
        const params_count = fn_params.count
        const tp_count = fn_tp.count

        if (call_args_count != tp_count) {
            self.ast = saved_ast
            self.safe_mode = saved_safe_mode
            self.reportError(idx, ErrorCode.e300, "wrong number of type arguments")
            return invalid_type
        }

        // Validate trait bounds (Zig lines 3460-3474)
        const bounds_count = fn_tp_bounds.count
        if (bounds_count > 0) {
            for bi in 0..bounds_count {
                const bound_name = fn_tp_bounds.get(bi)
                if (@lenOf(bound_name) > 0) {
                    const type_name = self.types.typeName(resolved_args.get(bi))
                    const impl_key = "${bound_name}:${type_name}"
                    if (self.trait_impls.has(impl_key) == 0) {
                        self.ast = saved_ast
                        self.safe_mode = saved_safe_mode
                        self.reportError(idx, ErrorCode.e300, "type does not satisfy trait bound")
                        return invalid_type
                    }
                }
            }
        }

        // Build cache key
        const cache_key = self.buildGenericCacheKey(name, resolved_args)

        // Check if already instantiated — return cached func type
        const cached_sym = self.lookupSymbol(cache_key)
        if (cached_sym >= 0) {
            self.ast = saved_ast
            self.safe_mode = saved_safe_mode
            return self.getSymbol(cached_sym).type_idx
        }

        // Set up type substitution from DEFINING file's AST
        const old_sub_count = self.type_sub_keys.count
        for i in 0..tp_count {
            const tp_name = fn_tp.get(i)
            self.pushTypeSub(tp_name, resolved_args.get(i))
        }

        // Build concrete function type from DEFINING file's AST
        const func_type = self.buildFuncType(fn_node)

        // Define in global scope
        const old_scope = self.current_scope
        self.current_scope = self.global_scope
        if (!self.isDefined(cache_key)) {
            self.defineSymbol(makeFuncSymbol(cache_key, func_type, fn_node))
        }
        self.current_scope = old_scope

        // Check the function body (still using DEFINING file's AST)
        // Cross-file: save/restore expr_types to avoid NodeIndex collision (Zig lines 3539-3548)
        const is_cross_file = (info.ast_ptr != @ptrToInt(saved_ast))
        var saved_expr_types = self.expr_types
        if (is_cross_file) {
            var fresh_et: Map(int, int) = .{}
            self.expr_types = fresh_et
        }
        self.checkFnDeclBody(fn_node, cache_key)
        if (is_cross_file) {
            self.expr_types = saved_expr_types
        }

        // Restore substitution
        self.type_sub_keys.count = old_sub_count
        self.type_sub_vals.count = old_sub_count

        // Restore caller's AST and safe_mode
        self.ast = saved_ast
        self.safe_mode = saved_safe_mode

        return func_type
    }

    /// Resolve generic struct init: Pair(int, string) { .a = 1, .b = "hi" }
    /// Cross-file: swaps self.ast to defining file's AST.
    fn resolveGenericStructInit(idx: int, type_name: string, fi_count: int, ta_count: int, si_type_args: List(int)) int {
        if (self.generic_structs.has(type_name) == 0) {
            self.reportError(idx, ErrorCode.e301, "undefined generic type")
            return invalid_type
        }
        const info = @intToPtr(*GenericInfo, self.generic_structs.get(type_name))
        const struct_node = info.node_idx

        // Resolve type args from CURRENT file's AST (passed in si_type_args)
        var resolved_args: List(int) = .{}
        for i in 0..ta_count {
            const arg_node = si_type_args.get(i)
            const arg_type = self.resolveTypeExpr(arg_node)
            resolved_args.append(arg_type)
        }

        // Swap to defining file's AST and safe_mode (Zig pattern)
        const saved_ast = self.ast
        const saved_safe_mode = self.safe_mode
        self.ast = info.getAst()
        self.safe_mode = self.ast.safe_mode

        // Extract struct_decl fields from DEFINING file's AST
        var s_fields: List(int) = .{}
        var s_tp: List(string) = .{}
        switch (self.ast.getNode(struct_node)) { Node.decl |d| => switch (d) { Decl.struct_decl |sd| => { s_fields = sd.fields; s_tp = sd.type_params }, else => {} }, else => {} }
        const s_fields_count = s_fields.count
        const tp_count = s_tp.count

        if (ta_count != tp_count) {
            self.ast = saved_ast
            self.safe_mode = saved_safe_mode
            self.reportError(idx, ErrorCode.e300, "wrong number of type arguments")
            return invalid_type
        }

        const cache_key = self.buildGenericCacheKey(type_name, resolved_args)
        if (self.instantiation_cache.has(cache_key) != 0) {
            self.ast = saved_ast
            self.safe_mode = saved_safe_mode
            return self.instantiation_cache.get(cache_key)
        }

        // Set up substitution from DEFINING file's AST
        const old_sub_count = self.type_sub_keys.count
        for i in 0..tp_count {
            const tp_name = s_tp.get(i)
            self.pushTypeSub(tp_name, resolved_args.get(i))
        }

        const concrete_type = self.buildStructType(struct_node, cache_key)
        self.type_sub_keys.count = old_sub_count
        self.type_sub_vals.count = old_sub_count

        // Restore caller's AST and safe_mode
        self.ast = saved_ast
        self.safe_mode = saved_safe_mode

        self.types.registerNamed(cache_key, concrete_type)
        self.instantiation_cache.set(cache_key, concrete_type)
        self.instantiateGenericImplMethods(type_name, cache_key, resolved_args)

        return concrete_type
    }

    /// Resolve generic new expr: new Pair(int, string) { a: 1, b: "hi" }
    /// Cross-file: swaps self.ast to defining file's AST.
    fn resolveGenericNewExpr(idx: int, type_name: string, fi_count: int, ta_count: int, ne_type_args: List(int)) int {
        if (self.generic_structs.has(type_name) == 0) {
            self.reportError(idx, ErrorCode.e301, "undefined generic type")
            return invalid_type
        }
        const info = @intToPtr(*GenericInfo, self.generic_structs.get(type_name))
        const struct_node = info.node_idx

        // Resolve type args from CURRENT file's AST (passed in ne_type_args)
        var resolved_args: List(int) = .{}
        for i in 0..ta_count {
            const arg_node = ne_type_args.get(i)
            const arg_type = self.resolveTypeExpr(arg_node)
            resolved_args.append(arg_type)
        }

        // Swap to defining file's AST and safe_mode (Zig pattern)
        const saved_ast = self.ast
        const saved_safe_mode = self.safe_mode
        self.ast = info.getAst()
        self.safe_mode = self.ast.safe_mode

        // Extract struct_decl fields from DEFINING file's AST
        var s_fields_ne: List(int) = .{}
        var s_tp_ne: List(string) = .{}
        switch (self.ast.getNode(struct_node)) { Node.decl |d| => switch (d) { Decl.struct_decl |sd| => { s_fields_ne = sd.fields; s_tp_ne = sd.type_params }, else => {} }, else => {} }
        const s_fields_count = s_fields_ne.count
        const tp_count = s_tp_ne.count

        if (ta_count != tp_count) {
            self.ast = saved_ast
            self.safe_mode = saved_safe_mode
            self.reportError(idx, ErrorCode.e300, "wrong number of type arguments")
            return invalid_type
        }

        const cache_key = self.buildGenericCacheKey(type_name, resolved_args)
        if (self.instantiation_cache.has(cache_key) != 0) {
            self.ast = saved_ast
            self.safe_mode = saved_safe_mode
            return self.instantiation_cache.get(cache_key)
        }

        // Set up substitution from DEFINING file's AST
        const old_sub_count = self.type_sub_keys.count
        for i in 0..tp_count {
            const tp_name = s_tp_ne.get(i)
            self.pushTypeSub(tp_name, resolved_args.get(i))
        }

        const concrete_type = self.buildStructType(struct_node, cache_key)
        self.type_sub_keys.count = old_sub_count
        self.type_sub_vals.count = old_sub_count

        // Restore caller's AST and safe_mode
        self.ast = saved_ast
        self.safe_mode = saved_safe_mode

        self.types.registerNamed(cache_key, concrete_type)
        self.instantiation_cache.set(cache_key, concrete_type)
        self.instantiateGenericImplMethods(type_name, cache_key, resolved_args)

        return concrete_type
    }

    fn buildFuncType(idx: int) int {
        var fn_params: List(int) = .{}
        var ret_type_n = null_node
        switch (self.ast.getNode(idx)) { Node.decl |d| => switch (d) { Decl.fn_decl |fd| => { fn_params = fd.params; ret_type_n = fd.return_type }, else => {} }, else => {} }
        const params_count = fn_params.count

        const params_ptr = alloc(0, params_count * @sizeOf(FuncParam))
        for pi in 0..params_count {
            const param_idx = fn_params.get(pi)
            var pname = ""
            var ptype: int = invalid_type
            if (nodeTag(self.ast, param_idx) == "field_def") {
                var ptype_n = null_node
                switch (self.ast.getNode(param_idx)) { Node.expr |pe| => switch (pe) { Expr.field_def |fd| => { pname = fd.name; ptype_n = fd.type_expr }, else => {} }, else => {} }
                ptype = self.resolveTypeExpr(ptype_n)
                // Don't auto-ref parameters whose type is a generic type parameter.
                // Generic functions are written with value semantics for T; wrapping T
                // to *T when T=struct would break body code.
                // Type params can appear as either .ident or .type_expr(.named)
                var is_substituted = false
                if (self.hasTypeSubstitution() and ptype_n != null_node) {
                    const ptype_tag = nodeTag(self.ast, ptype_n)
                    if (ptype_tag == "ident") {
                        var ptype_name = ""
                        switch (self.ast.getNode(ptype_n)) { Node.expr |pe2| => switch (pe2) { Expr.ident |pid| => { ptype_name = pid.name }, else => {} }, else => {} }
                        if (self.lookupTypeSub(ptype_name) >= 0) {
                            is_substituted = true
                        }
                    } else if (ptype_tag == "type_expr") {
                        var te_kind = 0
                        var te_d1 = null_node
                        switch (self.ast.getNode(ptype_n)) { Node.expr |pe3| => switch (pe3) { Expr.type_expr |te| => { te_kind = te.kind; te_d1 = te.data1 }, else => {} }, else => {} }
                        if (te_kind == TYPE_NAMED) {
                            const inner_n = te_d1
                            if (inner_n != null_node and nodeTag(self.ast, inner_n) == "ident") {
                                var inner_name = ""
                                switch (self.ast.getNode(inner_n)) { Node.expr |pe4| => switch (pe4) { Expr.ident |iid| => { inner_name = iid.name }, else => {} }, else => {} }
                                if (self.lookupTypeSub(inner_name) >= 0) {
                                    is_substituted = true
                                }
                            }
                        }
                    }
                }
                if (!is_substituted) {
                    ptype = self.safeWrapType(ptype)
                }
            }

            const fp = @intToPtr(*FuncParam, params_ptr + pi * @sizeOf(FuncParam))
            fp.name = pname
            fp.type_idx = ptype
        }

        var ret_type: int = VOID
        if (ret_type_n != null_node) {
            ret_type = self.resolveTypeExpr(ret_type_n)
        }

        return self.types.add(Type.func(FuncType {
            param_count: params_count,
            params: params_ptr,
            return_type: ret_type,
        }))
    }

    // ---- Const evaluation ----

    /// Evaluate a constant expression. Split into sub-functions to avoid
    /// large stack frames with many union temporaries.
    fn evalConstExpr(idx: int) (int, int) {
        if (idx == null_node) { return (0, 0) }
        const tag = nodeTag(self.ast, idx)
        if (tag == "literal") { return self.evalConstLiteral(idx) }
        if (tag == "unary") { return self.evalConstUnary(idx) }
        if (tag == "binary") { return self.evalConstBinary(idx) }
        if (tag == "paren") { return self.evalConstParen(idx) }
        if (tag == "ident") { return self.evalConstIdent(idx) }
        if (tag == "builtin_call") { return self.evalConstBuiltin(idx) }
        if (tag == "field_access") { return self.evalConstFieldAccess(idx) }
        if (tag == "if_expr") { return self.evalConstIfExpr(idx) }
        if (tag == "comptime_block") { return self.evalConstComptimeBlock(idx) }
        if (tag == "block_expr") { return self.evalConstBlockExpr(idx) }
        return (0, 0)
    }

    fn evalConstLiteral(idx: int) (int, int) {
        var kind = 0
        var val_str = ""
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.literal |lit| => { kind = lit.kind; val_str = lit.value }, else => {} }, else => {} }
        if (kind == @intFromEnum(LiteralKind.@"int")) { return (1, parseInt(val_str)) }
        if (kind == @intFromEnum(LiteralKind.true_lit)) { return (1, 1) }
        if (kind == @intFromEnum(LiteralKind.false_lit)) { return (1, 0) }
        return (0, 0)
    }

    fn evalConstUnary(idx: int) (int, int) {
        var op = 0
        var operand_idx = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.unary |u| => { op = u.op; operand_idx = u.operand }, else => {} }, else => {} }
        const inner = self.evalConstExpr(operand_idx)
        if (inner.0 == 0) { return (0, 0) }
        if (op == @intFromEnum(Token.sub)) { return (1, 0 - inner.1) }
        if (op == @intFromEnum(Token.lnot)) { return (1, if (inner.1 == 0) { 1 } else { 0 }) }
        // Bitwise not (Zig ref: checker.zig:742)
        if (op == @intFromEnum(Token.@"not")) { return (1, ~inner.1) }
        return (0, 0)
    }

    fn evalConstBinary(idx: int) (int, int) {
        var op = 0
        var left_n = null_node
        var right_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.binary |bin| => { op = bin.op; left_n = bin.left; right_n = bin.right }, else => {} }, else => {} }
        const lv = self.evalConstExpr(left_n)
        const rv = self.evalConstExpr(right_n)
        if (lv.0 == 0 or rv.0 == 0) {
            // String equality comparison (Zig ref: checker.zig:782-793)
            if (op == @intFromEnum(Token.eql) or op == @intFromEnum(Token.neq)) {
                const ls = self.evalConstString(left_n)
                const rs = self.evalConstString(right_n)
                if (ls.0 != 0 and rs.0 != 0) {
                    const eq = if (ls.1 == rs.1) { 1 } else { 0 }
                    if (op == @intFromEnum(Token.eql)) { return (1, eq) }
                    return (1, if (eq == 1) { 0 } else { 1 })
                }
            }
            return (0, 0)
        }
        const l = lv.1
        const r = rv.1
        if (op == @intFromEnum(Token.add)) { return (1, l + r) }
        if (op == @intFromEnum(Token.sub)) { return (1, l - r) }
        if (op == @intFromEnum(Token.mul)) { return (1, l * r) }
        if (op == @intFromEnum(Token.quo) and r != 0) { return (1, l / r) }
        if (op == @intFromEnum(Token.rem) and r != 0) { return (1, l % r) }
        if (op == @intFromEnum(Token.eql)) { return (1, if (l == r) { 1 } else { 0 }) }
        if (op == @intFromEnum(Token.neq)) { return (1, if (l != r) { 1 } else { 0 }) }
        if (op == @intFromEnum(Token.lss)) { return (1, if (l < r) { 1 } else { 0 }) }
        if (op == @intFromEnum(Token.leq)) { return (1, if (l <= r) { 1 } else { 0 }) }
        if (op == @intFromEnum(Token.gtr)) { return (1, if (l > r) { 1 } else { 0 }) }
        if (op == @intFromEnum(Token.geq)) { return (1, if (l >= r) { 1 } else { 0 }) }
        // Bitwise operators (Zig ref: checker.zig:765-769)
        if (op == @intFromEnum(Token.@"and")) { return (1, l & r) }
        if (op == @intFromEnum(Token.@"or")) { return (1, l | r) }
        if (op == @intFromEnum(Token.xor)) { return (1, l ^ r) }
        if (op == @intFromEnum(Token.shl)) { return (1, l << r) }
        if (op == @intFromEnum(Token.shr)) { return (1, l >> r) }
        return (0, 0)
    }

    fn evalConstParen(idx: int) (int, int) {
        var inner_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.paren |p| => { inner_n = p.inner }, else => {} }, else => {} }
        return self.evalConstExpr(inner_n)
    }

    fn evalConstIdent(idx: int) (int, int) {
        var name = ""
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.ident |id| => { name = id.name }, else => {} }, else => {} }
        // Check comptime mutable vars first
        if (self.in_comptime and self.comptime_vars.has(name) != 0) {
            return (1, self.comptime_vars.get(name))
        }
        const sym_idx = self.lookupSymbol(name)
        if (sym_idx >= 0) {
            const sym = self.getSymbol(sym_idx)
            if (sym.is_const_val) {
                return (1, sym.const_value)
            }
        }
        return (0, 0)
    }

    fn evalConstBuiltin(idx: int) (int, int) {
        var bk = 0
        var type_arg_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.builtin_call |bc| => { bk = bc.kind; type_arg_n = bc.type_arg }, else => {} }, else => {} }
        if (bk == @intFromEnum(BuiltinKind.size_of) and type_arg_n != null_node) {
            const type_idx = self.resolveTypeExpr(type_arg_n)
            if (type_idx != invalid_type) {
                return (1, self.types.sizeOf(type_idx))
            }
        }
        if (bk == @intFromEnum(BuiltinKind.enum_len) and type_arg_n != null_node) {
            const type_idx = self.resolveTypeExpr(type_arg_n)
            if (type_idx != invalid_type) {
                const t = self.types.get(type_idx)
                if (t.tag == TAG_ENUM) {
                    const et = switch (t) { Type.enum_type |e| => e, else => EnumType { name: "", variant_count: 0, variants: 0, backing_type: 0 } }
                    return (1, et.variant_count)
                }
            }
        }
        return (0, 0)
    }

    fn evalConstFieldAccess(idx: int) (int, int) {
        var base_n = null_node
        var field_name = ""
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.field_access |fa| => { base_n = fa.base; field_name = fa.field }, else => {} }, else => {} }
        if (nodeTag(self.ast, base_n) == "ident") {
            var base_name = ""
            switch (self.ast.getNode(base_n)) { Node.expr |e| => switch (e) { Expr.ident |id| => { base_name = id.name }, else => {} }, else => {} }
            const type_idx = self.types.lookupByName(base_name)
            if (type_idx >= 0) {
                const t = self.types.get(type_idx)
                if (t.tag == TAG_ENUM) {
                    const et = switch (t) { Type.enum_type |e| => e, else => EnumType { name: "", variant_count: 0, variants: 0, backing_type: 0 } }
                    for vi in 0..et.variant_count {
                        const ev = et.getVariant(vi)
                        if (ev.name == field_name) {
                            return (1, ev.value)
                        }
                    }
                }
            }
        }
        return (0, 0)
    }

    /// Evaluate a constant string expression.
    /// Returns (1, value) for success, (0, "") for failure.
    /// Zig ref: checker.zig:1435-1454
    fn evalConstString(idx: int) (int, string) {
        if (idx == null_node) { return (0, "") }
        const tag = nodeTag(self.ast, idx)
        if (tag == "literal") {
            var kind = 0
            var val_str = ""
            switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.literal |lit| => { kind = lit.kind; val_str = lit.value }, else => {} }, else => {} }
            if (kind == @intFromEnum(LiteralKind.@"string")) {
                return (1, val_str)
            }
        }
        if (tag == "paren") {
            var inner_n = null_node
            switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.paren |p| => { inner_n = p.inner }, else => {} }, else => {} }
            return self.evalConstString(inner_n)
        }
        if (tag == "builtin_call") {
            var bk = 0
            switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.builtin_call |bc| => { bk = bc.kind }, else => {} }, else => {} }
            if (bk == @intFromEnum(BuiltinKind.target_os)) { return (1, "macos") }
            if (bk == @intFromEnum(BuiltinKind.target_arch)) { return (1, "aarch64") }
            if (bk == @intFromEnum(BuiltinKind.target)) { return (1, "aarch64-macos") }
        }
        return (0, "")
    }

    /// Evaluate a comptime if expression: if (const_cond) then_val else else_val
    fn evalConstIfExpr(idx: int) (int, int) {
        var cond_n = null_node
        var then_n = null_node
        var else_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.if_expr |ie| => { cond_n = ie.condition; then_n = ie.then_branch; else_n = ie.else_branch }, else => {} }, else => {} }
        const cond = self.evalConstExpr(cond_n)
        if (cond.0 == 0) { return (0, 0) }
        if (cond.1 != 0) { return self.evalConstExpr(then_n) }
        if (else_n != null_node) { return self.evalConstExpr(else_n) }
        return (0, 0)
    }

    /// Evaluate a comptime { ... } block: push comptime context, run statements, evaluate result.
    fn evalConstComptimeBlock(idx: int) (int, int) {
        var body_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.comptime_block |cb| => { body_n = cb.body }, else => {} }, else => {} }
        if (body_n == null_node) { return (0, 0) }
        // comptime_block body should be a block_expr
        if (nodeTag(self.ast, body_n) != "block_expr") {
            // Single expression body — just evaluate it
            const old_comptime = self.in_comptime
            self.in_comptime = true
            const result = self.evalConstExpr(body_n)
            self.in_comptime = old_comptime
            return result
        }
        // Block with statements — push comptime context
        var stmts: List(int) = .{}
        var result_n = null_node
        switch (self.ast.getNode(body_n)) { Node.expr |e| => switch (e) { Expr.block_expr |blk| => { stmts = blk.stmts; result_n = blk.result_expr }, else => {} }, else => {} }
        const old_comptime = self.in_comptime
        self.in_comptime = true
        const result = self.evalComptimeStmts(stmts, result_n)
        self.in_comptime = old_comptime
        return result
    }

    /// Evaluate a block expression: { stmts...; result_expr }
    fn evalConstBlockExpr(idx: int) (int, int) {
        var stmts: List(int) = .{}
        var result_n = null_node
        switch (self.ast.getNode(idx)) { Node.expr |e| => switch (e) { Expr.block_expr |blk| => { stmts = blk.stmts; result_n = blk.result_expr }, else => {} }, else => {} }
        if (stmts.count == 0) { return self.evalConstExpr(result_n) }
        // Block with statements — only allowed in comptime context
        if (self.in_comptime) { return self.evalComptimeStmts(stmts, result_n) }
        return (0, 0)
    }

    /// Execute comptime block statements and evaluate final expression.
    /// Handles: var_stmt (init), assign_stmt (mutate), for_stmt (inline), expr_stmt (discard).
    fn evalComptimeStmts(stmts: List(int), final_expr: int) (int, int) {
        for i in 0..stmts.count {
            const stmt_idx = stmts.get(i)
            const tag = nodeTag(self.ast, stmt_idx)
            if (tag == "var_stmt") {
                var name = ""
                var val_n = null_node
                switch (self.ast.getNode(stmt_idx)) { Node.stmt |s| => switch (s) { Stmt.var_stmt |vs| => { name = vs.name; val_n = vs.value }, else => {} }, else => {} }
                if (val_n != null_node) {
                    const val = self.evalConstExpr(val_n)
                    if (val.0 == 0) { return (0, 0) }
                    self.comptime_vars.set(name, val.1)
                } else {
                    self.comptime_vars.set(name, 0)
                }
            } else if (tag == "assign_stmt") {
                var target_n = null_node
                var op = 0
                var val_n = null_node
                switch (self.ast.getNode(stmt_idx)) { Node.stmt |s| => switch (s) { Stmt.assign_stmt |a| => { target_n = a.target; op = a.op; val_n = a.value }, else => {} }, else => {} }
                // Get target variable name
                var target_name = ""
                if (nodeTag(self.ast, target_n) == "ident") {
                    switch (self.ast.getNode(target_n)) { Node.expr |e| => switch (e) { Expr.ident |id| => { target_name = id.name }, else => {} }, else => {} }
                }
                if (target_name == "") { return (0, 0) }
                const rhs = self.evalConstExpr(val_n)
                if (rhs.0 == 0) { return (0, 0) }
                if (op == @intFromEnum(Token.assign)) {
                    self.comptime_vars.set(target_name, rhs.1)
                } else if (op == @intFromEnum(Token.add_assign)) {
                    const old = self.comptime_vars.get(target_name)
                    self.comptime_vars.set(target_name, old + rhs.1)
                } else if (op == @intFromEnum(Token.sub_assign)) {
                    const old = self.comptime_vars.get(target_name)
                    self.comptime_vars.set(target_name, old - rhs.1)
                } else if (op == @intFromEnum(Token.mul_assign)) {
                    const old = self.comptime_vars.get(target_name)
                    self.comptime_vars.set(target_name, old * rhs.1)
                } else {
                    return (0, 0)
                }
            } else if (tag == "for_stmt") {
                // Only inline for allowed in comptime
                var binding = ""
                var start_n = null_node
                var end_n = null_node
                var body_n = null_node
                var is_inline = false
                switch (self.ast.getNode(stmt_idx)) { Node.stmt |s| => switch (s) { Stmt.for_stmt |fs| => { binding = fs.binding; start_n = fs.range_start; end_n = fs.range_end; body_n = fs.body; is_inline = fs.is_inline }, else => {} }, else => {} }
                if (not is_inline) { return (0, 0) }
                const sv = self.evalConstExpr(start_n)
                const ev = self.evalConstExpr(end_n)
                if (sv.0 == 0 or ev.0 == 0) { return (0, 0) }
                var iter = sv.1
                while (iter < ev.1) {
                    self.comptime_vars.set(binding, iter)
                    // Evaluate body — extract stmts from block_stmt
                    if (nodeTag(self.ast, body_n) == "block_stmt") {
                        var body_stmts: List(int) = .{}
                        switch (self.ast.getNode(body_n)) { Node.stmt |s| => switch (s) { Stmt.block_stmt |bs| => { body_stmts = bs.stmts }, else => {} }, else => {} }
                        for j in 0..body_stmts.count {
                            const inner_tag = nodeTag(self.ast, body_stmts.get(j))
                            if (inner_tag == "assign_stmt") {
                                var at = null_node
                                var aop = 0
                                var av = null_node
                                switch (self.ast.getNode(body_stmts.get(j))) { Node.stmt |s| => switch (s) { Stmt.assign_stmt |a| => { at = a.target; aop = a.op; av = a.value }, else => {} }, else => {} }
                                var aname = ""
                                if (nodeTag(self.ast, at) == "ident") {
                                    switch (self.ast.getNode(at)) { Node.expr |e| => switch (e) { Expr.ident |id| => { aname = id.name }, else => {} }, else => {} }
                                }
                                if (aname != "") {
                                    const arhs = self.evalConstExpr(av)
                                    if (arhs.0 != 0) {
                                        if (aop == @intFromEnum(Token.assign)) {
                                            self.comptime_vars.set(aname, arhs.1)
                                        } else if (aop == @intFromEnum(Token.add_assign)) {
                                            self.comptime_vars.set(aname, self.comptime_vars.get(aname) + arhs.1)
                                        } else if (aop == @intFromEnum(Token.sub_assign)) {
                                            self.comptime_vars.set(aname, self.comptime_vars.get(aname) - arhs.1)
                                        } else if (aop == @intFromEnum(Token.mul_assign)) {
                                            self.comptime_vars.set(aname, self.comptime_vars.get(aname) * arhs.1)
                                        }
                                    }
                                }
                            } else if (inner_tag == "var_stmt") {
                                var vn = ""
                                var vv = null_node
                                switch (self.ast.getNode(body_stmts.get(j))) { Node.stmt |s| => switch (s) { Stmt.var_stmt |vs| => { vn = vs.name; vv = vs.value }, else => {} }, else => {} }
                                if (vv != null_node) {
                                    const vr = self.evalConstExpr(vv)
                                    if (vr.0 != 0) { self.comptime_vars.set(vn, vr.1) }
                                }
                            }
                        }
                    }
                    iter += 1
                }
            } else if (tag == "expr_stmt") {
                // Discard expression statements
                var expr_n = null_node
                switch (self.ast.getNode(stmt_idx)) { Node.stmt |s| => switch (s) { Stmt.expr_stmt |es| => { expr_n = es.expr }, else => {} }, else => {} }
                if (expr_n != null_node) {
                    self.evalConstExpr(expr_n)
                }
            } else {
                return (0, 0)
            }
        }
        return self.evalConstExpr(final_expr)
    }

    // ---- Helper methods ----

    fn materializeType(idx: int) int {
        if (idx == UNTYPED_INT) { return INT }
        if (idx == UNTYPED_FLOAT) { return FLOAT }
        if (idx == UNTYPED_BOOL) { return BOOL }
        // Recursive array/slice materialization (Zig ref: checker.zig:3709-3717)
        const t = self.types.get(idx)
        if (t.tag == TAG_ARRAY) {
            const arr = switch (t) { Type.array |a| => a, else => ArrayType { elem: invalid_type, length: 0 } }
            const new_elem = self.materializeType(arr.elem)
            if (new_elem != arr.elem) { return self.types.makeArray(new_elem, arr.length) }
        }
        if (t.tag == TAG_SLICE) {
            const sl = switch (t) { Type.slice |s| => s, else => SliceType { elem: invalid_type } }
            const new_elem = self.materializeType(sl.elem)
            if (new_elem != sl.elem) { return self.types.makeSlice(new_elem) }
        }
        return idx
    }

    fn isBoolType(idx: int) bool {
        return idx == BOOL or idx == UNTYPED_BOOL
    }

    fn isNumericType(idx: int) bool {
        return idx == I8 or idx == I16 or idx == I32 or idx == I64 or
               idx == U8 or idx == U16 or idx == U32 or idx == U64 or
               idx == F32 or idx == F64 or idx == UNTYPED_INT or idx == UNTYPED_FLOAT
    }

    fn isIntegerType(idx: int) bool {
        return idx == I8 or idx == I16 or idx == I32 or idx == I64 or
               idx == U8 or idx == U16 or idx == U32 or idx == U64 or
               idx == UNTYPED_INT
    }

    fn isFloatType(idx: int) bool {
        return idx == F32 or idx == F64 or idx == UNTYPED_FLOAT
    }

    /// Port from Zig checker lines 3696-3714.
    fn isComparable(a: int, b: int) bool {
        if (self.types.isAssignable(a, b) or self.types.isAssignable(b, a)) { return true }
        const ta = self.types.get(a)
        const tb = self.types.get(b)
        if (self.isNumericType(a) and self.isNumericType(b)) { return true }
        // String-string comparison (slice(u8) == slice(u8))
        if (a == STRING and b == STRING) { return true }
        // Optional-null comparison
        if (ta.tag == TAG_OPTIONAL and b == UNTYPED_NULL) { return true }
        if (tb.tag == TAG_OPTIONAL and a == UNTYPED_NULL) { return true }
        // Pointer-null comparison
        if (ta.tag == TAG_POINTER and b == UNTYPED_NULL) { return true }
        if (tb.tag == TAG_POINTER and a == UNTYPED_NULL) { return true }
        // Enum-integer comparison
        if (ta.tag == TAG_ENUM and self.isIntegerType(b)) { return true }
        if (tb.tag == TAG_ENUM and self.isIntegerType(a)) { return true }
        // Optional-to-value comparison
        if (ta.tag == TAG_OPTIONAL) {
            const elem = switch (ta) { Type.optional |o| => o.elem, else => invalid_type }
            if (self.isComparable(elem, b)) { return true }
        }
        if (tb.tag == TAG_OPTIONAL) {
            const elem = switch (tb) { Type.optional |o| => o.elem, else => invalid_type }
            if (self.isComparable(a, elem)) { return true }
        }
        return false
    }

    /// Merge two error sets into a new error set with deduplicated variants.
    /// Port from Zig checker.zig:1662-1677.
    fn mergeErrorSets(a_idx: int, b_idx: int) int {
        const a = self.types.get(a_idx)
        const b = self.types.get(b_idx)
        const a_es = switch (a) { Type.error_set |e| => e, else => ErrorSetType { name: "", variant_count: 0, variant_names: 0 } }
        const b_es = switch (b) { Type.error_set |e| => e, else => ErrorSetType { name: "", variant_count: 0, variant_names: 0 } }

        // Build merged variant list with dedup (Zig: ArrayListUnmanaged + string compare)
        var merged: List(string) = .{}

        // Add all from a
        for ai in 0..a_es.variant_count {
            const av = a_es.getVariant(ai)
            merged.append(av.name)
        }

        // Add from b, skip duplicates
        for bi in 0..b_es.variant_count {
            const bv = b_es.getVariant(bi)
            var found = false
            for mi in 0..merged.count {
                if (merged.get(mi) == bv.name) {
                    found = true
                    break
                }
            }
            if (!found) { merged.append(bv.name) }
        }

        // Allocate merged variant array
        var merged_ptr: int = 0
        if (merged.count > 0) {
            merged_ptr = alloc(0, merged.count * @sizeOf(ErrorVariant))
            for i in 0..merged.count {
                const dest = @intToPtr(*ErrorVariant, merged_ptr + i * @sizeOf(ErrorVariant))
                dest.name = merged.get(i)
            }
        }

        const merged_name = "${a_es.name}||${b_es.name}"
        return self.types.add(Type.error_set(ErrorSetType {
            name: merged_name,
            variant_count: merged.count,
            variant_names: merged_ptr,
        }))
    }

    // ---- Lint checks ----

    /// Check for unused symbols in a scope.
    /// Zig ref: checker.zig:245-265
    fn checkScopeUnused(scope_idx: int) void {
        if (!self.lint_mode) { return }
        var map = self.getScopeMap(scope_idx)
        for ki in 0..map.capacity {
            if (@intToPtr(*u8, map.states + ki).* != 1) { continue }
            const sym_idx = @intToPtr(*int, map.values + ki * 8).*
            const sym = self.getSymbol(sym_idx)
            if (sym.used) { continue }
            // Skip _ prefixed names (intentionally unused)
            if (@lenOf(sym.name) > 0 and charAt(sym.name, 0) == '_') { continue }
            // Skip "self" parameter
            if (sym.name == "self") { continue }
            // Skip functions and type names (only lint vars/consts/params)
            if (sym.is_func or sym.is_type) { continue }
            // Get position from node
            var offset: int = 0
            if (sym.node != null_node) {
                const span = self.ast.nodeSpan(sym.node)
                offset = span.start
            }
            self.err.warningWithCode(offset, WarningCode.w001, sym.name)
        }
    }

    /// Check if a node is a terminal statement (return, break, continue).
    fn isTerminalStmt(idx: int) bool {
        const tag = nodeTag(self.ast, idx)
        return tag == "return_stmt" or tag == "break_stmt" or tag == "continue_stmt"
    }

    /// Check a list of statements with reachability analysis.
    /// Warns on unreachable code after return/break/continue.
    /// Zig ref: checker.zig:267-308
    fn checkStmtsWithReachability(stmts: List(int)) void {
        var seen_terminal = false
        var warned = false
        for i in 0..stmts.count {
            const stmt_idx = stmts.get(i)
            if (seen_terminal and self.lint_mode and !warned) {
                self.err.warningWithCode(self.ast.nodeSpan(stmt_idx).start, WarningCode.w004, "unreachable code")
                warned = true
            }
            if (!seen_terminal) {
                self.checkStmt(stmt_idx)
            }
            if (!seen_terminal and self.isTerminalStmt(stmt_idx)) {
                seen_terminal = true
            }
        }
    }

    /// Check if a node is an empty block (for lint W005).
    fn isEmptyBlock(idx: int) bool {
        const tag = nodeTag(self.ast, idx)
        if (tag == "block_stmt") {
            const node = self.ast.getNode(idx)
            switch (node) { Node.stmt |s| => switch (s) { Stmt.block_stmt |bs| => {
                return bs.stmts.count == 0
            }, else => {} }, else => {} }
        }
        if (tag == "block_expr") {
            const node = self.ast.getNode(idx)
            switch (node) { Node.expr |e| => switch (e) { Expr.block_expr |be| => {
                return be.stmts.count == 0 and be.result_expr == null_node
            }, else => {} }, else => {} }
        }
        return false
    }

    /// Warn on empty block bodies (for, while, if).
    fn warnEmptyBlock(idx: int, body_idx: int) void {
        if (!self.lint_mode) { return }
        if (self.isEmptyBlock(body_idx)) {
            self.err.warningWithCode(self.ast.nodeSpan(idx).start, WarningCode.w005, "empty block")
        }
    }

    /// Compute the Levenshtein edit distance between two strings.
    /// Uses heap-allocated arrays (Cot lacks fixed-size stack arrays).
    /// Zig ref: checker.zig:3748-3772
    fn editDistance(a: string, b: string) int {
        const alen = @lenOf(a)
        const blen = @lenOf(b)
        if (alen > 64 or blen > 64) { return 999 }
        if (alen == 0) { return blen }
        if (blen == 0) { return alen }
        if (a == b) { return 0 }

        // Use shorter string for column dimension
        var s1 = a
        var s2 = b
        if (alen > blen) { s1 = b; s2 = a }
        const s1len = @lenOf(s1)
        const s2len = @lenOf(s2)

        // Allocate two rows: prev and curr
        const row_size = (s1len + 1) * 8
        const prev_ptr = alloc(0, row_size)
        const curr_ptr = alloc(0, row_size)

        // Initialize prev row: [0, 1, 2, ..., s1len]
        for i in 0..s1len + 1 {
            @intToPtr(*int, prev_ptr + i * 8).* = i
        }

        for j in 0..s2len {
            const c2 = charAt(s2, j)
            @intToPtr(*int, curr_ptr).* = j + 1
            for i in 0..s1len {
                const c1 = charAt(s1, i)
                const cost = if (c1 == c2) { 0 } else { 1 }
                const del = @intToPtr(*int, curr_ptr + i * 8).* + 1
                const ins = @intToPtr(*int, prev_ptr + (i + 1) * 8).* + 1
                const sub = @intToPtr(*int, prev_ptr + i * 8).* + cost
                var min_val = del
                if (ins < min_val) { min_val = ins }
                if (sub < min_val) { min_val = sub }
                @intToPtr(*int, curr_ptr + (i + 1) * 8).* = min_val
            }
            // Copy curr to prev
            for i in 0..s1len + 1 {
                @intToPtr(*int, prev_ptr + i * 8).* = @intToPtr(*int, curr_ptr + i * 8).*
            }
        }

        const result = @intToPtr(*int, prev_ptr + s1len * 8).*
        dealloc(prev_ptr)
        dealloc(curr_ptr)
        return result
    }

    /// Check if a name is a valid suggestion candidate (not internal/generated).
    fn isUserVisibleName(name: string) bool {
        const len = @lenOf(name)
        if (len == 0) { return false }
        // Skip generic instantiation names (contain '(')
        if (contains(name, "(")) { return false }
        // Skip internal names (start with __)
        if (len >= 2 and charAt(name, 0) == '_' and charAt(name, 1) == '_') { return false }
        return true
    }

    /// Search scope chain for the closest match to `name`.
    /// Zig ref: checker.zig:3784-3835
    fn findSimilarName(name: string) ?string {
        var best: ?string = null
        var best_dist = 999

        // Walk scope chain — check all symbols
        for si in 0..self.symbols.count {
            const sym = self.getSymbol(si)
            const candidate = sym.name
            if (candidate == name) { continue }
            if (!self.isUserVisibleName(candidate)) { continue }
            const d = self.editDistance(name, candidate)
            if (d < best_dist and d <= 2 and d * 2 <= @lenOf(name)) {
                best_dist = d
                best = candidate
            }
        }

        return best
    }

    /// Find similar struct field name for "did you mean" suggestions.
    /// Zig ref: checker.zig:3838-3858
    fn findSimilarField(name: string, struct_type_idx: int) ?string {
        const t = self.types.get(struct_type_idx)
        if (t.tag != TAG_STRUCT) { return null }
        const st = switch (t) { Type.struct_type |s| => s, else => StructType { name: "", field_count: 0, fields: 0, size: 0, alignment: 0, layout: 0 } }
        var best: ?string = null
        var best_dist = 999
        for fi in 0..st.field_count {
            const sf = st.getField(fi)
            const d = self.editDistance(name, sf.name)
            if (d < best_dist and d <= 2 and d * 2 <= @lenOf(name)) {
                best_dist = d
                best = sf.name
            }
        }
        return best
    }

    /// Find similar enum/union variant name for "did you mean" suggestions.
    /// Zig ref: checker.zig:3860-3880
    fn findSimilarVariant(name: string, type_idx: int) ?string {
        const t = self.types.get(type_idx)
        var best: ?string = null
        var best_dist = 999
        if (t.tag == TAG_ENUM) {
            const et = switch (t) { Type.enum_type |e| => e, else => EnumType { name: "", variant_count: 0, variants: 0, backing_type: 0 } }
            for vi in 0..et.variant_count {
                const ev = et.getVariant(vi)
                const d = self.editDistance(name, ev.name)
                if (d < best_dist and d <= 2 and d * 2 <= @lenOf(name)) {
                    best_dist = d
                    best = ev.name
                }
            }
        }
        if (t.tag == TAG_UNION) {
            const ut = switch (t) { Type.union_type |u| => u, else => UnionType { name: "", variant_count: 0, variants: 0, tag_type: 0 } }
            for vi in 0..ut.variant_count {
                const uv = ut.getVariant(vi)
                const d = self.editDistance(name, uv.name)
                if (d < best_dist and d <= 2 and d * 2 <= @lenOf(name)) {
                    best_dist = d
                    best = uv.name
                }
            }
        }
        return best
    }

    fn reportError(idx: int, code: ErrorCode, msg: string) void {
        // Extract span from the node using nodeSpan
        var offset: int = 0
        if (idx != null_node) {
            const span = self.ast.nodeSpan(idx)
            offset = span.start
        }
        self.err.report(offset, code, msg)
    }
}

// ============================================================================
// Helper functions
// ============================================================================

// parseInt is provided by std/string (imported via main.cot)

/// Allocate a zero-initialized Map(string, int) on the heap.
/// Returns the raw pointer (int) to the Map struct.
fn allocMap() int {
    const size = 40  // Map has 5 fields × 8 bytes: keys, values, states, count, capacity
    const ptr = alloc(0, size)
    // Zero-init all fields
    var mp = @intToPtr(*Map(string, int), ptr)
    mp.keys = 0
    mp.values = 0
    mp.states = 0
    mp.count = 0
    mp.capacity = 0
    return ptr
}

// ============================================================================
// Tests
// ============================================================================

test "checker init" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)
    @assertEq(c.current_scope, 0)
    @assertEq(c.global_scope, 0)
    @assertEq(c.in_loop, false)
}

test "checker scope push pop" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)
    @assertEq(c.current_scope, 0)

    c.pushScope()
    @assertEq(c.current_scope, 1)

    c.pushScope()
    @assertEq(c.current_scope, 2)

    c.popScope()
    @assertEq(c.current_scope, 1)

    c.popScope()
    @assertEq(c.current_scope, 0)
}

test "checker define and lookup symbol" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    c.defineSymbol(makeSymbol("x", I64, 0, true))
    const idx = c.lookupSymbol("x")
    @assert(idx >= 0)
    @assertEq(c.getSymbol(idx).name, "x")
    @assertEq(c.getSymbol(idx).type_idx, I64)
    @assertEq(c.getSymbol(idx).mutable, true)
}

test "checker parent scope lookup" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    c.defineSymbol(makeSymbol("x", I64, 0, true))
    c.pushScope()
    c.defineSymbol(makeSymbol("y", BOOL, 1, false))

    // Can find both x and y from child scope
    @assert(c.lookupSymbol("x") >= 0)
    @assert(c.lookupSymbol("y") >= 0)

    c.popScope()
    // x still visible, y not
    @assert(c.lookupSymbol("x") >= 0)
    @assertEq(c.lookupSymbol("y"), -1)
}

test "checker isDefined local only" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    c.defineSymbol(makeSymbol("x", I64, 0, true))
    c.pushScope()

    // isDefined only checks current scope
    @assertEq(c.isDefined("x"), false)
    // lookup walks up
    @assert(c.lookupSymbol("x") >= 0)
}

test "checker materializeType" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    @assertEq(c.materializeType(UNTYPED_INT), INT)
    @assertEq(c.materializeType(UNTYPED_FLOAT), FLOAT)
    @assertEq(c.materializeType(UNTYPED_BOOL), BOOL)
    @assertEq(c.materializeType(I64), I64)
    @assertEq(c.materializeType(STRING), STRING)
}

test "checker isBoolType" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    @assert(c.isBoolType(BOOL))
    @assert(c.isBoolType(UNTYPED_BOOL))
    @assertEq(c.isBoolType(I64), false)
    @assertEq(c.isBoolType(STRING), false)
}

test "checker isNumericType" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    @assert(c.isNumericType(I64))
    @assert(c.isNumericType(F64))
    @assert(c.isNumericType(U8))
    @assert(c.isNumericType(UNTYPED_INT))
    @assertEq(c.isNumericType(BOOL), false)
    @assertEq(c.isNumericType(STRING), false)
}


test "checker checkFile simple const" {
    const src = "const x = 42"
    var s = Scanner.init(src)
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), false)

    var types = TypeRegistry.init()
    var c = Checker.init(ast, types, errs)
    c.checkFile()
    @assertEq(errs.hasErrors(), false)
}

test "checker checkFile simple fn" {
    const src = "fn foo() void { return }"
    var s = Scanner.init(src)
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), false)

    var types = TypeRegistry.init()
    var c = Checker.init(ast, types, errs)
    c.checkFile()
    @assertEq(errs.hasErrors(), false)
}

test "checker detects undefined identifier" {
    const src = "fn foo() int { return xyz }"
    var s = Scanner.init(src)
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), false)

    var types = TypeRegistry.init()
    var c = Checker.init(ast, types, errs)
    c.checkFile()
    @assert(errs.hasErrors())
}

test "checker struct type" {
    const src = "struct Point { x: int, y: int }"
    var s = Scanner.init(src)
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), false)

    var types = TypeRegistry.init()
    var c = Checker.init(ast, types, errs)
    c.checkFile()
    @assertEq(errs.hasErrors(), false)
    @assert(types.lookupByName("Point") >= 0)
}

test "checker enum type" {
    const src = "const Color = enum { red, green, blue }"
    var s = Scanner.init(src)
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), false)

    var types = TypeRegistry.init()
    var c = Checker.init(ast, types, errs)
    c.checkFile()
    @assertEq(errs.hasErrors(), false)
    @assert(types.lookupByName("Color") >= 0)
}

test "checker const evaluation" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    // Create a literal node for "42"
    const s = Span { start: 0, end: 2 }
    const lit = ast.addExpr(Expr.literal(Literal { kind: @intFromEnum(LiteralKind.@"int"), value: "42", span: s }))
    const cv = c.evalConstExpr(lit)
    @assert(cv.0 != 0)
    @assertEq(cv.1, 42)
}

test "checker const evaluation binary" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    const s = Span { start: 0, end: 5 }
    const left = ast.addExpr(Expr.literal(Literal { kind: @intFromEnum(LiteralKind.@"int"), value: "10", span: s }))
    const right = ast.addExpr(Expr.literal(Literal { kind: @intFromEnum(LiteralKind.@"int"), value: "3", span: s }))
    const bin = ast.addExpr(Expr.binary(Binary { op: @intFromEnum(Token.add), left: left, right: right, span: s }))
    const cv = c.evalConstExpr(bin)
    @assert(cv.0 != 0)
    @assertEq(cv.1, 13)
}

test "checker literal types" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    const s = Span { start: 0, end: 2 }
    const int_lit = ast.addExpr(Expr.literal(Literal { kind: @intFromEnum(LiteralKind.@"int"), value: "42", span: s }))
    @assertEq(c.checkExpr(int_lit), UNTYPED_INT)

    const str_lit = ast.addExpr(Expr.literal(Literal { kind: @intFromEnum(LiteralKind.@"string"), value: "\"hello\"", span: s }))
    @assertEq(c.checkExpr(str_lit), STRING)

    const true_lit = ast.addExpr(Expr.literal(Literal { kind: @intFromEnum(LiteralKind.true_lit), value: "true", span: s }))
    @assertEq(c.checkExpr(true_lit), UNTYPED_BOOL)
}

test "checker trait collection" {
    const src = "trait Drawable { fn draw(self: *Drawable) void }\nstruct Circle { radius: int }\nimpl Drawable for Circle { fn draw(self: *Circle) void { } }"
    var s = Scanner.init(src)
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), false)

    var types = TypeRegistry.init()
    var c = Checker.init(ast, types, errs)
    c.checkFile()
    @assertEq(errs.hasErrors(), false)
    // Trait should be registered
    @assertEq(c.trait_defs.has("Drawable") != 0, true)
}

test "checker safe wrap type" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    // Not in safe mode — should not wrap
    c.safe_mode = false
    @assertEq(c.safeWrapType(I64), I64)

    // In safe mode — should wrap struct to pointer
    c.safe_mode = true
    const st = types.add(Type.struct_type(StructType { name: "Foo", field_count: 0, fields: 0, size: 0, alignment: 0, layout: 0 }))
    const wrapped = c.safeWrapType(st)
    @assert(wrapped != st)  // Should be different (pointer type)

    // Non-struct should not be wrapped
    @assertEq(c.safeWrapType(I64), I64)
    @assertEq(c.safeWrapType(STRING), STRING)
}

test "checker type substitution" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    // No substitution active
    @assertEq(c.hasTypeSubstitution(), false)
    @assertEq(c.lookupTypeSub("T"), -1)

    // Push a substitution T → I64
    c.pushTypeSub("T", I64)
    @assert(c.hasTypeSubstitution())
    @assertEq(c.lookupTypeSub("T"), I64)
    @assertEq(c.lookupTypeSub("U"), -1)

    // Push another: U → STRING
    c.pushTypeSub("U", STRING)
    @assertEq(c.lookupTypeSub("T"), I64)
    @assertEq(c.lookupTypeSub("U"), STRING)

    // Restore by truncation
    c.type_sub_keys.count = 1
    c.type_sub_vals.count = 1
    @assert(c.hasTypeSubstitution())
    @assertEq(c.lookupTypeSub("T"), I64)
    @assertEq(c.lookupTypeSub("U"), -1)

    // Full restore
    c.type_sub_keys.count = 0
    c.type_sub_vals.count = 0
    @assertEq(c.hasTypeSubstitution(), false)
}

test "checker generic cache key" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)

    // Single arg
    var args1: List(int) = .{}
    args1.append(5)
    @assertEq(c.buildGenericCacheKey("List", args1), "List(5)")

    // Two args
    var args2: List(int) = .{}
    args2.append(5)
    args2.append(17)
    @assertEq(c.buildGenericCacheKey("Pair", args2), "Pair(5;17)")
}

test "checker generic struct registration" {
    const src = "struct Box(T) { value: T }"
    var s = Scanner.init(src)
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), false)

    var types = TypeRegistry.init()
    var c = Checker.init(ast, types, errs)
    c.checkFile()
    @assertEq(errs.hasErrors(), false)
    // Generic struct should be stored in generic_structs map
    @assert(c.generic_structs.has("Box") != 0)
    // But not yet in the type registry (no concrete instantiation)
    @assertEq(types.lookupByName("Box"), -1)
}

test "checker expected type init" {
    var ast = Ast.init("test.cot")
    var types = TypeRegistry.init()
    var errs = ErrorReporter.init()
    var c = Checker.init(ast, types, errs)
    @assertEq(c.expected_type, invalid_type)
    @assertEq(c.current_switch_enum_type, invalid_type)
}
