/// Token definitions for the self-hosted compiler.
/// Ported from compiler/frontend/token.zig

/// All token types produced by the scanner.
const Token = enum(u8) {
    // Special
    illegal, eof, comment, doc_comment,

    // Literals (literal_beg..literal_end)
    literal_beg,
    ident, int_lit, float_lit, string_lit,
    string_interp_start, string_interp_mid, string_interp_end,
    char_lit,
    literal_end,

    // Operators (operator_beg..operator_end)
    operator_beg,
    add, sub, mul, quo, rem, concat,
    @"and", @"or", xor, shl, shr, @"not",
    add_assign, sub_assign, mul_assign, quo_assign, rem_assign,
    and_assign, or_assign, xor_assign,
    eql, neq, lss, leq, gtr, geq,
    land, lor, lnot,
    assign, arrow, fat_arrow, optional_chain,
    lparen, rparen, lbrack, rbrack, lbrace, rbrace,
    comma, period, period_period, period_star, period_question,
    semicolon, colon, at, question,
    operator_end,

    // Keywords (keyword_beg..keyword_end)
    keyword_beg,
    kw_fn, kw_var, kw_let, kw_const, kw_struct, kw_impl, kw_trait, kw_where,
    kw_enum, kw_union, kw_type, kw_import, kw_extern, kw_export, kw_test, kw_bench,
    kw_if, kw_else, kw_switch, kw_while, kw_for, kw_in,
    kw_return, kw_break, kw_continue, kw_defer, kw_errdefer, kw_try, kw_catch, kw_orelse, kw_error,
    kw_true, kw_false, kw_null, kw_new, kw_undefined,
    kw_comptime,
    kw_async, kw_await,
    kw_inline,
    kw_unreachable,
    kw_packed,
    kw_weak,
    kw_static,
    kw_and, kw_or, kw_not,
    kw_int, kw_float, kw_bool, kw_string, kw_byte, kw_void, kw_noreturn,
    kw_i8, kw_i16, kw_i32, kw_i64, kw_u8, kw_u16, kw_u32, kw_u64, kw_f32, kw_f64,
    keyword_end,
}

/// Comptime string table: maps every Token variant to its display string.
/// Zig: const token_strings = blk: { var s: [...]; for (fields) |f| s[f.value] = f.name; break :blk s; };
const token_strings = comptime {
    var s: [@enumLen(Token)]string = undefined
    inline for field in @typeInfo(Token).fields {
        s[field.value] = field.name
    }
    // Readable overrides for special/literal tokens
    s[@intFromEnum(Token.illegal)] = "ILLEGAL"
    s[@intFromEnum(Token.eof)] = "EOF"
    s[@intFromEnum(Token.comment)] = "COMMENT"
    s[@intFromEnum(Token.doc_comment)] = "DOC_COMMENT"
    s[@intFromEnum(Token.ident)] = "IDENT"
    s[@intFromEnum(Token.int_lit)] = "INT"
    s[@intFromEnum(Token.float_lit)] = "FLOAT"
    s[@intFromEnum(Token.string_lit)] = "STRING"
    s[@intFromEnum(Token.char_lit)] = "CHAR"
    // Operators
    s[@intFromEnum(Token.add)] = "+"
    s[@intFromEnum(Token.sub)] = "-"
    s[@intFromEnum(Token.mul)] = "*"
    s[@intFromEnum(Token.quo)] = "/"
    s[@intFromEnum(Token.rem)] = "%"
    s[@intFromEnum(Token.concat)] = "++"
    s[@intFromEnum(Token.@"and")] = "&"
    s[@intFromEnum(Token.@"or")] = "|"
    s[@intFromEnum(Token.xor)] = "^"
    s[@intFromEnum(Token.shl)] = "<<"
    s[@intFromEnum(Token.shr)] = ">>"
    s[@intFromEnum(Token.@"not")] = "~"
    s[@intFromEnum(Token.add_assign)] = "+="
    s[@intFromEnum(Token.sub_assign)] = "-="
    s[@intFromEnum(Token.mul_assign)] = "*="
    s[@intFromEnum(Token.quo_assign)] = "/="
    s[@intFromEnum(Token.rem_assign)] = "%="
    s[@intFromEnum(Token.and_assign)] = "&="
    s[@intFromEnum(Token.or_assign)] = "|="
    s[@intFromEnum(Token.xor_assign)] = "^="
    s[@intFromEnum(Token.eql)] = "=="
    s[@intFromEnum(Token.neq)] = "!="
    s[@intFromEnum(Token.lss)] = "<"
    s[@intFromEnum(Token.leq)] = "<="
    s[@intFromEnum(Token.gtr)] = ">"
    s[@intFromEnum(Token.geq)] = ">="
    s[@intFromEnum(Token.land)] = "&&"
    s[@intFromEnum(Token.lor)] = "||"
    s[@intFromEnum(Token.lnot)] = "!"
    s[@intFromEnum(Token.assign)] = "="
    s[@intFromEnum(Token.arrow)] = "->"
    s[@intFromEnum(Token.fat_arrow)] = "=>"
    s[@intFromEnum(Token.optional_chain)] = "?."
    s[@intFromEnum(Token.lparen)] = "("
    s[@intFromEnum(Token.rparen)] = ")"
    s[@intFromEnum(Token.lbrack)] = "["
    s[@intFromEnum(Token.rbrack)] = "]"
    s[@intFromEnum(Token.lbrace)] = "{"
    s[@intFromEnum(Token.rbrace)] = "}"
    s[@intFromEnum(Token.comma)] = ","
    s[@intFromEnum(Token.period)] = "."
    s[@intFromEnum(Token.period_period)] = ".."
    s[@intFromEnum(Token.period_star)] = ".*"
    s[@intFromEnum(Token.period_question)] = ".?"
    s[@intFromEnum(Token.semicolon)] = ";"
    s[@intFromEnum(Token.colon)] = ":"
    s[@intFromEnum(Token.at)] = "@"
    s[@intFromEnum(Token.question)] = "?"
    // Keywords
    s[@intFromEnum(Token.kw_fn)] = "fn"
    s[@intFromEnum(Token.kw_var)] = "var"
    s[@intFromEnum(Token.kw_let)] = "let"
    s[@intFromEnum(Token.kw_const)] = "const"
    s[@intFromEnum(Token.kw_struct)] = "struct"
    s[@intFromEnum(Token.kw_impl)] = "impl"
    s[@intFromEnum(Token.kw_trait)] = "trait"
    s[@intFromEnum(Token.kw_where)] = "where"
    s[@intFromEnum(Token.kw_enum)] = "enum"
    s[@intFromEnum(Token.kw_union)] = "union"
    s[@intFromEnum(Token.kw_type)] = "type"
    s[@intFromEnum(Token.kw_import)] = "import"
    s[@intFromEnum(Token.kw_extern)] = "extern"
    s[@intFromEnum(Token.kw_export)] = "export"
    s[@intFromEnum(Token.kw_test)] = "test"
    s[@intFromEnum(Token.kw_bench)] = "bench"
    s[@intFromEnum(Token.kw_if)] = "if"
    s[@intFromEnum(Token.kw_else)] = "else"
    s[@intFromEnum(Token.kw_switch)] = "switch"
    s[@intFromEnum(Token.kw_while)] = "while"
    s[@intFromEnum(Token.kw_for)] = "for"
    s[@intFromEnum(Token.kw_in)] = "in"
    s[@intFromEnum(Token.kw_return)] = "return"
    s[@intFromEnum(Token.kw_break)] = "break"
    s[@intFromEnum(Token.kw_continue)] = "continue"
    s[@intFromEnum(Token.kw_defer)] = "defer"
    s[@intFromEnum(Token.kw_errdefer)] = "errdefer"
    s[@intFromEnum(Token.kw_try)] = "try"
    s[@intFromEnum(Token.kw_catch)] = "catch"
    s[@intFromEnum(Token.kw_orelse)] = "orelse"
    s[@intFromEnum(Token.kw_error)] = "error"
    s[@intFromEnum(Token.kw_true)] = "true"
    s[@intFromEnum(Token.kw_false)] = "false"
    s[@intFromEnum(Token.kw_null)] = "null"
    s[@intFromEnum(Token.kw_new)] = "new"
    s[@intFromEnum(Token.kw_undefined)] = "undefined"
    s[@intFromEnum(Token.kw_comptime)] = "comptime"
    s[@intFromEnum(Token.kw_async)] = "async"
    s[@intFromEnum(Token.kw_await)] = "await"
    s[@intFromEnum(Token.kw_inline)] = "inline"
    s[@intFromEnum(Token.kw_unreachable)] = "unreachable"
    s[@intFromEnum(Token.kw_packed)] = "packed"
    s[@intFromEnum(Token.kw_weak)] = "weak"
    s[@intFromEnum(Token.kw_and)] = "and"
    s[@intFromEnum(Token.kw_or)] = "or"
    s[@intFromEnum(Token.kw_not)] = "not"
    s[@intFromEnum(Token.kw_int)] = "int"
    s[@intFromEnum(Token.kw_float)] = "float"
    s[@intFromEnum(Token.kw_bool)] = "bool"
    s[@intFromEnum(Token.kw_string)] = "string"
    s[@intFromEnum(Token.kw_byte)] = "byte"
    s[@intFromEnum(Token.kw_void)] = "void"
    s[@intFromEnum(Token.kw_noreturn)] = "noreturn"
    s[@intFromEnum(Token.kw_i8)] = "i8"
    s[@intFromEnum(Token.kw_i16)] = "i16"
    s[@intFromEnum(Token.kw_i32)] = "i32"
    s[@intFromEnum(Token.kw_i64)] = "i64"
    s[@intFromEnum(Token.kw_u8)] = "u8"
    s[@intFromEnum(Token.kw_u16)] = "u16"
    s[@intFromEnum(Token.kw_u32)] = "u32"
    s[@intFromEnum(Token.kw_u64)] = "u64"
    s[@intFromEnum(Token.kw_f32)] = "f32"
    s[@intFromEnum(Token.kw_f64)] = "f64"
    s
}

impl Token {
    /// Return the display string for this token.
    fn toString() string {
        return token_strings[@intFromEnum(self)]
    }

    /// Return operator precedence (0 = not an operator).
    fn precedence() u8 {
        return switch (self) {
            .kw_orelse => 1,
            .lor, .kw_or => 2,
            .land, .kw_and => 3,
            .eql, .neq, .lss, .leq, .gtr, .geq => 4,
            .add, .sub, .@"or", .xor, .concat => 5,
            .mul, .quo, .rem, .@"and", .shl, .shr => 6,
            else => 0,
        }
    }

    /// Whether this token is a literal (ident, int, float, string, char).
    fn isLiteral() bool {
        return self > Token.literal_beg and self < Token.literal_end
    }

    /// Whether this token is an operator or punctuation.
    fn isOperator() bool {
        return self > Token.operator_beg and self < Token.operator_end
    }

    /// Whether this token is a keyword.
    fn isKeyword() bool {
        return self > Token.keyword_beg and self < Token.keyword_end
    }

    /// Whether this token is a type keyword (int, f64, string, etc).
    fn isTypeKeyword() bool {
        return switch (self) {
            .kw_int, .kw_float, .kw_bool, .kw_string, .kw_byte, .kw_void, .kw_noreturn,
            .kw_i8, .kw_i16, .kw_i32, .kw_i64, .kw_u8, .kw_u16, .kw_u32, .kw_u64, .kw_f32, .kw_f64 => true,
            else => false,
        }
    }

    /// Whether this token is an assignment operator (=, +=, -=, etc).
    fn isAssignment() bool {
        return switch (self) {
            .assign, .add_assign, .sub_assign, .mul_assign, .quo_assign,
            .rem_assign, .and_assign, .or_assign, .xor_assign => true,
            else => false,
        }
    }
}

/// Look up an identifier string and return its keyword token, or .ident if not a keyword.
fn lookup(name: string) Token {
    return switch (name) {
        "fn" => Token.kw_fn,
        "var" => Token.kw_var,
        "let" => Token.kw_let,
        "const" => Token.kw_const,
        "struct" => Token.kw_struct,
        "impl" => Token.kw_impl,
        "trait" => Token.kw_trait,
        "where" => Token.kw_where,
        "enum" => Token.kw_enum,
        "union" => Token.kw_union,
        "type" => Token.kw_type,
        "import" => Token.kw_import,
        "extern" => Token.kw_extern,
        "export" => Token.kw_export,
        "test" => Token.kw_test,
        "bench" => Token.kw_bench,
        "if" => Token.kw_if,
        "else" => Token.kw_else,
        "switch" => Token.kw_switch,
        "while" => Token.kw_while,
        "for" => Token.kw_for,
        "in" => Token.kw_in,
        "return" => Token.kw_return,
        "break" => Token.kw_break,
        "continue" => Token.kw_continue,
        "defer" => Token.kw_defer,
        "errdefer" => Token.kw_errdefer,
        "try" => Token.kw_try,
        "catch" => Token.kw_catch,
        "orelse" => Token.kw_orelse,
        "error" => Token.kw_error,
        "true" => Token.kw_true,
        "false" => Token.kw_false,
        "null" => Token.kw_null,
        "new" => Token.kw_new,
        "undefined" => Token.kw_undefined,
        "comptime" => Token.kw_comptime,
        "async" => Token.kw_async,
        "await" => Token.kw_await,
        "inline" => Token.kw_inline,
        "unreachable" => Token.kw_unreachable,
        "packed" => Token.kw_packed,
        "weak" => Token.kw_weak,
        "static" => Token.kw_static,
        "and" => Token.kw_and,
        "or" => Token.kw_or,
        "not" => Token.kw_not,
        "int" => Token.kw_int,
        "float" => Token.kw_float,
        "bool" => Token.kw_bool,
        "string" => Token.kw_string,
        "byte" => Token.kw_byte,
        "void" => Token.kw_void,
        "noreturn" => Token.kw_noreturn,
        "i8" => Token.kw_i8,
        "i16" => Token.kw_i16,
        "i32" => Token.kw_i32,
        "i64" => Token.kw_i64,
        "u8" => Token.kw_u8,
        "u16" => Token.kw_u16,
        "u32" => Token.kw_u32,
        "u64" => Token.kw_u64,
        "f32" => Token.kw_f32,
        "f64" => Token.kw_f64,
        else => Token.ident,
    }
}

// ============================================================================
// Tests
// ============================================================================

test "token to string" {
    const tok = Token.add
    @assertEq(tok.toString(), "+")
    @assertEq(Token.kw_fn.toString(), "fn")
    @assertEq(Token.eql.toString(), "==")
    @assertEq(Token.eof.toString(), "EOF")
}

test "keyword lookup" {
    @assertEq(lookup("fn"), Token.kw_fn)
    @assertEq(lookup("var"), Token.kw_var)
    @assertEq(lookup("and"), Token.kw_and)
    @assertEq(lookup("i64"), Token.kw_i64)
    @assertEq(lookup("notakeyword"), Token.ident)
    @assertEq(lookup("main"), Token.ident)
}

test "precedence" {
    @assertEq(Token.mul.precedence(), 6)
    @assertEq(Token.add.precedence(), 5)
    @assertEq(Token.eql.precedence(), 4)
    @assertEq(Token.kw_and.precedence(), 3)
    @assertEq(Token.kw_or.precedence(), 2)
    @assertEq(Token.kw_orelse.precedence(), 1)
    @assertEq(Token.lparen.precedence(), 0)
}

test "isLiteral" {
    @assertEq(Token.ident.isLiteral(), true)
    @assertEq(Token.int_lit.isLiteral(), true)
    @assertEq(Token.string_lit.isLiteral(), true)
    @assertEq(Token.add.isLiteral(), false)
    @assertEq(Token.kw_fn.isLiteral(), false)
}

test "isOperator" {
    @assertEq(Token.add.isOperator(), true)
    @assertEq(Token.eql.isOperator(), true)
    @assertEq(Token.lparen.isOperator(), true)
    @assertEq(Token.ident.isOperator(), false)
    @assertEq(Token.kw_fn.isOperator(), false)
}

test "isKeyword" {
    @assertEq(Token.kw_fn.isKeyword(), true)
    @assertEq(Token.kw_and.isKeyword(), true)
    @assertEq(Token.kw_i64.isKeyword(), true)
    @assertEq(Token.add.isKeyword(), false)
    @assertEq(Token.ident.isKeyword(), false)
}

test "isTypeKeyword" {
    @assertEq(Token.kw_int.isTypeKeyword(), true)
    @assertEq(Token.kw_i64.isTypeKeyword(), true)
    @assertEq(Token.kw_string.isTypeKeyword(), true)
    @assertEq(Token.kw_f64.isTypeKeyword(), true)
    @assertEq(Token.kw_fn.isTypeKeyword(), false)
    @assertEq(Token.kw_if.isTypeKeyword(), false)
    @assertEq(Token.add.isTypeKeyword(), false)
}

test "isAssignment" {
    @assertEq(Token.assign.isAssignment(), true)
    @assertEq(Token.add_assign.isAssignment(), true)
    @assertEq(Token.sub_assign.isAssignment(), true)
    @assertEq(Token.rem_assign.isAssignment(), true)
    @assertEq(Token.add.isAssignment(), false)
    @assertEq(Token.eql.isAssignment(), false)
}

test "string method via switch shorthand" {
    const tok = Token.arrow
    @assertEq(tok.toString(), "->")
    @assertEq(Token.fat_arrow.toString(), "=>")
    @assertEq(Token.question.toString(), "?")
}

test "precedence multi-case arms" {
    @assertEq(Token.sub.precedence(), 5)
    @assertEq(Token.@"or".precedence(), 5)
    @assertEq(Token.xor.precedence(), 5)
    @assertEq(Token.quo.precedence(), 6)
    @assertEq(Token.rem.precedence(), 6)
    @assertEq(Token.@"and".precedence(), 6)
    @assertEq(Token.shl.precedence(), 6)
    @assertEq(Token.shr.precedence(), 6)
    @assertEq(Token.neq.precedence(), 4)
    @assertEq(Token.lss.precedence(), 4)
    @assertEq(Token.leq.precedence(), 4)
    @assertEq(Token.gtr.precedence(), 4)
    @assertEq(Token.geq.precedence(), 4)
    @assertEq(Token.lor.precedence(), 2)
    @assertEq(Token.land.precedence(), 3)
}

test "concat token" {
    @assertEq(Token.concat.toString(), "++")
    @assertEq(Token.concat.precedence(), 5)
    @assertEq(Token.concat.isOperator(), true)
}

test "quoted ident operator tokens" {
    @assertEq(Token.@"and".toString(), "&")
    @assertEq(Token.@"or".toString(), "|")
    @assertEq(Token.@"not".toString(), "~")
    @assertEq(Token.@"and".isOperator(), true)
    @assertEq(Token.@"or".isOperator(), true)
    @assertEq(Token.@"not".isOperator(), true)
}

test "string switch keyword lookup" {
    @assertEq(lookup("struct"), Token.kw_struct)
    @assertEq(lookup("enum"), Token.kw_enum)
    @assertEq(lookup("if"), Token.kw_if)
    @assertEq(lookup("while"), Token.kw_while)
    @assertEq(lookup("return"), Token.kw_return)
    @assertEq(lookup("true"), Token.kw_true)
    @assertEq(lookup("false"), Token.kw_false)
    @assertEq(lookup("null"), Token.kw_null)
    @assertEq(lookup("comptime"), Token.kw_comptime)
    @assertEq(lookup("async"), Token.kw_async)
    @assertEq(lookup("await"), Token.kw_await)
    @assertEq(lookup("u8"), Token.kw_u8)
    @assertEq(lookup("f64"), Token.kw_f64)
    @assertEq(lookup("xyz"), Token.ident)
}
