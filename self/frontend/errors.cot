/// Error reporting for the self-hosted compiler.
/// Ported from compiler/frontend/errors.zig

import "std/string"
import "std/sys"
import "source"

/// Severity level for diagnostics.
const Severity = enum { err, warning, note }

/// Warning codes for lint rules.
const WarningCode = enum(u16) {
    w001 = 1,
    w002 = 2,
    w003 = 3,
    w004 = 4,
    w005 = 5,
}

impl WarningCode {
    fn code() int {
        return @intFromEnum(self)
    }

    fn description() string {
        return switch (self) {
            .w001 => "unused variable",
            .w002 => "unused parameter",
            .w003 => "variable shadowing",
            .w004 => "unreachable code",
            .w005 => "empty block",
        }
    }
}

/// Error codes: 1xx=scanner, 2xx=parser, 3xx=type, 4xx=semantic
const ErrorCode = enum(u16) {
    // Scanner
    e100 = 100, e101 = 101, e102 = 102, e103 = 103, e104 = 104,
    // Parser
    e200 = 200, e201 = 201, e202 = 202, e203 = 203, e204 = 204,
    e205 = 205, e206 = 206, e207 = 207, e208 = 208,
    // Type
    e300 = 300, e301 = 301, e302 = 302, e303 = 303, e304 = 304,
    e305 = 305, e306 = 306,
    // Semantic
    e400 = 400, e401 = 401, e402 = 402, e403 = 403,
}

impl ErrorCode {
    /// Return the numeric error code.
    fn code() int {
        return @intFromEnum(self)
    }

    /// Return a human-readable description for this error code.
    fn description() string {
        return switch (self) {
            .e100 => "unterminated string literal",
            .e101 => "unterminated character literal",
            .e102 => "invalid escape sequence",
            .e103 => "invalid number literal",
            .e104 => "unexpected character",
            .e200 => "unexpected token",
            .e201 => "expected expression",
            .e202 => "expected type",
            .e203 => "expected identifier",
            .e204 => "expected '{'",
            .e205 => "expected '}'",
            .e206 => "expected '('",
            .e207 => "expected ')'",
            .e208 => "expected ';' or newline",
            .e300 => "type mismatch",
            .e301 => "undefined identifier",
            .e302 => "redefined identifier",
            .e303 => "invalid operation",
            .e304 => "wrong number of arguments",
            .e305 => "not callable",
            .e306 => "field not found",
            .e400 => "break outside loop",
            .e401 => "continue outside loop",
            .e402 => "return type mismatch",
            .e403 => "missing return",
            else => "unknown error",
        }
    }
}

/// A single diagnostic error.
struct Diagnostic {
    offset: int,
    code: ErrorCode,
    msg: string,
}

/// A note attached to an error (secondary location).
struct Note {
    offset: int,
    msg: string,
}

/// Collects compilation errors with source location info.
struct ErrorReporter {
    count: int,
    warning_count: int,
    first_msg: string,
    first_code: ErrorCode,
    first_offset: int,
    suppressed: bool,
}

impl ErrorReporter {
    /// Create a fresh reporter with no errors.
    static fn init() ErrorReporter {
        return ErrorReporter {
            count: 0,
            warning_count: 0,
            first_msg: "",
            first_code: ErrorCode.e100,
            first_offset: 0,
            suppressed: false,
        }
    }

    /// Record an error.
    fn report(offset: int, code: ErrorCode, msg: string) void {
        if (self.count == 0) {
            self.first_msg = msg
            self.first_code = code
            self.first_offset = offset
        }
        self.count += 1
    }

    /// Record an error with a note (secondary location).
    fn reportWithNote(offset: int, code: ErrorCode, msg: string, note_offset: int, note_msg: string) void {
        self.report(offset, code, msg)
    }

    /// Record a warning.
    fn warningWithCode(offset: int, wc: WarningCode, msg: string) void {
        self.warning_count += 1
    }

    /// Whether any errors have been recorded.
    fn hasErrors() bool {
        return self.count > 0
    }

    /// Number of errors recorded.
    fn errorCount() int {
        return self.count
    }
}

/// Compute line and column (1-based) from a byte offset in source text.
fn offsetToLineCol(content: string, offset: int) (int, int) {
    var line = 1
    var col = 1
    var i = 0
    const len = @lenOf(content)
    while (i < len and i < offset) {
        if (charAt(content, i) == '\n') {
            line += 1
            col = 1
        } else {
            col += 1
        }
        i += 1
    }
    return (line, col)
}

/// Format a diagnostic as "filename:line:col: error[E###]: message"
fn formatDiagnostic(filename: string, content: string, diag: Diagnostic) string {
    const line, col = offsetToLineCol(content, diag.offset)
    return "${filename}:${line}:${col}: error[E${diag.code.code()}]: ${diag.msg}"
}

/// Write a formatted error to stderr.
fn printError(filename: string, content: string, offset: int, code: ErrorCode, msg: string) void {
    const line, col = offsetToLineCol(content, offset)
    const output = "${filename}:${line}:${col}: error[E${code.code()}]: ${msg}\n"
    fd_write(2, @ptrOf(output), @lenOf(output))
}

/// Write a formatted warning to stderr.
fn printWarning(filename: string, content: string, offset: int, wc: WarningCode, msg: string) void {
    const line, col = offsetToLineCol(content, offset)
    const output = "${filename}:${line}:${col}: warning[W${wc.code()}]: ${msg}\n"
    fd_write(2, @ptrOf(output), @lenOf(output))
}

// ============================================================================
// Tests
// ============================================================================

test "severity enum" {
    @assertEq(@intFromEnum(Severity.err), 0)
    @assertEq(@intFromEnum(Severity.warning), 1)
    @assertEq(@intFromEnum(Severity.note), 2)
}

test "warning code values" {
    @assertEq(WarningCode.w001.code(), 1)
    @assertEq(WarningCode.w005.code(), 5)
}

test "warning code descriptions" {
    @assertEq(WarningCode.w001.description(), "unused variable")
    @assertEq(WarningCode.w003.description(), "variable shadowing")
    @assertEq(WarningCode.w004.description(), "unreachable code")
}

test "error code values" {
    @assertEq(ErrorCode.e100.code(), 100)
    @assertEq(ErrorCode.e200.code(), 200)
    @assertEq(ErrorCode.e300.code(), 300)
    @assertEq(ErrorCode.e403.code(), 403)
}

test "error code descriptions" {
    @assertEq(ErrorCode.e100.description(), "unterminated string literal")
    @assertEq(ErrorCode.e200.description(), "unexpected token")
    @assertEq(ErrorCode.e301.description(), "undefined identifier")
    @assertEq(ErrorCode.e403.description(), "missing return")
}

test "note struct" {
    const n = Note { offset: 42, msg: "defined here" }
    @assertEq(n.offset, 42)
    @assertEq(n.msg, "defined here")
}

test "reporter init" {
    var r = ErrorReporter.init()
    @assertEq(r.hasErrors(), false)
    @assertEq(r.errorCount(), 0)
    @assertEq(r.warning_count, 0)
}

test "report single error" {
    var r = ErrorReporter.init()
    r.report(10, ErrorCode.e100, "unterminated string")
    @assertEq(r.hasErrors(), true)
    @assertEq(r.errorCount(), 1)
    @assertEq(r.first_offset, 10)
    @assertEq(r.first_msg, "unterminated string")
    @assertEq(r.first_code.code(), 100)
}

test "report multiple errors" {
    var r = ErrorReporter.init()
    r.report(0, ErrorCode.e200, "error 1")
    r.report(5, ErrorCode.e201, "error 2")
    r.report(10, ErrorCode.e300, "error 3")
    @assertEq(r.errorCount(), 3)
    @assertEq(r.first_msg, "error 1")
    @assertEq(r.first_offset, 0)
    @assertEq(r.first_code.code(), 200)
}

test "warning tracking" {
    var r = ErrorReporter.init()
    r.warningWithCode(5, WarningCode.w001, "unused x")
    @assertEq(r.warning_count, 1)
    @assertEq(r.hasErrors(), false)
}

test "offsetToLineCol first char" {
    const line, col = offsetToLineCol("hello\nworld", 0)
    @assertEq(line, 1)
    @assertEq(col, 1)
}

test "offsetToLineCol middle of first line" {
    const line, col = offsetToLineCol("hello\nworld", 3)
    @assertEq(line, 1)
    @assertEq(col, 4)
}

test "offsetToLineCol second line" {
    const line, col = offsetToLineCol("hello\nworld", 6)
    @assertEq(line, 2)
    @assertEq(col, 1)
}

test "offsetToLineCol third line" {
    const line, col = offsetToLineCol("a\nb\ncde", 5)
    @assertEq(line, 3)
    @assertEq(col, 2)
}

test "formatDiagnostic output" {
    const diag = Diagnostic { offset: 6, code: ErrorCode.e203, msg: "expected identifier" }
    const result = formatDiagnostic("test.cot", "hello\nworld", diag)
    @assertEq(result, "test.cot:2:1: error[E203]: expected identifier")
}
