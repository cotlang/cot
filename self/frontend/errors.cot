/// Error reporting for the self-hosted compiler.
/// Ported from compiler/frontend/errors.zig

import "std/string"

/// Error codes: 1xx=scanner, 2xx=parser, 3xx=type, 4xx=semantic
const ErrorCode = enum(u16) {
    // Scanner
    e100 = 100, e101 = 101, e102 = 102, e103 = 103, e104 = 104,
    // Parser
    e200 = 200, e201 = 201, e202 = 202, e203 = 203, e204 = 204,
    e205 = 205, e206 = 206, e207 = 207, e208 = 208,
    // Type
    e300 = 300, e301 = 301, e302 = 302, e303 = 303, e304 = 304,
    e305 = 305, e306 = 306,
    // Semantic
    e400 = 400, e401 = 401, e402 = 402, e403 = 403,
}

impl ErrorCode {
    /// Return the numeric error code.
    fn code() int {
        return @intFromEnum(self)
    }

    /// Return a human-readable description for this error code.
    fn description() string {
        return switch (self) {
            .e100 => "unterminated string literal",
            .e101 => "unterminated character literal",
            .e102 => "invalid escape sequence",
            .e103 => "invalid number literal",
            .e104 => "unexpected character",
            .e200 => "unexpected token",
            .e201 => "expected expression",
            .e202 => "expected type",
            .e203 => "expected identifier",
            .e204 => "expected '{'",
            .e205 => "expected '}'",
            .e206 => "expected '('",
            .e207 => "expected ')'",
            .e208 => "expected ';' or newline",
            .e300 => "type mismatch",
            .e301 => "undefined identifier",
            .e302 => "redefined identifier",
            .e303 => "invalid operation",
            .e304 => "wrong number of arguments",
            .e305 => "not callable",
            .e306 => "field not found",
            .e400 => "break outside loop",
            .e401 => "continue outside loop",
            .e402 => "return type mismatch",
            .e403 => "missing return",
            else => "unknown error",
        }
    }
}

/// A single diagnostic error.
struct Diagnostic {
    offset: int,
    code: ErrorCode,
    msg: string,
}

/// Collects compilation errors with source location info.
struct ErrorReporter {
    count: int,
    first_msg: string,
    first_code: ErrorCode,
    first_offset: int,
}

impl ErrorReporter {
    /// Create a fresh reporter with no errors.
    static fn init() ErrorReporter {
        return ErrorReporter {
            count: 0,
            first_msg: "",
            first_code: ErrorCode.e100,
            first_offset: 0,
        }
    }

    /// Record an error.
    fn report(offset: int, code: ErrorCode, msg: string) void {
        if (self.count == 0) {
            self.first_msg = msg
            self.first_code = code
            self.first_offset = offset
        }
        self.count = self.count + 1
    }

    /// Whether any errors have been recorded.
    fn hasErrors() bool {
        return self.count > 0
    }

    /// Number of errors recorded.
    fn errorCount() int {
        return self.count
    }
}

/// Compute line and column (1-based) from a byte offset in source text.
fn offsetToLineCol(content: string, offset: int) (int, int) {
    var line = 1
    var col = 1
    var i = 0
    const len = @lenOf(content)
    while (i < len and i < offset) {
        if (charAt(content, i) == '\n') {
            line = line + 1
            col = 1
        } else {
            col = col + 1
        }
        i = i + 1
    }
    return (line, col)
}

/// Format a diagnostic as "filename:line:col: error[E###]: message"
fn formatDiagnostic(filename: string, content: string, diag: Diagnostic) string {
    const line, col = offsetToLineCol(content, diag.offset)
    const loc = filename ++ ":" ++ intToString(line) ++ ":" ++ intToString(col)
    const code_str = "error[E" ++ intToString(diag.code.code()) ++ "]: "
    return loc ++ ": " ++ code_str ++ diag.msg
}

// ============================================================================
// Tests
// ============================================================================

test "error code values" {
    @assertEq(ErrorCode.e100.code(), 100)
    @assertEq(ErrorCode.e200.code(), 200)
    @assertEq(ErrorCode.e300.code(), 300)
    @assertEq(ErrorCode.e403.code(), 403)
}

test "error code descriptions" {
    @assertEq(ErrorCode.e100.description(), "unterminated string literal")
    @assertEq(ErrorCode.e200.description(), "unexpected token")
    @assertEq(ErrorCode.e301.description(), "undefined identifier")
    @assertEq(ErrorCode.e403.description(), "missing return")
}

test "reporter init" {
    var r = ErrorReporter.init()
    @assertEq(r.hasErrors(), false)
    @assertEq(r.errorCount(), 0)
}

test "report single error" {
    var r = ErrorReporter.init()
    r.report(10, ErrorCode.e100, "unterminated string")
    @assertEq(r.hasErrors(), true)
    @assertEq(r.errorCount(), 1)
    @assertEq(r.first_offset, 10)
    @assertEq(r.first_msg, "unterminated string")
    @assertEq(r.first_code.code(), 100)
}

test "report multiple errors" {
    var r = ErrorReporter.init()
    r.report(0, ErrorCode.e200, "error 1")
    r.report(5, ErrorCode.e201, "error 2")
    r.report(10, ErrorCode.e300, "error 3")
    @assertEq(r.errorCount(), 3)
    @assertEq(r.first_msg, "error 1")
    @assertEq(r.first_offset, 0)
    @assertEq(r.first_code.code(), 200)
}

test "offsetToLineCol first char" {
    const line, col = offsetToLineCol("hello\nworld", 0)
    @assertEq(line, 1)
    @assertEq(col, 1)
}

test "offsetToLineCol second line" {
    const line, col = offsetToLineCol("hello\nworld", 6)
    @assertEq(line, 2)
    @assertEq(col, 1)
}

test "offsetToLineCol third line" {
    const line, col = offsetToLineCol("a\nb\ncde", 5)
    @assertEq(line, 3)
    @assertEq(col, 2)
}

test "formatDiagnostic output" {
    const diag = Diagnostic { offset: 6, code: ErrorCode.e203, msg: "expected identifier" }
    const result = formatDiagnostic("test.cot", "hello\nworld", diag)
    @assertEq(result, "test.cot:2:1: error[E203]: expected identifier")
}
