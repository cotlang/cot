/// Error reporting for the self-hosted compiler.
/// Ported from compiler/frontend/errors.zig

import "std/string"
import "std/sys"
import "source"

/// Severity level for diagnostics.
const Severity = enum { err, warning, note }

/// Warning codes for lint rules.
const WarningCode = enum(u16) {
    w001 = 1,
    w002 = 2,
    w003 = 3,
    w004 = 4,
    w005 = 5,
}

impl WarningCode {
    fn code() int {
        return @intFromEnum(self)
    }

    fn description() string {
        return switch (self) {
            .w001 => "unused variable",
            .w002 => "unused parameter",
            .w003 => "variable shadowing",
            .w004 => "unreachable code",
            .w005 => "empty block",
        }
    }
}

/// Error codes: 1xx=scanner, 2xx=parser, 3xx=type, 4xx=semantic
const ErrorCode = enum(u16) {
    // Scanner
    e100 = 100, e101 = 101, e102 = 102, e103 = 103, e104 = 104,
    // Parser
    e200 = 200, e201 = 201, e202 = 202, e203 = 203, e204 = 204,
    e205 = 205, e206 = 206, e207 = 207, e208 = 208,
    // Type
    e300 = 300, e301 = 301, e302 = 302, e303 = 303, e304 = 304,
    e305 = 305, e306 = 306,
    // Semantic
    e400 = 400, e401 = 401, e402 = 402, e403 = 403,
}

impl ErrorCode {
    /// Return the numeric error code.
    fn code() int {
        return @intFromEnum(self)
    }

    /// Return a human-readable description for this error code.
    fn description() string {
        return switch (self) {
            .e100 => "unterminated string literal",
            .e101 => "unterminated character literal",
            .e102 => "invalid escape sequence",
            .e103 => "invalid number literal",
            .e104 => "unexpected character",
            .e200 => "unexpected token",
            .e201 => "expected expression",
            .e202 => "expected type",
            .e203 => "expected identifier",
            .e204 => "expected '{'",
            .e205 => "expected '}'",
            .e206 => "expected '('",
            .e207 => "expected ')'",
            .e208 => "expected ';' or newline",
            .e300 => "type mismatch",
            .e301 => "undefined identifier",
            .e302 => "redefined identifier",
            .e303 => "invalid operation",
            .e304 => "wrong number of arguments",
            .e305 => "not callable",
            .e306 => "field not found",
            .e400 => "break outside loop",
            .e401 => "continue outside loop",
            .e402 => "return type mismatch",
            .e403 => "missing return",
            else => "unknown error",
        }
    }
}

/// A note attached to an error (secondary location).
struct Note {
    span: Span,
    msg: string,
}

/// A unified diagnostic error (Zig: Error struct in errors.zig).
struct Error {
    span: Span,
    msg: string,
    err_code: int,
    severity: int,
    warning_code: int,
    note_span: Span,
    note_msg: string,
    has_note: bool,
}

/// Maximum errors before suppression.
const MAX_ERRORS: int = 10

/// Factory functions for Error construction.
fn errorAt(offset: int, msg: string) Error {
    return Error {
        span: Span.fromPos(offset),
        msg: msg,
        err_code: -1,
        severity: 0,
        warning_code: -1,
        note_span: Span.zero(),
        note_msg: "",
        has_note: false,
    }
}

fn errorWithCode(offset: int, code: ErrorCode, msg: string) Error {
    return Error {
        span: Span.fromPos(offset),
        msg: msg,
        err_code: @intFromEnum(code),
        severity: 0,
        warning_code: -1,
        note_span: Span.zero(),
        note_msg: "",
        has_note: false,
    }
}

fn errorWithCodeAndNote(offset: int, code: ErrorCode, msg: string, note_offset: int, note_msg: string) Error {
    return Error {
        span: Span.fromPos(offset),
        msg: msg,
        err_code: @intFromEnum(code),
        severity: 0,
        warning_code: -1,
        note_span: Span.fromPos(note_offset),
        note_msg: note_msg,
        has_note: true,
    }
}

fn warnError(offset: int, wc: WarningCode, msg: string) Error {
    return Error {
        span: Span.fromPos(offset),
        msg: msg,
        err_code: -1,
        severity: 1,
        warning_code: @intFromEnum(wc),
        note_span: Span.zero(),
        note_msg: "",
        has_note: false,
    }
}

/// Collects compilation errors with source location info.
/// Zig reference: ErrorReporter in errors.zig
struct ErrorReporter {
    count: int,
    warning_count: int,
    suppressed: bool,
    has_first: bool,
    first_msg: string,
    first_code: ErrorCode,
    first_offset: int,
    has_source: bool,
    src_filename: string,
    src_content: string,
    // Error collection mode (for LSP and test harnesses).
    // When collect_mode is true, errors are stored in collected_errors
    // instead of being printed to stderr.
    collect_mode: bool,
    collected_errors: List(Error),
}

impl ErrorReporter {
    /// Create a fresh reporter with no errors (no source — for tests).
    static fn init() ErrorReporter {
        var collected: List(Error) = .{}
        return ErrorReporter {
            count: 0,
            warning_count: 0,
            suppressed: false,
            has_first: false,
            first_msg: "",
            first_code: ErrorCode.e100,
            first_offset: 0,
            has_source: false,
            src_filename: "",
            src_content: "",
            collect_mode: false,
            collected_errors: collected,
        }
    }

    /// Create a reporter with source context (for rendering errors).
    static fn initWithSource(filename: string, content: string) ErrorReporter {
        var collected: List(Error) = .{}
        return ErrorReporter {
            count: 0,
            warning_count: 0,
            suppressed: false,
            has_first: false,
            first_msg: "",
            first_code: ErrorCode.e100,
            first_offset: 0,
            has_source: true,
            src_filename: filename,
            src_content: content,
            collect_mode: false,
            collected_errors: collected,
        }
    }

    /// Create a reporter in collect mode (for LSP and test harnesses).
    /// Errors are stored in collected_errors instead of printed to stderr.
    static fn initCollecting() ErrorReporter {
        var collected: List(Error) = .{}
        return ErrorReporter {
            count: 0,
            warning_count: 0,
            suppressed: false,
            has_first: false,
            first_msg: "",
            first_code: ErrorCode.e100,
            first_offset: 0,
            has_source: false,
            src_filename: "",
            src_content: "",
            collect_mode: true,
            collected_errors: collected,
        }
    }

    /// Record an error (3-arg convenience wrapper — keeps ~100+ call sites unchanged).
    fn report(offset: int, code: ErrorCode, msg: string) void {
        self.reportError(errorWithCode(offset, code, msg))
    }

    /// Record an error with a note (secondary location).
    fn reportWithNote(offset: int, code: ErrorCode, msg: string, note_offset: int, note_msg: string) void {
        self.reportError(errorWithCodeAndNote(offset, code, msg, note_offset, note_msg))
    }

    /// Record a warning. Zig: warningWithCode renders to stderr.
    fn warningWithCode(offset: int, wc: WarningCode, msg: string) void {
        self.warning_count += 1
        const err = warnError(offset, wc, msg)
        if (self.collect_mode) {
            self.collected_errors.append(err)
        } else if (self.has_source) {
            self.printErr(err)
        }
    }

    /// Core report method (Zig: report(self, err)).
    fn reportError(err: Error) void {
        if (!self.has_first) {
            self.has_first = true
            self.first_msg = err.msg
            self.first_offset = err.span.start
            if (err.err_code >= 0) {
                self.first_code = @enumFromInt(ErrorCode, err.err_code)
            }
        }
        self.count += 1

        if (self.count > MAX_ERRORS) {
            if (!self.suppressed) {
                self.suppressed = true
                if (!self.collect_mode) {
                    const too_many = "error: too many errors, stopping\n"
                    fd_write(2, @ptrOf(too_many), @lenOf(too_many))
                }
            }
            return
        }

        if (self.collect_mode) {
            self.collected_errors.append(err)
        } else if (self.has_source) {
            self.printErr(err)
        }
    }

    /// Render a diagnostic to stderr with source context.
    /// Zig reference: printError in errors.zig
    fn printErr(err: Error) void {
        const line, col = offsetToLineCol(self.src_content, err.span.start)

        // Severity label + code
        if (err.severity == 1) {
            // Warning
            if (err.warning_code >= 0) {
                const output = "${self.src_filename}:${line}:${col}: warning[W${err.warning_code}]: ${err.msg}\n"
                fd_write(2, @ptrOf(output), @lenOf(output))
            } else {
                const output = "${self.src_filename}:${line}:${col}: warning: ${err.msg}\n"
                fd_write(2, @ptrOf(output), @lenOf(output))
            }
        } else {
            // Error
            if (err.err_code >= 0) {
                const output = "${self.src_filename}:${line}:${col}: error[E${err.err_code}]: ${err.msg}\n"
                fd_write(2, @ptrOf(output), @lenOf(output))
            } else {
                const output = "${self.src_filename}:${line}:${col}: error: ${err.msg}\n"
                fd_write(2, @ptrOf(output), @lenOf(output))
            }
        }

        // Source line
        const source_line = getSourceLine(self.src_content, err.span.start)
        const line_output = "    ${source_line}\n"
        fd_write(2, @ptrOf(line_output), @lenOf(line_output))

        // Underline caret
        var spaces = ""
        var i = 1
        while (i < col) {
            spaces = "${spaces} "
            i += 1
        }
        const caret_output = "    ${spaces}^\n"
        fd_write(2, @ptrOf(caret_output), @lenOf(caret_output))

        // Note (if present)
        if (err.has_note) {
            const note_line, note_col = offsetToLineCol(self.src_content, err.note_span.start)
            const note_output = "${self.src_filename}:${note_line}:${note_col}: note: ${err.note_msg}\n"
            fd_write(2, @ptrOf(note_output), @lenOf(note_output))
        }
    }

    /// Whether any errors have been recorded.
    fn hasErrors() bool {
        return self.count > 0
    }

    /// Number of errors recorded.
    fn errorCount() int {
        return self.count
    }
}

/// Compute line and column (1-based) from a byte offset in source text.
fn offsetToLineCol(content: string, offset: int) (int, int) {
    var line = 1
    var col = 1
    var i = 0
    const len = @lenOf(content)
    while (i < len and i < offset) {
        if (charAt(content, i) == '\n') {
            line += 1
            col = 1
        } else {
            col += 1
        }
        i += 1
    }
    return (line, col)
}

/// Extract the source line containing the given offset.
fn getSourceLine(content: string, offset: int) string {
    const len = @lenOf(content)
    // Find line start
    var start = offset
    while (start > 0 and charAt(content, start - 1) != '\n') {
        start -= 1
    }
    // Find line end
    var end = offset
    while (end < len and charAt(content, end) != '\n') {
        end += 1
    }
    return substring(content, start, end)
}

/// Format a diagnostic as "filename:line:col: error[E###]: message"
fn formatDiagnostic(filename: string, content: string, diag: Diagnostic) string {
    const line, col = offsetToLineCol(content, diag.offset)
    return "${filename}:${line}:${col}: error[E${diag.code.code()}]: ${diag.msg}"
}

/// A single diagnostic error (legacy — kept for formatDiagnostic test compat).
struct Diagnostic {
    offset: int,
    code: ErrorCode,
    msg: string,
}

// ============================================================================
// Tests
// ============================================================================

test "severity enum" {
    @assertEq(@intFromEnum(Severity.err), 0)
    @assertEq(@intFromEnum(Severity.warning), 1)
    @assertEq(@intFromEnum(Severity.note), 2)
}

test "warning code values" {
    @assertEq(WarningCode.w001.code(), 1)
    @assertEq(WarningCode.w005.code(), 5)
}

test "warning code descriptions" {
    @assertEq(WarningCode.w001.description(), "unused variable")
    @assertEq(WarningCode.w003.description(), "variable shadowing")
    @assertEq(WarningCode.w004.description(), "unreachable code")
}

test "error code values" {
    @assertEq(ErrorCode.e100.code(), 100)
    @assertEq(ErrorCode.e200.code(), 200)
    @assertEq(ErrorCode.e300.code(), 300)
    @assertEq(ErrorCode.e403.code(), 403)
}

test "error code descriptions" {
    @assertEq(ErrorCode.e100.description(), "unterminated string literal")
    @assertEq(ErrorCode.e200.description(), "unexpected token")
    @assertEq(ErrorCode.e301.description(), "undefined identifier")
    @assertEq(ErrorCode.e403.description(), "missing return")
}

test "note struct" {
    const n = Note { span: Span.fromPos(42), msg: "defined here" }
    @assertEq(n.span.start, 42)
    @assertEq(n.msg, "defined here")
}

test "error struct factory at" {
    const err = errorAt(10, "test error")
    @assertEq(err.span.start, 10)
    @assertEq(err.msg, "test error")
    @assertEq(err.err_code, -1)
    @assertEq(err.severity, 0)
    @assertEq(err.has_note, false)
}

test "error struct factory withCode" {
    const err = errorWithCode(20, ErrorCode.e200, "bad token")
    @assertEq(err.span.start, 20)
    @assertEq(err.msg, "bad token")
    @assertEq(err.err_code, 200)
    @assertEq(err.severity, 0)
}

test "error struct factory withCodeAndNote" {
    const err = errorWithCodeAndNote(30, ErrorCode.e302, "redefined", 5, "defined here")
    @assertEq(err.span.start, 30)
    @assertEq(err.msg, "redefined")
    @assertEq(err.err_code, 302)
    @assertEq(err.has_note, true)
    @assertEq(err.note_span.start, 5)
    @assertEq(err.note_msg, "defined here")
}

test "error struct factory warn" {
    const err = warnError(15, WarningCode.w001, "unused x")
    @assertEq(err.span.start, 15)
    @assertEq(err.severity, 1)
    @assertEq(err.warning_code, 1)
}

test "reporter init" {
    var r = ErrorReporter.init()
    @assertEq(r.hasErrors(), false)
    @assertEq(r.errorCount(), 0)
    @assertEq(r.warning_count, 0)
}

test "report single error" {
    var r = ErrorReporter.init()
    r.report(10, ErrorCode.e100, "unterminated string")
    @assertEq(r.hasErrors(), true)
    @assertEq(r.errorCount(), 1)
    @assertEq(r.first_offset, 10)
    @assertEq(r.first_msg, "unterminated string")
    @assertEq(r.first_code.code(), 100)
}

test "report multiple errors" {
    var r = ErrorReporter.init()
    r.report(0, ErrorCode.e200, "error 1")
    r.report(5, ErrorCode.e201, "error 2")
    r.report(10, ErrorCode.e300, "error 3")
    @assertEq(r.errorCount(), 3)
    @assertEq(r.first_msg, "error 1")
    @assertEq(r.first_offset, 0)
    @assertEq(r.first_code.code(), 200)
}

test "warning tracking" {
    var r = ErrorReporter.init()
    r.warningWithCode(5, WarningCode.w001, "unused x")
    @assertEq(r.warning_count, 1)
    @assertEq(r.hasErrors(), false)
}

test "max errors suppression" {
    var r = ErrorReporter.init()
    var i = 0
    while (i < 15) {
        r.report(i, ErrorCode.e200, "error")
        i += 1
    }
    @assertEq(r.errorCount(), 15)
    @assertEq(r.suppressed, true)
}

test "offsetToLineCol first char" {
    const line, col = offsetToLineCol("hello\nworld", 0)
    @assertEq(line, 1)
    @assertEq(col, 1)
}

test "offsetToLineCol middle of first line" {
    const line, col = offsetToLineCol("hello\nworld", 3)
    @assertEq(line, 1)
    @assertEq(col, 4)
}

test "offsetToLineCol second line" {
    const line, col = offsetToLineCol("hello\nworld", 6)
    @assertEq(line, 2)
    @assertEq(col, 1)
}

test "offsetToLineCol third line" {
    const line, col = offsetToLineCol("a\nb\ncde", 5)
    @assertEq(line, 3)
    @assertEq(col, 2)
}

test "getSourceLine first line" {
    @assertEq(getSourceLine("hello\nworld", 0), "hello")
    @assertEq(getSourceLine("hello\nworld", 3), "hello")
}

test "getSourceLine second line" {
    @assertEq(getSourceLine("hello\nworld", 6), "world")
}

test "formatDiagnostic output" {
    const diag = Diagnostic { offset: 6, code: ErrorCode.e203, msg: "expected identifier" }
    const result = formatDiagnostic("test.cot", "hello\nworld", diag)
    @assertEq(result, "test.cot:2:1: error[E203]: expected identifier")
}

test "reportWithNote stores first error" {
    var r = ErrorReporter.init()
    r.reportWithNote(30, ErrorCode.e302, "redefined", 5, "defined here")
    @assertEq(r.hasErrors(), true)
    @assertEq(r.errorCount(), 1)
    @assertEq(r.first_offset, 30)
    @assertEq(r.first_msg, "redefined")
}

test "initWithSource has source" {
    var r = ErrorReporter.initWithSource("test.cot", "fn main() {}\n")
    @assertEq(r.has_source, true)
    @assertEq(r.src_filename, "test.cot")
    @assertEq(r.hasErrors(), false)
}
