/// Error reporting for the self-hosted compiler.
/// Ported from compiler/frontend/errors.zig

/// Error codes: 1xx=scanner, 2xx=parser, 3xx=type, 4xx=semantic
const ErrorCode = enum(u16) {
    // Scanner
    e100 = 100, e101 = 101, e102 = 102, e103 = 103, e104 = 104,
    // Parser
    e200 = 200, e201 = 201, e202 = 202, e203 = 203, e204 = 204,
    e205 = 205, e206 = 206, e207 = 207, e208 = 208,
    // Type
    e300 = 300, e301 = 301, e302 = 302, e303 = 303, e304 = 304,
    e305 = 305, e306 = 306,
    // Semantic
    e400 = 400, e401 = 401, e402 = 402, e403 = 403,
}

impl ErrorCode {
    /// Return the numeric error code.
    fn code() int {
        return @intFromEnum(self)
    }

    /// Return a human-readable description for this error code.
    fn description() string {
        return switch (self) {
            .e100 => "unterminated string literal",
            .e101 => "unterminated character literal",
            .e102 => "invalid escape sequence",
            .e103 => "invalid number literal",
            .e104 => "unexpected character",
            .e200 => "unexpected token",
            .e201 => "expected expression",
            .e202 => "expected type",
            .e203 => "expected identifier",
            .e204 => "expected '{'",
            .e205 => "expected '}'",
            .e206 => "expected '('",
            .e207 => "expected ')'",
            .e208 => "expected ';' or newline",
            .e300 => "type mismatch",
            .e301 => "undefined identifier",
            .e302 => "redefined identifier",
            .e303 => "invalid operation",
            .e304 => "wrong number of arguments",
            .e305 => "not callable",
            .e306 => "field not found",
            .e400 => "break outside loop",
            .e401 => "continue outside loop",
            .e402 => "return type mismatch",
            .e403 => "missing return",
            else => "unknown error",
        }
    }
}

/// Collects compilation errors with first-error detail.
struct ErrorReporter {
    count: int,
    first_msg: string,
    first_code: ErrorCode,
    first_offset: int,
}

/// Create a fresh reporter with no errors.
fn reporterInit() ErrorReporter {
    return ErrorReporter {
        count: 0,
        first_msg: "",
        first_code: ErrorCode.e100,
        first_offset: 0,
    }
}

impl ErrorReporter {
    /// Record an error. First error's details are preserved.
    fn report(offset: int, code: ErrorCode, msg: string) void {
        if (self.count == 0) {
            self.first_msg = msg
            self.first_code = code
            self.first_offset = offset
        }
        self.count = self.count + 1
    }

    /// Whether any errors have been recorded.
    fn hasErrors() bool {
        return self.count > 0
    }

    /// Number of errors recorded.
    fn errorCount() int {
        return self.count
    }
}

// ============================================================================
// Tests
// ============================================================================

test "error code values" {
    @assertEq(ErrorCode.e100.code(), 100)
    @assertEq(ErrorCode.e200.code(), 200)
    @assertEq(ErrorCode.e300.code(), 300)
    @assertEq(ErrorCode.e403.code(), 403)
}

test "error code descriptions" {
    @assertEq(ErrorCode.e100.description(), "unterminated string literal")
    @assertEq(ErrorCode.e200.description(), "unexpected token")
    @assertEq(ErrorCode.e301.description(), "undefined identifier")
    @assertEq(ErrorCode.e403.description(), "missing return")
}

test "reporter init" {
    var r = reporterInit()
    @assertEq(r.hasErrors(), false)
    @assertEq(r.errorCount(), 0)
}

test "report single error" {
    var r = reporterInit()
    r.report(10, ErrorCode.e100, "unterminated string")
    @assertEq(r.hasErrors(), true)
    @assertEq(r.errorCount(), 1)
    @assertEq(r.first_offset, 10)
    @assertEq(r.first_msg, "unterminated string")
    @assertEq(r.first_code.code(), 100)
}

test "report multiple errors" {
    var r = reporterInit()
    r.report(0, ErrorCode.e200, "error 1")
    r.report(5, ErrorCode.e201, "error 2")
    r.report(10, ErrorCode.e300, "error 3")
    @assertEq(r.errorCount(), 3)
    @assertEq(r.first_msg, "error 1")
    @assertEq(r.first_offset, 0)
    @assertEq(r.first_code.code(), 200)
}
