/// Recursive descent parser for the self-hosted Cot compiler.
/// Ported from compiler/frontend/parser.zig
///
/// Produces a flat-encoded AST (see ast.cot) from a token stream.
/// Uses precedence climbing for binary expressions.

import "std/list"
import "std/string"
import "scanner"
import "token"
import "errors"
import "ast"

const MAX_NEST: int = 10000

// ============================================================================
// Parser state
// ============================================================================

struct Parser {
    scanner: *Scanner,
    ast: *Ast,
    errors: *ErrorReporter,
    tok: int,          // current token tag (Token enum as int)
    tok_text: string,  // current token text
    tok_start: int,    // current token start offset
    tok_end: int,      // current token end offset
    peek_tok: int,     // lookahead token tag (0 = not populated)
    peek_text: string,
    peek_start: int,
    peek_end: int,
    has_peek: bool,
    safe_mode: bool,
    current_impl_type: string,
    current_impl_is_generic: bool,
    nest_level: int,
    pending_doc: string,
}

/// Create a new parser. Caller must call advance() once before parsing.
fn parserInit(scanner: *Scanner, ast: *Ast, errors: *ErrorReporter) Parser {
    var p = Parser {
        scanner: scanner,
        ast: ast,
        errors: errors,
        tok: 0,
        tok_text: "",
        tok_start: 0,
        tok_end: 0,
        peek_tok: 0,
        peek_text: "",
        peek_start: 0,
        peek_end: 0,
        has_peek: false,
        safe_mode: false,
        current_impl_type: "",
        current_impl_is_generic: false,
        nest_level: 0,
        pending_doc: "",
    }
    // Prime the first token
    p.advance()
    return p
}

impl Parser {

    // ================================================================
    // Core navigation helpers
    // ================================================================

    /// Advance to the next token.
    fn advance() void {
        if (self.has_peek) {
            self.tok = self.peek_tok
            self.tok_text = self.peek_text
            self.tok_start = self.peek_start
            self.tok_end = self.peek_end
            self.has_peek = false
        } else {
            const info = self.scanner.scanNext()
            self.tok = info.tok
            self.tok_text = info.text
            self.tok_start = info.start_offset
            self.tok_end = info.end_offset
        }
    }

    /// Peek at the next token without consuming it.
    fn peekToken() int {
        if (!self.has_peek) {
            const info = self.scanner.scanNext()
            self.peek_tok = info.tok
            self.peek_text = info.text
            self.peek_start = info.start_offset
            self.peek_end = info.end_offset
            self.has_peek = true
        }
        return self.peek_tok
    }

    /// If current token matches, consume it and return true.
    fn match(t: int) bool {
        if (self.tok == t) {
            self.advance()
            return true
        }
        return false
    }

    /// Expect a specific token. Consume it and return true, or report error.
    fn expect(t: int) bool {
        if (self.tok == t) {
            self.advance()
            return true
        }
        self.errors.report(self.tok_start, ErrorCode.e200, "unexpected token")
        return false
    }

    /// Get a Span from start to end.
    fn spanSE(start: int, end: int) Span {
        return Span { start: start, end: end }
    }

    // ================================================================
    // Doc comment accumulation
    // ================================================================

    fn collectDocComment() void {
        if (self.tok != @intFromEnum(Token.doc_comment)) {
            self.pending_doc = ""
            return
        }
        self.pending_doc = self.tok_text
        self.advance()
        while (self.tok == @intFromEnum(Token.doc_comment)) {
            self.advance()
        }
    }

    fn consumeDocComment() string {
        const doc = self.pending_doc
        self.pending_doc = ""
        return doc
    }

    // ================================================================
    // Phase A: File + simplest declarations
    // ================================================================

    /// Parse an entire file. Populates ast.file_decls.
    fn parseFile() void {
        // Check for @safe annotation
        if (self.tok == @intFromEnum(Token.at)) {
            const pk = self.peekToken()
            if (pk == @intFromEnum(Token.ident)) {
                // Note: can't check peek_text == "safe" easily here
                // For now, any @ident at file start sets safe mode
                self.advance()  // consume @
                self.advance()  // consume safe
                self.safe_mode = true
            }
        }
        while (self.tok != @intFromEnum(Token.eof)) {
            self.collectDocComment()
            if (self.tok == @intFromEnum(Token.eof)) {
                break
            }
            const decl = self.parseDecl()
            if (decl != null_node) {
                self.ast.addFileDecl(decl)
            } else {
                self.advance()
            }
        }
    }

    /// Parse a top-level declaration.
    fn parseDecl() int {
        const tok = @as(Token, @enumFromInt(self.tok))
        return switch (tok) {
            Token.kw_import => self.parseImportDecl(),
            Token.kw_test => self.parseTestDecl(),
            Token.kw_bench => self.parseBenchDecl(),
            Token.kw_fn => self.parseFnDecl(0, 0),
            Token.kw_const => self.parseVarDecl(1),
            Token.kw_var => self.parseVarDecl(0),
            Token.kw_let => self.parseVarDecl(0),
            Token.kw_struct => self.parseStructDecl(0),
            Token.kw_packed => self.parsePackedStructDecl(),
            Token.kw_extern => self.parseExternDecl(),
            Token.kw_enum => self.parseEnumDecl(),
            Token.kw_union => self.parseUnionDecl(),
            Token.kw_impl => self.parseImplBlock(),
            Token.kw_trait => self.parseTraitDecl(),
            Token.kw_type => self.parseTypeAlias(),
            Token.kw_async => self.parseAsyncFn(),
            else => {
                self.errors.report(self.tok_start, ErrorCode.e200, "expected declaration")
                null_node
            },
        }
    }

    /// import "path"
    fn parseImportDecl() int {
        const start = self.tok_start
        self.advance()  // consume 'import'
        if (self.tok != @intFromEnum(Token.string_lit)) {
            self.errors.report(self.tok_start, ErrorCode.e200, "expected string after import")
            return null_node
        }
        const path = self.tok_text
        self.advance()  // consume string
        return self.ast.addImportDecl(path, self.spanSE(start, self.tok_end))
    }

    /// test "name" { body }
    fn parseTestDecl() int {
        const start = self.tok_start
        self.advance()  // consume 'test'
        if (self.tok != @intFromEnum(Token.string_lit)) {
            self.errors.report(self.tok_start, ErrorCode.e200, "expected test name string")
            return null_node
        }
        const name = self.tok_text
        self.advance()  // consume name
        const body = self.parseBlock()
        return self.ast.addTestDecl(name, body, self.spanSE(start, self.tok_end))
    }

    /// bench "name" { body }
    fn parseBenchDecl() int {
        const start = self.tok_start
        self.advance()  // consume 'bench'
        if (self.tok != @intFromEnum(Token.string_lit)) {
            self.errors.report(self.tok_start, ErrorCode.e200, "expected bench name string")
            return null_node
        }
        const name = self.tok_text
        self.advance()  // consume name
        const body = self.parseBlock()
        return self.ast.addBenchDecl(name, body, self.spanSE(start, self.tok_end))
    }

    /// fn name(T)(params) return_type { body }
    fn parseFnDecl(is_extern: int, is_async: int) int {
        const start = self.tok_start
        const doc = self.consumeDocComment()
        self.advance()  // consume 'fn'
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected function name")
            return null_node
        }
        const name = self.tok_text
        self.advance()  // consume name

        // Ported from parser.zig:250-270: fn max(T)(a: T, b: T) T
        // First '(' is consumed, then we distinguish type params from regular params:
        // bare idents (no ':') = type params; ident followed by ':' = regular params.
        if (!self.expect(@intFromEnum(Token.lparen))) {
            return null_node
        }

        var type_params: List(string) = undefined
        type_params.items = 0
        type_params.count = 0
        type_params.capacity = 0
        if (self.tok == @intFromEnum(Token.ident) and self.peekToken() != @intFromEnum(Token.colon)) {
            // Type parameters: (T) or (T, U)
            while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
                if (self.tok != @intFromEnum(Token.ident)) {
                    self.errors.report(self.tok_start, ErrorCode.e203, "expected type parameter name")
                    return null_node
                }
                type_params.append(self.tok_text)
                self.advance()
                if (!self.match(@intFromEnum(Token.comma))) {
                    break
                }
            }
            if (!self.expect(@intFromEnum(Token.rparen))) {
                return null_node
            }
            // Expect second ( for value parameters
            if (!self.expect(@intFromEnum(Token.lparen))) {
                return null_node
            }
        }

        // Regular parameters (lparen already consumed above)
        var params: List(int) = undefined
        params.items = 0
        params.count = 0
        params.capacity = 0
        while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
            const param_node = self.parseFieldDef()
            if (param_node != null_node) {
                params.append(param_node)
            }
            if (!self.match(@intFromEnum(Token.comma))) {
                break
            }
        }
        if (!self.expect(@intFromEnum(Token.rparen))) {
            return null_node
        }

        // @safe implicit self: inject `self: TypeName` if in impl block
        if (self.safe_mode and @lenOf(self.current_impl_type) > 0 and !self.current_impl_is_generic) {
            // Check if first param is already named "self"
            var needs_self = true
            if (params.count > 0) {
                const first_tag = self.ast.getTag(params.get(0))
                if (first_tag == @intFromEnum(NodeTag.field_def)) {
                    const first_name = self.ast.getStr(self.ast.getData(params.get(0), 0))
                    if (strEqual(first_name, "self")) {
                        needs_self = false
                    }
                }
            }
            if (needs_self) {
                // Create self param with type = current_impl_type
                const self_type = self.ast.addIdent(self.current_impl_type, self.spanSE(start, start))
                const self_param = self.ast.addFieldDef("self", self_type, null_node, "", self.spanSE(start, start))
                // Prepend self to params
                var new_params: List(int) = undefined
                new_params.items = 0
                new_params.count = 0
                new_params.capacity = 0
                new_params.append(self_param)
                var pi = 0
                while (pi < params.count) {
                    new_params.append(params.get(pi))
                    pi = pi + 1
                }
                params = new_params
            }
        }

        // Return type — skip if at '{', eof, or 'where'
        // Ported from parser.zig:294-295
        var ret_type = null_node
        if (self.tok != @intFromEnum(Token.lbrace) and self.tok != @intFromEnum(Token.eof) and self.tok != @intFromEnum(Token.kw_where)) {
            ret_type = self.parseType()
        }

        // Where clause: fn sort(T)(list: *List(T)) void where T: Ord
        // Ported from parser.zig:299-321
        var type_param_bounds: List(string) = undefined
        type_param_bounds.items = 0
        type_param_bounds.count = 0
        type_param_bounds.capacity = 0
        if (self.tok == @intFromEnum(Token.kw_where) and type_params.len() > 0) {
            // Initialize bounds array with "" for each type param
            var bi = 0
            while (bi < type_params.len()) {
                type_param_bounds.append("")
                bi = bi + 1
            }
            self.advance()  // consume 'where'
            while (self.tok == @intFromEnum(Token.ident)) {
                const param_name = self.tok_text
                self.advance()
                if (!self.expect(@intFromEnum(Token.colon))) {
                    break
                }
                if (self.tok != @intFromEnum(Token.ident)) {
                    self.errors.report(self.tok_start, ErrorCode.e203, "expected trait name after ':'")
                    break
                }
                const trait_name = self.tok_text
                self.advance()
                // Find matching type param and set its bound
                var wi = 0
                while (wi < type_params.len()) {
                    if (strEqual(type_params.get(wi), param_name)) {
                        type_param_bounds.set(wi, trait_name)
                        break
                    }
                    wi = wi + 1
                }
                if (!self.match(@intFromEnum(Token.comma))) {
                    break
                }
            }
        }

        // Body (optional for extern)
        var body = null_node
        if (self.tok == @intFromEnum(Token.lbrace)) {
            body = self.parseBlock()
        }

        return self.ast.addFnDecl(name, ret_type, body, is_extern, is_async, doc, params, type_params, type_param_bounds, self.spanSE(start, self.tok_end))
    }

    /// const/var name: Type = value
    /// Also handles: const Name = enum { ... }, const Name = error { ... }
    fn parseVarDecl(is_const: int) int {
        const start = self.tok_start
        const doc = self.consumeDocComment()
        self.advance()  // consume const/var/let
        if (self.tok != @intFromEnum(Token.ident)) {
            // Could be destructuring: const a, b = ...
            return self.parseDestructureDecl(is_const, start, doc)
        }
        const name = self.tok_text
        const name_start = self.tok_start
        self.advance()  // consume name

        // Optional type annotation
        var type_expr = null_node
        if (self.match(@intFromEnum(Token.colon))) {
            type_expr = self.parseType()
        }

        // Destructuring: const a, b = expr
        if (self.tok == @intFromEnum(Token.comma)) {
            return self.parseDestructureDeclFrom(name, type_expr, name_start, start, is_const, doc)
        }

        // Check for inline type declarations: const Name = enum { ... } or const Name = enum(u8) { ... }
        // Ported from parser.zig:1678-1716 — full state save/restore backtracking
        if (is_const == 1 and self.tok == @intFromEnum(Token.assign)) {
            // Save parser + scanner state for backtracking
            const saved_tok = self.tok
            const saved_tok_text = self.tok_text
            const saved_tok_start = self.tok_start
            const saved_tok_end = self.tok_end
            const saved_has_peek = self.has_peek
            const saved_peek_tok = self.peek_tok
            const saved_peek_text = self.peek_text
            const saved_peek_start = self.peek_start
            const saved_peek_end = self.peek_end
            const saved_scan_pos = self.scanner.pos
            const saved_scan_ch = self.scanner.ch

            self.advance()  // consume '='

            if (self.tok == @intFromEnum(Token.kw_enum)) {
                self.advance()  // consume 'enum'
                var backing = null_node
                if (self.match(@intFromEnum(Token.lparen))) {
                    backing = self.parseType()
                    self.expect(@intFromEnum(Token.rparen))
                }
                if (!self.expect(@intFromEnum(Token.lbrace))) {
                    return null_node
                }
                var variants: List(int) = undefined
                variants.items = 0
                variants.count = 0
                variants.capacity = 0
                while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
                    const vstart = self.tok_start
                    if (self.tok == @intFromEnum(Token.at)) {
                        self.advance()
                    }
                    if (self.tok != @intFromEnum(Token.ident) and self.tok != @intFromEnum(Token.string_lit)) {
                        self.errors.report(self.tok_start, ErrorCode.e203, "expected variant name")
                        break
                    }
                    const vname = self.tok_text
                    self.advance()
                    var vval = null_node
                    if (self.match(@intFromEnum(Token.assign))) {
                        vval = self.parseExpr()
                    }
                    variants.append(self.ast.addEnumVariant(vname, vval, self.spanSE(vstart, self.tok_end)))
                    self.match(@intFromEnum(Token.comma))
                }
                self.expect(@intFromEnum(Token.rbrace))
                return self.ast.addEnumDecl(name, backing, doc, variants, self.spanSE(start, self.tok_end))
            }

            if (self.tok == @intFromEnum(Token.kw_error)) {
                if (self.peekToken() == @intFromEnum(Token.lbrace)) {
                    self.advance()  // consume 'error'
                    self.advance()  // consume '{'
                    var variants: List(string) = undefined
                    variants.items = 0
                    variants.count = 0
                    variants.capacity = 0
                    while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
                        if (self.tok != @intFromEnum(Token.ident)) {
                            break
                        }
                        variants.append(self.tok_text)
                        self.advance()
                        if (!self.match(@intFromEnum(Token.comma))) {
                            break
                        }
                    }
                    self.expect(@intFromEnum(Token.rbrace))
                    return self.ast.addErrorSetDecl(name, doc, variants, self.spanSE(start, self.tok_end))
                }
                // error.Name expression — not an error set, restore state
            }

            if (self.tok == @intFromEnum(Token.kw_union)) {
                self.advance()  // consume 'union'
                if (!self.expect(@intFromEnum(Token.lbrace))) {
                    return null_node
                }
                var variants: List(int) = undefined
                variants.items = 0
                variants.count = 0
                variants.capacity = 0
                while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
                    const vstart = self.tok_start
                    if (self.tok != @intFromEnum(Token.ident)) {
                        self.errors.report(self.tok_start, ErrorCode.e203, "expected variant name")
                        break
                    }
                    const vname = self.tok_text
                    self.advance()
                    var vtype = null_node
                    if (self.match(@intFromEnum(Token.colon))) {
                        vtype = self.parseType()
                    }
                    variants.append(self.ast.addUnionVariant(vname, vtype, self.spanSE(vstart, self.tok_end)))
                    self.match(@intFromEnum(Token.comma))
                }
                self.expect(@intFromEnum(Token.rbrace))
                return self.ast.addUnionDecl(name, doc, variants, self.spanSE(start, self.tok_end))
            }

            if (self.tok == @intFromEnum(Token.kw_struct)) {
                self.advance()  // consume 'struct'
                var sfields: List(int) = undefined
                sfields.items = 0
                sfields.count = 0
                sfields.capacity = 0
                var nested: List(int) = undefined
                nested.items = 0
                nested.count = 0
                nested.capacity = 0
                var type_params: List(string) = undefined
                type_params.items = 0
                type_params.count = 0
                type_params.capacity = 0
                if (!self.expect(@intFromEnum(Token.lbrace))) {
                    return null_node
                }
                while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
                    self.collectDocComment()
                    const fd = self.parseFieldDef()
                    if (fd != null_node) {
                        sfields.append(fd)
                    }
                    self.match(@intFromEnum(Token.comma))
                }
                self.expect(@intFromEnum(Token.rbrace))
                return self.ast.addStructDecl(name, 0, doc, sfields, type_params, nested, self.spanSE(start, self.tok_end))
            }

            // Not a type declaration — restore parser + scanner state
            self.tok = saved_tok
            self.tok_text = saved_tok_text
            self.tok_start = saved_tok_start
            self.tok_end = saved_tok_end
            self.has_peek = saved_has_peek
            self.peek_tok = saved_peek_tok
            self.peek_text = saved_peek_text
            self.peek_start = saved_peek_start
            self.peek_end = saved_peek_end
            self.scanner.pos = saved_scan_pos
            self.scanner.ch = saved_scan_ch
        }

        // Regular initializer
        var value = null_node
        if (self.match(@intFromEnum(Token.assign))) {
            value = self.parseExpr()
        }

        return self.ast.addVarDecl(name, type_expr, value, is_const, doc, self.spanSE(start, self.tok_end))
    }

    /// Destructure top-level: const a, b = expr (no ident found, multiple bindings)
    fn parseDestructureDecl(is_const: int, start: int, doc: string) int {
        // First token isn't ident — this shouldn't normally happen for destructuring
        // Destructuring starts with ident: const a, b = ...
        self.errors.report(self.tok_start, ErrorCode.e203, "expected variable name")
        return null_node
    }

    /// Destructure from first binding: const a, b = expr
    fn parseDestructureDeclFrom(first_name: string, first_type: int, first_start: int, start: int, is_const: int, doc: string) int {
        var bindings: List(int) = undefined
        bindings.items = 0
        bindings.count = 0
        bindings.capacity = 0
        bindings.append(self.ast.addDestructureBind(first_name, first_type, self.spanSE(first_start, self.tok_end)))
        while (self.match(@intFromEnum(Token.comma))) {
            if (self.tok != @intFromEnum(Token.ident)) {
                self.errors.report(self.tok_start, ErrorCode.e203, "expected variable name")
                break
            }
            const bname = self.tok_text
            const bstart = self.tok_start
            self.advance()
            var btype = null_node
            if (self.match(@intFromEnum(Token.colon))) {
                btype = self.parseType()
            }
            bindings.append(self.ast.addDestructureBind(bname, btype, self.spanSE(bstart, self.tok_end)))
        }
        if (!self.expect(@intFromEnum(Token.assign))) {
            return null_node
        }
        const value = self.parseExpr()
        return self.ast.addDestructureStmt(value, is_const, bindings, self.spanSE(start, self.tok_end))
    }

    /// struct Name { fields }
    /// Ported from parser.zig:428-483 (parseStructDeclWithLayout)
    fn parseStructDecl(layout: int) int {
        const start = self.tok_start
        const doc = self.consumeDocComment()
        self.advance()  // consume 'struct'
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected struct name")
            return null_node
        }
        const name = self.tok_text
        self.advance()

        // Parse optional type parameters: struct Pair(T, U) { ... }
        // Ported from parser.zig:440-454
        var type_params: List(string) = undefined
        type_params.items = 0
        type_params.count = 0
        type_params.capacity = 0
        if (self.tok == @intFromEnum(Token.lparen)) {
            self.advance()  // consume (
            while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
                if (self.tok != @intFromEnum(Token.ident)) {
                    self.errors.report(self.tok_start, ErrorCode.e203, "expected type parameter name")
                    return null_node
                }
                type_params.append(self.tok_text)
                self.advance()
                if (!self.match(@intFromEnum(Token.comma))) {
                    break
                }
            }
            self.expect(@intFromEnum(Token.rparen))
        }

        if (!self.expect(@intFromEnum(Token.lbrace))) {
            return null_node
        }

        // Parse nested declarations (const, enum, struct, type, fn) before fields
        // Ported from parser.zig:458-470
        var nested: List(int) = undefined
        nested.items = 0
        nested.count = 0
        nested.capacity = 0
        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            const tok = @as(Token, @enumFromInt(self.tok))
            if (tok == Token.kw_const or tok == Token.kw_enum or tok == Token.kw_type or
                tok == Token.kw_fn) {
                const nested_decl = self.parseDecl()
                if (nested_decl != null_node) {
                    nested.append(nested_decl)
                }
            } else {
                break
            }
        }

        // Fields
        var fields: List(int) = undefined
        fields.items = 0
        fields.count = 0
        fields.capacity = 0
        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            self.collectDocComment()
            const fd = self.parseFieldDef()
            if (fd != null_node) {
                fields.append(fd)
            }
            self.match(@intFromEnum(Token.comma))
        }
        self.expect(@intFromEnum(Token.rbrace))

        return self.ast.addStructDecl(name, layout, doc, fields, type_params, nested, self.spanSE(start, self.tok_end))
    }

    fn parsePackedStructDecl() int {
        self.advance()  // consume 'packed'
        return self.parseStructDecl(1)  // packed layout
    }

    /// Parse extern fn or extern struct
    fn parseExternDecl() int {
        const start = self.tok_start
        self.advance()  // consume 'extern'
        if (self.tok == @intFromEnum(Token.kw_fn)) {
            return self.parseFnDecl(1, 0)
        }
        if (self.tok == @intFromEnum(Token.kw_struct)) {
            return self.parseStructDecl(2)  // extern layout
        }
        self.errors.report(start, ErrorCode.e200, "expected fn or struct after extern")
        return null_node
    }

    /// const Name = enum { variants }
    fn parseEnumDecl() int {
        const start = self.tok_start
        const doc = self.consumeDocComment()
        self.advance()  // consume 'enum'
        // Optional backing type: enum(u8)
        var backing = null_node
        if (self.match(@intFromEnum(Token.lparen))) {
            backing = self.parseType()
            self.expect(@intFromEnum(Token.rparen))
        }
        if (!self.expect(@intFromEnum(Token.lbrace))) {
            return null_node
        }
        var variants: List(int) = undefined
        variants.items = 0
        variants.count = 0
        variants.capacity = 0
        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            const vstart = self.tok_start
            if (self.tok == @intFromEnum(Token.at)) {
                // Quoted identifier: @"packed"
                self.advance()
                if (self.tok != @intFromEnum(Token.string_lit)) {
                    self.errors.report(self.tok_start, ErrorCode.e200, "expected string after @")
                    break
                }
            }
            if (self.tok != @intFromEnum(Token.ident) and self.tok != @intFromEnum(Token.string_lit)) {
                self.errors.report(self.tok_start, ErrorCode.e203, "expected variant name")
                break
            }
            const vname = self.tok_text
            self.advance()
            var vval = null_node
            if (self.match(@intFromEnum(Token.assign))) {
                vval = self.parseExpr()
            }
            variants.append(self.ast.addEnumVariant(vname, vval, self.spanSE(vstart, self.tok_end)))
            self.match(@intFromEnum(Token.comma))
        }
        self.expect(@intFromEnum(Token.rbrace))
        // enum is declared as `const Name = enum { ... }`, name comes from the var decl
        return self.ast.addEnumDecl("", backing, doc, variants, self.spanSE(start, self.tok_end))
    }

    /// union { variants }
    fn parseUnionDecl() int {
        const start = self.tok_start
        const doc = self.consumeDocComment()
        self.advance()  // consume 'union'
        if (!self.expect(@intFromEnum(Token.lbrace))) {
            return null_node
        }
        var variants: List(int) = undefined
        variants.items = 0
        variants.count = 0
        variants.capacity = 0
        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            const vstart = self.tok_start
            if (self.tok != @intFromEnum(Token.ident)) {
                self.errors.report(self.tok_start, ErrorCode.e203, "expected variant name")
                break
            }
            const vname = self.tok_text
            self.advance()
            var vtype = null_node
            if (self.match(@intFromEnum(Token.colon))) {
                vtype = self.parseType()
            }
            variants.append(self.ast.addUnionVariant(vname, vtype, self.spanSE(vstart, self.tok_end)))
            self.match(@intFromEnum(Token.comma))
        }
        self.expect(@intFromEnum(Token.rbrace))
        return self.ast.addUnionDecl("", doc, variants, self.spanSE(start, self.tok_end))
    }

    /// impl Type { methods }  or  impl Type(T) { methods }  or  impl Trait for Type { methods }
    /// Ported from parser.zig:485-534
    fn parseImplBlock() int {
        const start = self.tok_start
        const doc = self.consumeDocComment()
        self.advance()  // consume 'impl'
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected type name after impl")
            return null_node
        }
        const type_name = self.tok_text
        self.advance()

        // Parse optional type parameters: impl List(T) { ... }
        // Ported from parser.zig:493-507
        var type_params: List(string) = undefined
        type_params.items = 0
        type_params.count = 0
        type_params.capacity = 0
        if (self.tok == @intFromEnum(Token.lparen)) {
            self.advance()
            while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
                if (self.tok != @intFromEnum(Token.ident)) {
                    self.errors.report(self.tok_start, ErrorCode.e203, "expected type parameter name")
                    return null_node
                }
                type_params.append(self.tok_text)
                self.advance()
                if (!self.match(@intFromEnum(Token.comma))) {
                    break
                }
            }
            self.expect(@intFromEnum(Token.rparen))
        }

        // Check for trait impl: impl Trait for Type { ... }
        // Ported from parser.zig:510
        if (self.tok == @intFromEnum(Token.kw_for)) {
            return self.parseImplTraitBlock(type_name, type_params, doc, start)
        }

        if (!self.expect(@intFromEnum(Token.lbrace))) {
            return null_node
        }

        // Save/restore impl context for implicit self injection (@safe mode)
        // Ported from parser.zig:515-522
        const saved_impl = self.current_impl_type
        const saved_generic = self.current_impl_is_generic
        self.current_impl_type = type_name
        self.current_impl_is_generic = type_params.len() > 0

        var methods: List(int) = undefined
        methods.items = 0
        methods.count = 0
        methods.capacity = 0

        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            self.collectDocComment()
            if (self.tok == @intFromEnum(Token.kw_fn)) {
                const m = self.parseFnDecl(0, 0)
                if (m != null_node) {
                    methods.append(m)
                }
            } else if (self.tok == @intFromEnum(Token.kw_async)) {
                const m = self.parseAsyncFn()
                if (m != null_node) {
                    methods.append(m)
                }
            } else {
                self.errors.report(self.tok_start, ErrorCode.e200, "expected method in impl block")
                self.advance()
            }
        }
        self.expect(@intFromEnum(Token.rbrace))
        self.current_impl_type = saved_impl
        self.current_impl_is_generic = saved_generic

        return self.ast.addImplBlock(type_name, doc, methods, type_params, self.spanSE(start, self.tok_end))
    }

    /// impl Trait for Type { methods }
    /// Ported from parser.zig:558-594
    /// type_params already parsed by parseImplBlock, trait_name is actually the first ident
    fn parseImplTraitBlock(trait_name: string, type_params: List(string), doc: string, start: int) int {
        self.advance()  // consume 'for'
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected type name after for")
            return null_node
        }
        const target = self.tok_text
        self.advance()

        if (!self.expect(@intFromEnum(Token.lbrace))) {
            return null_node
        }

        // Save/restore impl context — ported from parser.zig:575-582
        const saved_impl = self.current_impl_type
        const saved_generic = self.current_impl_is_generic
        self.current_impl_type = target
        self.current_impl_is_generic = type_params.len() > 0

        var methods: List(int) = undefined
        methods.items = 0
        methods.count = 0
        methods.capacity = 0

        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            self.collectDocComment()
            if (self.tok == @intFromEnum(Token.kw_fn)) {
                const m = self.parseFnDecl(0, 0)
                if (m != null_node) {
                    methods.append(m)
                }
            } else {
                self.errors.report(self.tok_start, ErrorCode.e200, "expected method")
                self.advance()
            }
        }
        self.expect(@intFromEnum(Token.rbrace))
        self.current_impl_type = saved_impl
        self.current_impl_is_generic = saved_generic

        return self.ast.addImplTrait(trait_name, target, doc, methods, type_params, self.spanSE(start, self.tok_end))
    }

    /// trait Name { method signatures }
    fn parseTraitDecl() int {
        const start = self.tok_start
        const doc = self.consumeDocComment()
        self.advance()  // consume 'trait'
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected trait name")
            return null_node
        }
        const name = self.tok_text
        self.advance()
        var methods: List(int) = undefined
        methods.items = 0
        methods.count = 0
        methods.capacity = 0
        if (!self.expect(@intFromEnum(Token.lbrace))) {
            return null_node
        }
        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            self.collectDocComment()
            if (self.tok == @intFromEnum(Token.kw_fn)) {
                const m = self.parseFnDecl(0, 0)
                if (m != null_node) {
                    methods.append(m)
                }
            } else {
                self.errors.report(self.tok_start, ErrorCode.e200, "expected method signature in trait")
                self.advance()
            }
        }
        self.expect(@intFromEnum(Token.rbrace))
        return self.ast.addTraitDecl(name, doc, methods, self.spanSE(start, self.tok_end))
    }

    /// type Name = Type
    fn parseTypeAlias() int {
        const start = self.tok_start
        const doc = self.consumeDocComment()
        self.advance()  // consume 'type'
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected type name")
            return null_node
        }
        const name = self.tok_text
        self.advance()
        if (!self.expect(@intFromEnum(Token.assign))) {
            return null_node
        }
        const target = self.parseType()
        return self.ast.addTypeAliasDecl(name, target, doc, self.spanSE(start, self.tok_end))
    }

    /// async fn name(...) { ... }
    fn parseAsyncFn() int {
        self.advance()  // consume 'async'
        if (self.tok != @intFromEnum(Token.kw_fn)) {
            self.errors.report(self.tok_start, ErrorCode.e200, "expected fn after async")
            return null_node
        }
        return self.parseFnDecl(0, 1)
    }

    /// Parse a field definition: name: Type or name: Type = default
    fn parseFieldDef() int {
        const start = self.tok_start
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected field name")
            return null_node
        }
        const name = self.tok_text
        self.advance()
        var type_expr = null_node
        if (self.match(@intFromEnum(Token.colon))) {
            type_expr = self.parseType()
        }
        var default_val = null_node
        if (self.match(@intFromEnum(Token.assign))) {
            default_val = self.parseExpr()
        }
        const doc = self.consumeDocComment()
        return self.ast.addFieldDef(name, type_expr, default_val, doc, self.spanSE(start, self.tok_end))
    }

    // ================================================================
    // Phase B: Expressions
    // ================================================================

    /// Parse an expression (entry point).
    fn parseExpr() int {
        return self.parseBinaryExpr(0)
    }

    /// Precedence climbing for binary operators.
    fn parseBinaryExpr(min_prec: int) int {
        if (self.nest_level > MAX_NEST) {
            self.errors.report(self.tok_start, ErrorCode.e200, "maximum nesting depth exceeded")
            return null_node
        }
        self.nest_level = self.nest_level + 1
        var left = self.parseUnaryExpr()
        if (left == null_node) {
            self.nest_level = self.nest_level - 1
            return null_node
        }

        while (true) {
            const tok = @as(Token, @enumFromInt(self.tok))
            // Handle catch specially (low precedence, right-associative)
            if (tok == Token.kw_catch) {
                if (min_prec > 1) {
                    break
                }
                const op_start = self.tok_start
                self.advance()  // consume 'catch'
                // Optional error capture: catch |err| { ... }
                var capture = ""
                if (self.tok == @intFromEnum(Token.@"or")) {
                    self.advance()  // consume |
                    if (self.tok == @intFromEnum(Token.ident)) {
                        capture = self.tok_text
                        self.advance()
                    }
                    self.expect(@intFromEnum(Token.@"or"))  // consume |
                }
                const right = self.parseBinaryExpr(2)
                left = self.ast.addCatchExpr(left, capture, right, self.spanSE(op_start, self.tok_end))
                continue
            }

            const prec = tok.precedence()
            if (prec == 0 or @as(int, prec) < min_prec) {
                break
            }
            const op = self.tok
            self.advance()
            const right = self.parseBinaryExpr(@as(int, prec) + 1)
            left = self.ast.addBinary(op, left, right, self.spanSE(self.tok_start, self.tok_end))
        }
        self.nest_level = self.nest_level - 1
        return left
    }

    /// Parse a unary expression: -x, !x, try x, await x, &x
    fn parseUnaryExpr() int {
        const tok = @as(Token, @enumFromInt(self.tok))
        if (tok == Token.@"and") {
            // Address-of: &expr
            const start = self.tok_start
            self.advance()
            const operand = self.parseUnaryExpr()
            return self.ast.addAddrOf(operand, self.spanSE(start, self.tok_end))
        }
        if (tok == Token.kw_try) {
            const start = self.tok_start
            self.advance()
            const operand = self.parseUnaryExpr()
            return self.ast.addTryExpr(operand, self.spanSE(start, self.tok_end))
        }
        if (tok == Token.kw_await) {
            const start = self.tok_start
            self.advance()
            const operand = self.parseUnaryExpr()
            return self.ast.addAwaitExpr(operand, self.spanSE(start, self.tok_end))
        }
        if (tok == Token.sub or tok == Token.lnot or tok == Token.@"not" or tok == Token.kw_not) {
            const start = self.tok_start
            const op = self.tok
            self.advance()
            const operand = self.parseUnaryExpr()
            return self.ast.addUnary(op, operand, self.spanSE(start, self.tok_end))
        }
        return self.parsePrimaryExpr()
    }

    /// Parse primary expression with postfix operations.
    fn parsePrimaryExpr() int {
        var node = self.parseOperand()
        if (node == null_node) {
            return null_node
        }
        // Postfix loop
        while (true) {
            const tok = @as(Token, @enumFromInt(self.tok))
            if (tok == Token.period) {
                self.advance()
                if (self.tok == @intFromEnum(Token.mul)) {
                    // .*  dereference
                    self.advance()
                    node = self.ast.addDeref(node, self.spanSE(self.tok_start, self.tok_end))
                } else if (self.tok == @intFromEnum(Token.question)) {
                    // .?  optional unwrap
                    self.advance()
                    node = self.ast.addUnary(@intFromEnum(Token.question), node, self.spanSE(self.tok_start, self.tok_end))
                } else if (self.tok == @intFromEnum(Token.ident) or self.tok == @intFromEnum(Token.int_lit)) {
                    // .field or .0 (tuple index)
                    const field_name = self.tok_text
                    self.advance()
                    node = self.ast.addFieldAccess(node, field_name, self.spanSE(self.tok_start, self.tok_end))
                } else {
                    break
                }
            } else if (tok == Token.lbrack) {
                self.advance()  // consume [
                const idx = self.parseExpr()
                if (self.tok == @intFromEnum(Token.colon)) {
                    // Slice: expr[start:end]
                    self.advance()
                    const end_expr = self.parseExpr()
                    self.expect(@intFromEnum(Token.rbrack))
                    node = self.ast.addSliceExpr(node, idx, end_expr, self.spanSE(self.tok_start, self.tok_end))
                } else {
                    self.expect(@intFromEnum(Token.rbrack))
                    node = self.ast.addIndexExpr(node, idx, self.spanSE(self.tok_start, self.tok_end))
                }
            } else if (tok == Token.lparen) {
                // Function call
                self.advance()  // consume (
                var args: List(int) = undefined
                args.items = 0
                args.count = 0
                args.capacity = 0
                while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
                    const arg = self.parseExpr()
                    if (arg != null_node) {
                        args.append(arg)
                    }
                    if (!self.match(@intFromEnum(Token.comma))) {
                        break
                    }
                }
                self.expect(@intFromEnum(Token.rparen))
                node = self.ast.addCallNode(node, args, self.spanSE(self.tok_start, self.tok_end))
            } else if (self.peekNextIsPeriod() or (self.safe_mode and self.peekNextIsIdentColon())) {
                // Struct init: Type { .x = 1 } or Type { x: 1 } (@safe)
                node = self.parseStructInitFrom(node)
            } else {
                break
            }
        }
        return node
    }

    /// Parse an atomic operand expression.
    fn parseOperand() int {
        const tok = @as(Token, @enumFromInt(self.tok))
        const start = self.tok_start

        // Identifiers
        if (tok == Token.ident) {
            const name = self.tok_text
            self.advance()
            return self.ast.addIdent(name, self.spanSE(start, self.tok_end))
        }

        // Integer literal
        if (tok == Token.int_lit) {
            const text = self.tok_text
            self.advance()
            return self.ast.addLiteral(@intFromEnum(LiteralKind.@"int"), text, self.spanSE(start, self.tok_end))
        }

        // Float literal
        if (tok == Token.float_lit) {
            const text = self.tok_text
            self.advance()
            return self.ast.addLiteral(@intFromEnum(LiteralKind.@"float"), text, self.spanSE(start, self.tok_end))
        }

        // String literal
        if (tok == Token.string_lit) {
            const text = self.tok_text
            self.advance()
            return self.ast.addLiteral(@intFromEnum(LiteralKind.@"string"), text, self.spanSE(start, self.tok_end))
        }

        // String interpolation: "text${expr}..."
        if (tok == Token.string_interp_start) {
            return self.parseStringInterp()
        }

        // Char literal
        if (tok == Token.char_lit) {
            const text = self.tok_text
            self.advance()
            return self.ast.addLiteral(@intFromEnum(LiteralKind.char), text, self.spanSE(start, self.tok_end))
        }

        // Keywords as literals
        if (tok == Token.kw_true) {
            self.advance()
            return self.ast.addLiteral(@intFromEnum(LiteralKind.true_lit), "true", self.spanSE(start, self.tok_end))
        }
        if (tok == Token.kw_false) {
            self.advance()
            return self.ast.addLiteral(@intFromEnum(LiteralKind.false_lit), "false", self.spanSE(start, self.tok_end))
        }
        if (tok == Token.kw_null) {
            self.advance()
            return self.ast.addLiteral(@intFromEnum(LiteralKind.null_lit), "null", self.spanSE(start, self.tok_end))
        }
        if (tok == Token.kw_undefined) {
            self.advance()
            return self.ast.addLiteral(@intFromEnum(LiteralKind.undefined_lit), "undefined", self.spanSE(start, self.tok_end))
        }
        if (tok == Token.kw_unreachable) {
            self.advance()
            return self.ast.addLiteral(@intFromEnum(LiteralKind.unreachable_lit), "unreachable", self.spanSE(start, self.tok_end))
        }

        // Type keywords as identifiers
        if (tok.isTypeKeyword()) {
            const name = self.tok_text
            self.advance()
            return self.ast.addIdent(name, self.spanSE(start, self.tok_end))
        }

        // Parenthesized expression or tuple
        if (tok == Token.lparen) {
            self.advance()  // consume (
            const inner = self.parseExpr()
            if (self.tok == @intFromEnum(Token.comma)) {
                // Tuple literal: (a, b, c)
                var elems: List(int) = undefined
                elems.items = 0
                elems.count = 0
                elems.capacity = 0
                elems.append(inner)
                while (self.match(@intFromEnum(Token.comma))) {
                    if (self.tok == @intFromEnum(Token.rparen)) {
                        break
                    }
                    elems.append(self.parseExpr())
                }
                self.expect(@intFromEnum(Token.rparen))
                return self.ast.addTupleLit(elems, self.spanSE(start, self.tok_end))
            }
            self.expect(@intFromEnum(Token.rparen))
            return self.ast.addParen(inner, self.spanSE(start, self.tok_end))
        }

        // Array literal: [1, 2, 3]
        if (tok == Token.lbrack) {
            self.advance()  // consume [
            var elems: List(int) = undefined
            elems.items = 0
            elems.count = 0
            elems.capacity = 0
            while (self.tok != @intFromEnum(Token.rbrack) and self.tok != @intFromEnum(Token.eof)) {
                elems.append(self.parseExpr())
                if (!self.match(@intFromEnum(Token.comma))) {
                    break
                }
            }
            self.expect(@intFromEnum(Token.rbrack))
            return self.ast.addArrayLit(elems, self.spanSE(start, self.tok_end))
        }

        // Block expression: { stmts; result }
        if (tok == Token.lbrace) {
            return self.parseBlockExpr()
        }

        // If expression
        if (tok == Token.kw_if) {
            return self.parseIfExpr()
        }

        // Switch expression
        if (tok == Token.kw_switch) {
            return self.parseSwitchExpr()
        }

        // Anonymous function (closure): fn(params) rettype { body }
        if (tok == Token.kw_fn) {
            return self.parseClosureExpr()
        }

        // Builtin call: @name(args)
        if (tok == Token.at) {
            return self.parseBuiltinCall()
        }

        // new expression
        if (tok == Token.kw_new) {
            return self.parseNewExpr()
        }

        // error literal: error.Name
        if (tok == Token.kw_error) {
            self.advance()
            if (self.match(@intFromEnum(Token.period))) {
                if (self.tok == @intFromEnum(Token.ident)) {
                    const name = self.tok_text
                    self.advance()
                    return self.ast.addErrorLit(name, self.spanSE(start, self.tok_end))
                }
            }
            self.errors.report(start, ErrorCode.e200, "expected error variant name")
            return null_node
        }

        // comptime block
        if (tok == Token.kw_comptime) {
            self.advance()
            const body = self.parseBlock()
            return self.ast.addComptimeBlock(body, self.spanSE(start, self.tok_end))
        }

        // Period prefix: .variant, .{ .x = 1 } anonymous struct, or .{ } zero-init
        if (tok == Token.period) {
            self.advance()
            if (self.tok == @intFromEnum(Token.lbrace)) {
                // .{ } — check if struct init or zero-init
                if (self.peekToken() == @intFromEnum(Token.period) or self.peekToken() == @intFromEnum(Token.ident)) {
                    // .{ .x = 1 } or .{ x: 1 } — anonymous struct init
                    const anon = self.ast.addIdent("", self.spanSE(start, start))
                    return self.parseStructInitFrom(anon)
                }
                if (self.peekToken() == @intFromEnum(Token.rbrace)) {
                    // .{ } — zero-init
                    self.advance()  // consume {
                    self.advance()  // consume }
                    return self.ast.addZeroInit(self.spanSE(start, self.tok_end))
                }
                // .{ expr, expr } — could be tuple or array init
                return self.parseBlockExpr()
            }
            if (self.tok == @intFromEnum(Token.ident)) {
                const name = self.tok_text
                self.advance()
                return self.ast.addIdent(name, self.spanSE(start, self.tok_end))
            }
            return self.ast.addZeroInit(self.spanSE(start, self.tok_end))
        }

        self.errors.report(start, ErrorCode.e201, "expected expression")
        return null_node
    }

    // ================================================================
    // Phase E: Struct init disambiguation helpers
    // ================================================================

    /// Check if { . follows — indicates struct init with period syntax.
    fn peekNextIsPeriod() bool {
        if (self.tok != @intFromEnum(Token.lbrace)) { return false }
        return self.peekToken() == @intFromEnum(Token.period)
    }

    /// Check if { ident : follows — indicates struct init with colon syntax (@safe).
    /// Uses 2-token lookahead with scanner state save/restore.
    fn peekNextIsIdentColon() bool {
        if (self.tok != @intFromEnum(Token.lbrace)) { return false }
        // Save scanner state for restoration after lookahead
        const saved_pos = self.scanner.pos
        const saved_ch = self.scanner.ch
        // Get token after { (use existing peek or scan new)
        var after_brace: int = 0
        if (self.has_peek) {
            after_brace = self.peek_tok
        } else {
            after_brace = self.scanner.scanNext().tok
        }
        if (after_brace != @intFromEnum(Token.ident)) {
            self.scanner.pos = saved_pos
            self.scanner.ch = saved_ch
            return false
        }
        // Scan third token (after ident)
        const third = self.scanner.scanNext()
        const result = third.tok == @intFromEnum(Token.colon) or
                       third.tok == @intFromEnum(Token.comma) or
                       third.tok == @intFromEnum(Token.rbrace)
        // Restore scanner state
        self.scanner.pos = saved_pos
        self.scanner.ch = saved_ch
        return result
    }

    // ================================================================
    // Phase E: Complex expressions
    // ================================================================

    /// Parse string interpolation: "text${expr}more${expr}end"
    /// Scanner produces string_interp_start, then exprs with
    /// string_interp_mid between them, ending with string_interp_end.
    fn parseStringInterp() int {
        const start = self.tok_start
        var segments: List(int) = undefined
        segments.items = 0
        segments.count = 0
        segments.capacity = 0
        // Start segment text (between " and ${)
        const start_text = self.tok_text
        if (@lenOf(start_text) > 0) {
            segments.append(self.ast.addLiteral(
                @intFromEnum(LiteralKind.@"string"), start_text,
                self.spanSE(start, self.tok_end)))
        }
        self.advance()  // consume string_interp_start
        // Expression inside ${ }
        segments.append(self.parseExpr())
        // Mid and end segments
        while (true) {
            if (self.tok == @intFromEnum(Token.string_interp_mid)) {
                const mid_text = self.tok_text
                if (@lenOf(mid_text) > 0) {
                    segments.append(self.ast.addLiteral(
                        @intFromEnum(LiteralKind.@"string"), mid_text,
                        self.spanSE(self.tok_start, self.tok_end)))
                }
                self.advance()  // consume mid
                segments.append(self.parseExpr())
            } else if (self.tok == @intFromEnum(Token.string_interp_end)) {
                const end_text = self.tok_text
                if (@lenOf(end_text) > 0) {
                    segments.append(self.ast.addLiteral(
                        @intFromEnum(LiteralKind.@"string"), end_text,
                        self.spanSE(self.tok_start, self.tok_end)))
                }
                self.advance()  // consume end
                break
            } else {
                self.errors.report(self.tok_start, ErrorCode.e200, "unterminated string interpolation")
                break
            }
        }
        return self.ast.addStringInterp(segments, self.spanSE(start, self.tok_end))
    }

    /// Parse anonymous function (closure): fn(params) rettype { body }
    fn parseClosureExpr() int {
        const start = self.tok_start
        self.advance()  // consume 'fn'
        if (!self.expect(@intFromEnum(Token.lparen))) {
            return null_node
        }
        var params: List(int) = undefined
        params.items = 0
        params.count = 0
        params.capacity = 0
        while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
            const param = self.parseFieldDef()
            if (param != null_node) {
                params.append(param)
            }
            if (!self.match(@intFromEnum(Token.comma))) {
                break
            }
        }
        if (!self.expect(@intFromEnum(Token.rparen))) {
            return null_node
        }
        var ret_type = null_node
        if (self.tok != @intFromEnum(Token.lbrace) and self.tok != @intFromEnum(Token.eof)) {
            ret_type = self.parseType()
        }
        const body = self.parseBlock()
        return self.ast.addClosureExpr(ret_type, body, params, self.spanSE(start, self.tok_end))
    }

    /// Parse struct init fields after detecting { in postfix position.
    /// `preceding` is the already-parsed type-name expression node.
    fn parseStructInitFrom(preceding: int) int {
        const start = self.tok_start
        // Determine type name from preceding node
        var type_name = ""
        var type_args: List(int) = undefined
        type_args.items = 0
        type_args.count = 0
        type_args.capacity = 0
        const tag = self.ast.getTag(preceding)
        if (tag == @intFromEnum(NodeTag.ident)) {
            type_name = self.ast.getStr(self.ast.getData(preceding, 0))
        }
        // Determine syntax: period vs colon
        const use_colon = self.safe_mode and self.peekNextIsIdentColon()
        self.advance()  // consume {
        var fields: List(int) = undefined
        fields.items = 0
        fields.count = 0
        fields.capacity = 0
        if (use_colon) {
            // Colon syntax (@safe): { name: val, name2: val2 }
            while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
                const fi = self.parseFieldInit()
                if (fi != null_node) {
                    fields.append(fi)
                }
                if (!self.match(@intFromEnum(Token.comma))) {
                    break
                }
            }
        } else {
            // Period syntax: { .name = val, .name2 = val2 }
            while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
                if (!self.expect(@intFromEnum(Token.period))) {
                    break
                }
                if (self.tok != @intFromEnum(Token.ident)) {
                    self.errors.report(self.tok_start, ErrorCode.e203, "expected field name")
                    break
                }
                const fname = self.tok_text
                const fstart = self.tok_start
                self.advance()
                self.expect(@intFromEnum(Token.assign))
                const val = self.parseExpr()
                fields.append(self.ast.addFieldInitNode(fname, val, self.spanSE(fstart, self.tok_end)))
                if (!self.match(@intFromEnum(Token.comma))) {
                    break
                }
            }
        }
        self.expect(@intFromEnum(Token.rbrace))
        return self.ast.addStructInit(type_name, fields, type_args, self.spanSE(start, self.tok_end))
    }

    /// if (cond) |capture| { then } else { else }
    fn parseIfExpr() int {
        const start = self.tok_start
        self.advance()  // consume 'if'
        if (!self.expect(@intFromEnum(Token.lparen))) {
            return null_node
        }
        const cond = self.parseExpr()
        if (!self.expect(@intFromEnum(Token.rparen))) {
            return null_node
        }
        // Optional capture: |val|
        var capture = ""
        if (self.tok == @intFromEnum(Token.@"or")) {
            self.advance()
            if (self.tok == @intFromEnum(Token.ident)) {
                capture = self.tok_text
                self.advance()
            }
            self.expect(@intFromEnum(Token.@"or"))
        }
        const then_br = self.parseExpr()
        var else_br = null_node
        if (self.match(@intFromEnum(Token.kw_else))) {
            else_br = self.parseExpr()
        }
        return self.ast.addIfExpr(cond, then_br, else_br, capture, self.spanSE(start, self.tok_end))
    }

    /// switch (subject) { cases }
    fn parseSwitchExpr() int {
        const start = self.tok_start
        self.advance()  // consume 'switch'
        if (!self.expect(@intFromEnum(Token.lparen))) {
            return null_node
        }
        const subject = self.parseExpr()
        if (!self.expect(@intFromEnum(Token.rparen))) {
            return null_node
        }
        if (!self.expect(@intFromEnum(Token.lbrace))) {
            return null_node
        }
        var cases: List(int) = undefined
        cases.items = 0
        cases.count = 0
        cases.capacity = 0
        var else_body = null_node
        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            // else => body
            if (self.tok == @intFromEnum(Token.kw_else)) {
                self.advance()
                self.expect(@intFromEnum(Token.fat_arrow))
                else_body = self.parseExpr()
                self.match(@intFromEnum(Token.comma))
            } else if (self.tok == @intFromEnum(Token.ident) and strEqual(self.tok_text, "_")) {
                // Wildcard _ => treat as else (Rust/Zig convention)
                // Ported from parser.zig:1502-1508
                self.advance()
                self.expect(@intFromEnum(Token.fat_arrow))
                else_body = self.parseExpr()
                self.match(@intFromEnum(Token.comma))
            } else {
                const case_node = self.parseSwitchCase()
                if (case_node != null_node) {
                    cases.append(case_node)
                }
            }
        }
        self.expect(@intFromEnum(Token.rbrace))
        return self.ast.addSwitchExpr(subject, else_body, cases, self.spanSE(start, self.tok_end))
    }

    /// Ported from parser.zig:1510-1546
    fn parseSwitchCase() int {
        const start = self.tok_start
        var patterns: List(int) = undefined
        patterns.items = 0
        patterns.count = 0
        patterns.capacity = 0
        var is_range = 0

        // First pattern
        const first = self.parsePrimaryExpr()
        patterns.append(first)

        // Range pattern: 1..5 (ported from parser.zig:1517-1521)
        if (self.tok == @intFromEnum(Token.period_period)) {
            self.advance()
            const range_end = self.parsePrimaryExpr()
            patterns.append(range_end)
            is_range = 1
        } else {
            // Multiple comma-separated patterns
            while (self.match(@intFromEnum(Token.comma))) {
                if (self.tok == @intFromEnum(Token.fat_arrow) or self.tok == @intFromEnum(Token.kw_else) or self.tok == @intFromEnum(Token.rbrace)) {
                    break
                }
                patterns.append(self.parsePrimaryExpr())
            }
        }

        // Optional capture: |val|
        var capture = ""
        if (self.tok == @intFromEnum(Token.@"or")) {
            self.advance()
            if (self.tok == @intFromEnum(Token.ident)) {
                capture = self.tok_text
                self.advance()
            }
            self.expect(@intFromEnum(Token.@"or"))
        }

        // Guard expression: pattern if expr => (ported from parser.zig:1537-1542)
        var guard = null_node
        if (self.tok == @intFromEnum(Token.kw_if)) {
            self.advance()
            guard = self.parseExpr()
        }

        self.expect(@intFromEnum(Token.fat_arrow))
        const body = self.parseExpr()
        self.match(@intFromEnum(Token.comma))
        return self.ast.addSwitchCase(capture, guard, is_range, body, patterns, self.spanSE(start, self.tok_end))
    }

    /// Block expression: { stmts; result_expr }
    fn parseBlockExpr() int {
        const start = self.tok_start
        self.advance()  // consume {
        var stmts: List(int) = undefined
        stmts.items = 0
        stmts.count = 0
        stmts.capacity = 0
        var result_expr = null_node
        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            const s = self.parseStmt()
            if (s != null_node) {
                stmts.append(s)
            }
        }
        // If last stmt is expr_stmt, extract as result
        if (stmts.count > 0) {
            const last_tag = self.ast.getTag(stmts.get(stmts.count - 1))
            if (last_tag == @intFromEnum(NodeTag.expr_stmt)) {
                result_expr = self.ast.getData(stmts.get(stmts.count - 1), 0)
                stmts.count = stmts.count - 1
            }
        }
        self.expect(@intFromEnum(Token.rbrace))
        return self.ast.addBlockExpr(result_expr, stmts, self.spanSE(start, self.tok_end))
    }

    /// @builtin(args)
    fn parseBuiltinCall() int {
        const start = self.tok_start
        self.advance()  // consume @
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(start, ErrorCode.e200, "expected builtin name after @")
            return null_node
        }
        const name = self.tok_text
        const kind = builtinFromString(name)
        self.advance()
        // Optional type arg: @sizeOf(Type)
        var type_arg = null_node
        var args: List(int) = undefined
        args.items = 0
        args.count = 0
        args.capacity = 0
        if (self.match(@intFromEnum(Token.lparen))) {
            while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
                args.append(self.parseExpr())
                if (!self.match(@intFromEnum(Token.comma))) {
                    break
                }
            }
            self.expect(@intFromEnum(Token.rparen))
        }
        const kind_val = kind orelse 0
        return self.ast.addBuiltinCall(kind_val, type_arg, args, self.spanSE(start, self.tok_end))
    }

    /// new Type { fields } or new Type(args) { fields }
    fn parseNewExpr() int {
        const start = self.tok_start
        self.advance()  // consume 'new'
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(start, ErrorCode.e200, "expected type name after new")
            return null_node
        }
        const type_name = self.tok_text
        self.advance()

        var type_args: List(int) = undefined
        type_args.items = 0
        type_args.count = 0
        type_args.capacity = 0
        var ctor_args: List(int) = undefined
        ctor_args.items = 0
        ctor_args.count = 0
        ctor_args.capacity = 0
        var fields: List(int) = undefined
        fields.items = 0
        fields.count = 0
        fields.capacity = 0

        // Constructor args or type args
        var is_ctor = 0
        if (self.tok == @intFromEnum(Token.lparen)) {
            is_ctor = 1
            self.advance()
            while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
                ctor_args.append(self.parseExpr())
                if (!self.match(@intFromEnum(Token.comma))) {
                    break
                }
            }
            self.expect(@intFromEnum(Token.rparen))
        }

        // Field initializers
        if (self.tok == @intFromEnum(Token.lbrace)) {
            self.advance()
            while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
                const fi = self.parseFieldInit()
                if (fi != null_node) {
                    fields.append(fi)
                }
                self.match(@intFromEnum(Token.comma))
            }
            self.expect(@intFromEnum(Token.rbrace))
        }

        return self.ast.addNewExpr(type_name, is_ctor, fields, type_args, ctor_args, self.spanSE(start, self.tok_end))
    }

    /// Parse field init: .name = expr or name: expr (@safe)
    fn parseFieldInit() int {
        const start = self.tok_start
        if (self.tok == @intFromEnum(Token.period)) {
            // Standard: .name = expr
            self.advance()
            if (self.tok != @intFromEnum(Token.ident)) {
                return null_node
            }
            const name = self.tok_text
            self.advance()
            self.expect(@intFromEnum(Token.assign))
            const value = self.parseExpr()
            return self.ast.addFieldInitNode(name, value, self.spanSE(start, self.tok_end))
        }
        if (self.tok == @intFromEnum(Token.ident)) {
            // @safe colon syntax: name: expr
            const name = self.tok_text
            self.advance()
            if (self.match(@intFromEnum(Token.colon))) {
                const value = self.parseExpr()
                return self.ast.addFieldInitNode(name, value, self.spanSE(start, self.tok_end))
            }
            // Field shorthand: just `name` means `name: name`
            const name_node = self.ast.addIdent(name, self.spanSE(start, self.tok_end))
            return self.ast.addFieldInitNode(name, name_node, self.spanSE(start, self.tok_end))
        }
        self.errors.report(start, ErrorCode.e200, "expected field initializer")
        return null_node
    }

    // ================================================================
    // Phase C: Statements
    // ================================================================

    /// Parse a statement.
    fn parseStmt() int {
        const tok = @as(Token, @enumFromInt(self.tok))
        // Label detection: `label: while` or `label: for`
        if (tok == Token.ident) {
            if (self.peekToken() == @intFromEnum(Token.colon)) {
                const label = self.tok_text
                self.advance()  // consume ident
                self.advance()  // consume :
                if (self.tok == @intFromEnum(Token.kw_while)) {
                    return self.parseWhileStmt(label)
                }
                if (self.tok == @intFromEnum(Token.kw_for)) {
                    return self.parseForStmt(label, 0)
                }
                self.errors.report(self.tok_start, ErrorCode.e201, "expected 'while' or 'for' after label")
                return null_node
            }
        }
        return switch (tok) {
            .kw_return => self.parseReturnStmt(),
            .kw_var, .kw_let => self.parseVarStmt(0),
            .kw_const => self.parseVarStmt(1),
            .kw_weak => self.parseWeakVarStmt(),
            .kw_if => self.parseIfStmt(),
            .kw_while => self.parseWhileStmt(""),
            .kw_for => self.parseForStmt("", 0),
            .kw_inline => self.parseInlineFor(),
            .kw_break => self.parseBreakStmt(),
            .kw_continue => self.parseContinueStmt(),
            .kw_defer => self.parseDeferStmt(0),
            .kw_errdefer => self.parseDeferStmt(1),
            else => self.parseExprOrAssign(),
        }
    }

    fn parseReturnStmt() int {
        const start = self.tok_start
        self.advance()  // consume 'return'
        var value = null_node
        // Return has a value if the next token isn't a statement-ending token
        if (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof) and self.tok != @intFromEnum(Token.semicolon)) {
            value = self.parseExpr()
        }
        self.match(@intFromEnum(Token.semicolon))
        return self.ast.addReturnStmt(value, self.spanSE(start, self.tok_end))
    }

    fn parseVarStmt(is_const: int) int {
        const start = self.tok_start
        self.advance()  // consume const/var/let
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected variable name")
            return null_node
        }
        const name = self.tok_text
        const name_start = self.tok_start
        self.advance()
        var type_expr = null_node
        if (self.match(@intFromEnum(Token.colon))) {
            type_expr = self.parseType()
        }
        // Destructuring: const a, b = expr
        if (self.tok == @intFromEnum(Token.comma)) {
            return self.parseDestructureStmtFrom(name, type_expr, name_start, start, is_const)
        }
        var value = null_node
        if (self.match(@intFromEnum(Token.assign))) {
            value = self.parseExpr()
        }
        self.match(@intFromEnum(Token.semicolon))
        return self.ast.addVarStmt(name, type_expr, value, is_const, 0, self.spanSE(start, self.tok_end))
    }

    fn parseWeakVarStmt() int {
        self.advance()  // consume 'weak'
        const start = self.tok_start
        const is_const = if (self.tok == @intFromEnum(Token.kw_const)) { 1 } else { 0 }
        self.advance()  // consume var/const
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected variable name")
            return null_node
        }
        const name = self.tok_text
        self.advance()
        var type_expr = null_node
        if (self.match(@intFromEnum(Token.colon))) {
            type_expr = self.parseType()
        }
        var value = null_node
        if (self.match(@intFromEnum(Token.assign))) {
            value = self.parseExpr()
        }
        self.match(@intFromEnum(Token.semicolon))
        return self.ast.addVarStmt(name, type_expr, value, is_const, 1, self.spanSE(start, self.tok_end))
    }

    /// if (cond) |cap| { then } else { else }
    fn parseIfStmt() int {
        const start = self.tok_start
        self.advance()  // consume 'if'
        if (!self.expect(@intFromEnum(Token.lparen))) {
            return null_node
        }
        const cond = self.parseExpr()
        if (!self.expect(@intFromEnum(Token.rparen))) {
            return null_node
        }
        var capture = ""
        if (self.tok == @intFromEnum(Token.@"or")) {
            self.advance()
            if (self.tok == @intFromEnum(Token.ident)) {
                capture = self.tok_text
                self.advance()
            }
            self.expect(@intFromEnum(Token.@"or"))
        }
        const then_br = self.parseBlock()
        var else_br = null_node
        if (self.match(@intFromEnum(Token.kw_else))) {
            if (self.tok == @intFromEnum(Token.kw_if)) {
                else_br = self.parseIfStmt()
            } else {
                else_br = self.parseBlock()
            }
        }
        return self.ast.addIfStmt(cond, then_br, else_br, capture, self.spanSE(start, self.tok_end))
    }

    /// while (cond) |cap| : (continue_expr) { body }
    fn parseWhileStmt(label: string) int {
        const start = self.tok_start
        self.advance()  // consume 'while'
        if (!self.expect(@intFromEnum(Token.lparen))) {
            return null_node
        }
        const cond = self.parseExpr()
        if (!self.expect(@intFromEnum(Token.rparen))) {
            return null_node
        }
        var capture = ""
        if (self.tok == @intFromEnum(Token.@"or")) {
            self.advance()
            if (self.tok == @intFromEnum(Token.ident)) {
                capture = self.tok_text
                self.advance()
            }
            self.expect(@intFromEnum(Token.@"or"))
        }
        var cont = null_node
        if (self.match(@intFromEnum(Token.colon))) {
            if (self.match(@intFromEnum(Token.lparen))) {
                cont = self.parseExpr()
                self.expect(@intFromEnum(Token.rparen))
            }
        }
        const body = self.parseBlock()
        return self.ast.addWhileStmt(cond, body, capture, cont, label, self.spanSE(start, self.tok_end))
    }

    /// for item in iterable { body } or for i in 0..10 { body }
    fn parseForStmt(label: string, is_inline: int) int {
        const start = self.tok_start
        self.advance()  // consume 'for'
        // Binding name
        if (self.tok != @intFromEnum(Token.ident)) {
            self.errors.report(self.tok_start, ErrorCode.e203, "expected loop variable name")
            return null_node
        }
        const binding = self.tok_text
        self.advance()
        // Optional index binding: for item, i in ...
        var index_binding = ""
        if (self.match(@intFromEnum(Token.comma))) {
            if (self.tok == @intFromEnum(Token.ident)) {
                index_binding = self.tok_text
                self.advance()
            }
        }
        self.expect(@intFromEnum(Token.kw_in))
        // Range (0..10) or iterable
        const range_or_iter = self.parseExpr()
        var range_start = null_node
        var range_end = null_node
        var iterable = null_node
        if (self.tok == @intFromEnum(Token.period_period)) {
            // Range: start..end
            self.advance()
            range_start = range_or_iter
            range_end = self.parseExpr()
        } else {
            iterable = range_or_iter
        }
        const body = self.parseBlock()
        return self.ast.addForStmt(binding, index_binding, iterable, range_start, range_end, body, is_inline, label, self.spanSE(start, self.tok_end))
    }

    fn parseInlineFor() int {
        self.advance()  // consume 'inline'
        if (self.tok != @intFromEnum(Token.kw_for)) {
            self.errors.report(self.tok_start, ErrorCode.e200, "expected for after inline")
            return null_node
        }
        return self.parseForStmt("", 1)
    }

    fn parseBreakStmt() int {
        const start = self.tok_start
        self.advance()  // consume 'break'
        var label = ""
        if (self.tok == @intFromEnum(Token.colon) or self.tok == @intFromEnum(Token.ident)) {
            if (self.tok == @intFromEnum(Token.ident)) {
                label = self.tok_text
                self.advance()
            }
        }
        self.match(@intFromEnum(Token.semicolon))
        return self.ast.addBreakStmt(label, self.spanSE(start, self.tok_end))
    }

    fn parseContinueStmt() int {
        const start = self.tok_start
        self.advance()  // consume 'continue'
        var label = ""
        if (self.tok == @intFromEnum(Token.ident)) {
            label = self.tok_text
            self.advance()
        }
        self.match(@intFromEnum(Token.semicolon))
        return self.ast.addContinueStmt(label, self.spanSE(start, self.tok_end))
    }

    fn parseDeferStmt(is_errdefer: int) int {
        const start = self.tok_start
        self.advance()  // consume 'defer'/'errdefer'
        const expr = if (self.tok == @intFromEnum(Token.lbrace)) { self.parseBlock() } else { self.parseExpr() }
        self.match(@intFromEnum(Token.semicolon))
        return self.ast.addDeferStmt(expr, is_errdefer, self.spanSE(start, self.tok_end))
    }

    /// Destructure statement: const a, b = expr (called after first binding parsed)
    fn parseDestructureStmtFrom(first_name: string, first_type: int, first_start: int, start: int, is_const: int) int {
        var bindings: List(int) = undefined
        bindings.items = 0
        bindings.count = 0
        bindings.capacity = 0
        bindings.append(self.ast.addDestructureBind(first_name, first_type, self.spanSE(first_start, self.tok_end)))
        while (self.match(@intFromEnum(Token.comma))) {
            if (self.tok != @intFromEnum(Token.ident)) {
                self.errors.report(self.tok_start, ErrorCode.e203, "expected variable name")
                break
            }
            const bname = self.tok_text
            const bstart = self.tok_start
            self.advance()
            var btype = null_node
            if (self.match(@intFromEnum(Token.colon))) {
                btype = self.parseType()
            }
            bindings.append(self.ast.addDestructureBind(bname, btype, self.spanSE(bstart, self.tok_end)))
        }
        if (!self.expect(@intFromEnum(Token.assign))) {
            return null_node
        }
        const value = self.parseExpr()
        self.match(@intFromEnum(Token.semicolon))
        return self.ast.addDestructureStmt(value, is_const, bindings, self.spanSE(start, self.tok_end))
    }

    /// Expression statement or assignment: expr = value
    fn parseExprOrAssign() int {
        const start = self.tok_start
        const expr = self.parseExpr()
        if (expr == null_node) {
            return null_node
        }
        const tok = @as(Token, @enumFromInt(self.tok))
        if (tok.isAssignment()) {
            const op = self.tok
            self.advance()
            const value = self.parseExpr()
            self.match(@intFromEnum(Token.semicolon))
            return self.ast.addAssignStmt(expr, op, value, self.spanSE(start, self.tok_end))
        }
        self.match(@intFromEnum(Token.semicolon))
        return self.ast.addExprStmt(expr, self.spanSE(start, self.tok_end))
    }

    // ================================================================
    // Phase D: Block + Type parsing
    // ================================================================

    /// Parse a { ... } block.
    fn parseBlock() int {
        const start = self.tok_start
        if (!self.expect(@intFromEnum(Token.lbrace))) {
            return null_node
        }
        var stmts: List(int) = undefined
        stmts.items = 0
        stmts.count = 0
        stmts.capacity = 0
        while (self.tok != @intFromEnum(Token.rbrace) and self.tok != @intFromEnum(Token.eof)) {
            const s = self.parseStmt()
            if (s != null_node) {
                stmts.append(s)
            }
        }
        self.expect(@intFromEnum(Token.rbrace))
        return self.ast.addBlockStmt(stmts, self.spanSE(start, self.tok_end))
    }

    /// Parse a type expression.
    fn parseType() int {
        const start = self.tok_start
        // Optional prefix: ?, *, !
        if (self.tok == @intFromEnum(Token.question)) {
            self.advance()
            const inner = self.parseType()
            return self.ast.addTypeExpr(2, inner, null_node, self.spanSE(start, self.tok_end))  // kind=2 optional
        }
        if (self.tok == @intFromEnum(Token.mul)) {
            self.advance()
            const inner = self.parseType()
            return self.ast.addTypeExpr(1, inner, null_node, self.spanSE(start, self.tok_end))  // kind=1 pointer
        }
        if (self.tok == @intFromEnum(Token.lnot)) {
            self.advance()
            const inner = self.parseType()
            return self.ast.addTypeExpr(3, inner, null_node, self.spanSE(start, self.tok_end))  // kind=3 error union
        }
        // Slice: []T
        if (self.tok == @intFromEnum(Token.lbrack)) {
            self.advance()
            if (self.tok == @intFromEnum(Token.rbrack)) {
                self.advance()
                const elem = self.parseType()
                return self.ast.addTypeExpr(4, elem, null_node, self.spanSE(start, self.tok_end))  // kind=4 slice
            }
            // Array: [N]T
            const size_expr = self.parseExpr()
            self.expect(@intFromEnum(Token.rbrack))
            const elem = self.parseType()
            return self.ast.addTypeExpr(5, elem, size_expr, self.spanSE(start, self.tok_end))  // kind=5 array
        }
        // Named type or keyword type
        if (self.tok == @intFromEnum(Token.ident) or @as(Token, @enumFromInt(self.tok)).isTypeKeyword()) {
            const name = self.tok_text
            self.advance()
            // Check for generic: Type(Args)
            if (self.tok == @intFromEnum(Token.lparen)) {
                const name_node = self.ast.addIdent(name, self.spanSE(start, self.tok_end))
                self.advance()  // consume (
                var type_args: List(int) = undefined
                type_args.items = 0
                type_args.count = 0
                type_args.capacity = 0
                while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
                    type_args.append(self.parseType())
                    if (!self.match(@intFromEnum(Token.comma))) {
                        break
                    }
                }
                self.expect(@intFromEnum(Token.rparen))
                return self.ast.addGenericInst(name, type_args, self.spanSE(start, self.tok_end))
            }
            return self.ast.addIdent(name, self.spanSE(start, self.tok_end))
        }
        // fn type
        if (self.tok == @intFromEnum(Token.kw_fn)) {
            return self.parseFnType(start)
        }
        self.errors.report(start, ErrorCode.e202, "expected type")
        return null_node
    }

    fn parseFnType(start: int) int {
        // Ported from parser.zig:800-812: fn(Type, Type) -> RetType
        self.advance()  // consume 'fn'
        self.expect(@intFromEnum(Token.lparen))
        // Parse function type parameter types
        var param_count = 0
        while (self.tok != @intFromEnum(Token.rparen) and self.tok != @intFromEnum(Token.eof)) {
            self.parseType()
            param_count = param_count + 1
            if (!self.match(@intFromEnum(Token.comma))) {
                break
            }
        }
        self.expect(@intFromEnum(Token.rparen))
        // Return type after '->'
        var ret = null_node
        if (self.match(@intFromEnum(Token.arrow))) {
            ret = self.parseType()
        }
        return self.ast.addTypeExpr(6, ret, null_node, self.spanSE(start, self.tok_end))  // kind=6 function
    }

    // ================================================================
    // Phase G: Error recovery
    // ================================================================

    /// Skip tokens until we find a declaration-starting keyword.
    /// Used for error recovery after parse errors.
    fn synchronize() void {
        while (self.tok != @intFromEnum(Token.eof)) {
            const tok = @as(Token, @enumFromInt(self.tok))
            if (tok == Token.kw_fn or tok == Token.kw_const or tok == Token.kw_var or
                tok == Token.kw_struct or tok == Token.kw_enum or tok == Token.kw_union or
                tok == Token.kw_impl or tok == Token.kw_trait or tok == Token.kw_import or
                tok == Token.kw_test or tok == Token.kw_bench or tok == Token.kw_type or
                tok == Token.kw_extern) {
                return
            }
            self.advance()
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

test "parser init" {
    const src = "const x = 42"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    @assertEq(errors.hasErrors(), false)
    // Verify first token was loaded
    @assertEq(p.tok, @intFromEnum(Token.kw_const))
}

test "parse import" {
    const src = "import \"std/list\""
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.import_decl))
}

test "parse const decl" {
    const src = "const x = 42"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.var_decl))
}

test "parse fn decl" {
    const src = "fn main() void { return }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.fn_decl))
}

test "parse test decl" {
    const src = "test \"basic\" { @assertEq(1, 1) }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.test_decl))
}

test "parse struct decl" {
    const src = "struct Point { x: int, y: int }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.struct_decl))
}

test "parse multiple decls" {
    const src = "import \"std/list\"\nconst x = 1\nfn foo() void { }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 3)
}

test "parse binary expr" {
    const src = "const x = 1 + 2 * 3"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 1)
}

test "parse if stmt" {
    const src = "fn f() void { if (x > 0) { return x } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
}

test "parse while stmt" {
    const src = "fn f() void { while (true) { break } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
}

test "parse for stmt" {
    const src = "fn f() void { for i in 0..10 { } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
}

// ============================================================================
// Phase E: Complex expressions
// ============================================================================

test "parse builtin call" {
    const src = "fn f() void { @assertEq(1, 2) }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
}

test "parse closure expr" {
    const src = "const f = fn(x: int) int { return x * 2 }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 1)
}

test "parse struct init" {
    const src = "fn f() void { const p = Point { .x = 1, .y = 2 } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
}

test "parse anon struct literal" {
    const src = "fn f() void { const p = .{ .x = 1, .y = 2 } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
}

// ============================================================================
// Phase F: Labels, destructuring, inline types, backtracking
// ============================================================================

test "parse enum decl" {
    const src = "const Color = enum { red, green, blue }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.enum_decl))
}

test "parse enum with backing type" {
    const src = "const Flags = enum(u8) { a = 1, b = 2, c = 4 }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.enum_decl))
}

test "parse error set decl" {
    const src = "const FileError = error { NotFound, PermissionDenied, IoError }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.error_set_decl))
}

test "parse union decl" {
    const src = "const Value = union { int_val: int, str_val: string }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.union_decl))
}

test "parse inline struct decl" {
    const src = "const Pair = struct { a: int, b: int }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.struct_decl))
}

test "parse const non-type backtrack" {
    // const x = regular_expr must backtrack when '=' is not followed by a type keyword
    const src = "const x = 42\nconst y = x + 1"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 2)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.var_decl))
    @assertEq(ast.getTag(ast.file_decls.get(1)), @intFromEnum(NodeTag.var_decl))
}

test "parse labeled while" {
    const src = "fn f() void { outer: while (true) { break } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
}

test "parse labeled for" {
    const src = "fn f() void { outer: for i in 0..10 { break } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
}

test "parse fn type simple" {
    const src = "const f: fn(int) -> int = null"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
}

test "parse fn type as param" {
    const src = "fn apply(f: fn(int) -> int, x: int) int { return f(x) }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
}

test "parse mixed inline types" {
    const src = "const Color = enum { red }\nconst E = error { Fail }\nconst x = 42"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.hasErrors(), false)
    @assertEq(ast.file_decls.count, 3)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.enum_decl))
    @assertEq(ast.getTag(ast.file_decls.get(1)), @intFromEnum(NodeTag.error_set_decl))
    @assertEq(ast.getTag(ast.file_decls.get(2)), @intFromEnum(NodeTag.var_decl))
}

test "parse impl block with param" {
    const src = "impl Foo { fn bar(x: int) int { return 0 } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.impl_block))
}

test "parse generic fn" {
    const src = "fn max(T)(a: T, b: T) T { return a }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.fn_decl))
}

test "parse generic impl block" {
    const src = "impl List(T) { fn push(val: T) void { return } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.impl_block))
}

test "parse impl trait for type" {
    const src = "impl Display for Point { fn toString(s: *Point) string { return \"\" } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.impl_trait))
}

test "parse where clause" {
    const src = "fn sort(T)(list: *T) void where T: Ord { return }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.fn_decl))
}

test "parse where clause multi" {
    const src = "fn combine(T, U)(a: T, b: U) int where T: Display, U: Clone { return 0 }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.fn_decl))
}

test "parse switch range pattern" {
    const src = "fn f(x: int) int { return switch (x) { 1..5 => 1, else => 0 } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
}

test "parse switch guard" {
    const src = "fn f(x: int) int { return switch (x) { 1 if x > 0 => 1, else => 0 } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
}

test "parse switch wildcard" {
    const src = "fn f(x: int) int { return switch (x) { 1 => 10, _ => 0 } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
}

test "parse generic impl trait" {
    const src = "impl Iterable(T) for List { fn next(s: *List) int { return 0 } }"
    var s = scannerInit(src)
    var ast = astInit("test.cot")
    var errors = reporterInit()
    var p = parserInit(s, ast, errors)
    p.parseFile()
    @assertEq(errors.errorCount(), 0)
    @assertEq(ast.file_decls.count, 1)
    @assertEq(ast.getTag(ast.file_decls.get(0)), @intFromEnum(NodeTag.impl_trait))
}
