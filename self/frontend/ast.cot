/// Abstract Syntax Tree node definitions.
/// Ported from compiler/frontend/ast.zig

// ============================================================================
// Node index — reference AST nodes by position in the node array
// ============================================================================

const null_node: int = 0xFFFFFFFF

// ============================================================================
// Span — source location tracking
// ============================================================================

/// Half-open byte range [start, end) in source text.
struct Span {
    start: int,
    end: int,
}

// ============================================================================
// Declarations
// ============================================================================

/// Struct memory layout strategy.
const StructLayout = enum { auto, @"packed", @"extern" }

/// Function declaration.
struct FnDecl {
    name: string,
    return_type: int,
    body: int,
    is_extern: bool,
    is_async: bool,
    doc_comment: string,
    span: Span,
}

/// Variable or constant declaration.
struct VarDecl {
    name: string,
    type_expr: int,
    value: int,
    is_const: bool,
    doc_comment: string,
    span: Span,
}

/// Struct type declaration.
struct StructDecl {
    name: string,
    layout: int,
    doc_comment: string,
    span: Span,
}

/// Enum type declaration.
struct EnumDecl {
    name: string,
    backing_type: int,
    doc_comment: string,
    span: Span,
}

/// Tagged union declaration.
struct UnionDecl {
    name: string,
    doc_comment: string,
    span: Span,
}

/// Type alias declaration.
struct TypeAlias {
    name: string,
    target: int,
    doc_comment: string,
    span: Span,
}

/// Import declaration.
struct ImportDecl {
    path: string,
    span: Span,
}

/// Impl block (methods for a type).
struct ImplBlock {
    type_name: string,
    doc_comment: string,
    span: Span,
}

/// Trait declaration.
struct TraitDecl {
    name: string,
    doc_comment: string,
    span: Span,
}

/// Trait implementation for a type.
struct ImplTraitBlock {
    trait_name: string,
    target_type: string,
    doc_comment: string,
    span: Span,
}

/// Error set declaration.
struct ErrorSetDecl {
    name: string,
    doc_comment: string,
    span: Span,
}

/// Test block declaration.
struct TestDecl {
    name: string,
    body: int,
    span: Span,
}

/// Benchmark block declaration.
struct BenchDecl {
    name: string,
    body: int,
    span: Span,
}

/// Invalid declaration (parse error recovery).
struct BadDecl {
    span: Span,
}

/// Struct field definition.
struct Field {
    name: string,
    type_expr: int,
    default_value: int,
    doc_comment: string,
    span: Span,
}

/// Enum variant definition.
struct EnumVariant {
    name: string,
    value: int,
    span: Span,
}

/// Union variant definition.
struct UnionVariant {
    name: string,
    type_expr: int,
    span: Span,
}

/// Top-level declaration in a Cot source file.
union Decl {
    fn_decl: FnDecl,
    var_decl: VarDecl,
    struct_decl: StructDecl,
    enum_decl: EnumDecl,
    union_decl: UnionDecl,
    type_alias: TypeAlias,
    import_decl: ImportDecl,
    impl_block: ImplBlock,
    trait_decl: TraitDecl,
    impl_trait: ImplTraitBlock,
    error_set_decl: ErrorSetDecl,
    test_decl: TestDecl,
    bench_decl: BenchDecl,
    bad_decl: BadDecl,
}

/// Return the source span for any declaration.
fn declSpan(d: Decl) Span {
    switch d {
        Decl.fn_decl |v| => { return v.span },
        Decl.var_decl |v| => { return v.span },
        Decl.struct_decl |v| => { return v.span },
        Decl.enum_decl |v| => { return v.span },
        Decl.union_decl |v| => { return v.span },
        Decl.type_alias |v| => { return v.span },
        Decl.import_decl |v| => { return v.span },
        Decl.impl_block |v| => { return v.span },
        Decl.trait_decl |v| => { return v.span },
        Decl.impl_trait |v| => { return v.span },
        Decl.error_set_decl |v| => { return v.span },
        Decl.test_decl |v| => { return v.span },
        Decl.bench_decl |v| => { return v.span },
        Decl.bad_decl |v| => { return v.span },
    }
}

// ============================================================================
// Expressions
// ============================================================================

/// Literal value categories.
const LiteralKind = enum {
    @"int", @"float", @"string", char,
    true_lit, false_lit, null_lit, undefined_lit, unreachable_lit,
}

struct Ident { name: string, span: Span }
struct Literal { kind: int, value: string, span: Span }
struct Binary { op: int, left: int, right: int, span: Span }
struct Unary { op: int, operand: int, span: Span }
struct Call { callee: int, span: Span }
struct Index { base: int, idx: int, span: Span }
struct SliceExpr { base: int, start: int, end: int, span: Span }
struct FieldAccess { base: int, field: string, span: Span }
struct ArrayLiteral { span: Span }
struct Paren { inner: int, span: Span }
struct IfExpr { condition: int, then_branch: int, else_branch: int, capture: string, span: Span }
struct SwitchExpr { subject: int, else_body: int, span: Span }
struct SwitchCase { capture: string, guard: int, is_range: bool, body: int, span: Span }
struct BlockExpr { expr: int, span: Span }
struct StructInit { type_name: string, span: Span }
struct FieldInit { name: string, value: int, span: Span }
struct NewExpr { type_name: string, is_constructor: bool, span: Span }
struct BuiltinCall { kind: int, type_arg: int, span: Span }
struct StringInterp { span: Span }
struct TypeExpr { span: Span }
struct TryExpr { operand: int, span: Span }
struct AwaitExpr { operand: int, span: Span }
struct CatchExpr { operand: int, capture: string, fallback: int, span: Span }
struct ErrorLiteral { error_name: string, span: Span }
struct ClosureExpr { return_type: int, body: int, span: Span }
struct TupleLiteral { span: Span }
struct ComptimeBlock { body: int, span: Span }
struct ZeroInit { span: Span }
struct AddrOf { operand: int, span: Span }
struct Deref { operand: int, span: Span }
struct BadExpr { span: Span }

/// Any expression node.
union Expr {
    ident: Ident,
    literal: Literal,
    binary: Binary,
    unary: Unary,
    call: Call,
    index: Index,
    slice_expr: SliceExpr,
    field_access: FieldAccess,
    array_literal: ArrayLiteral,
    paren: Paren,
    if_expr: IfExpr,
    switch_expr: SwitchExpr,
    block_expr: BlockExpr,
    struct_init: StructInit,
    new_expr: NewExpr,
    builtin_call: BuiltinCall,
    string_interp: StringInterp,
    type_expr: TypeExpr,
    try_expr: TryExpr,
    await_expr: AwaitExpr,
    catch_expr: CatchExpr,
    error_literal: ErrorLiteral,
    closure_expr: ClosureExpr,
    tuple_literal: TupleLiteral,
    comptime_block: ComptimeBlock,
    zero_init: ZeroInit,
    addr_of: AddrOf,
    deref: Deref,
    bad_expr: BadExpr,
}

/// Return the source span for any expression.
fn exprSpan(e: Expr) Span {
    switch e {
        Expr.ident |v| => { return v.span },
        Expr.literal |v| => { return v.span },
        Expr.binary |v| => { return v.span },
        Expr.unary |v| => { return v.span },
        Expr.call |v| => { return v.span },
        Expr.index |v| => { return v.span },
        Expr.slice_expr |v| => { return v.span },
        Expr.field_access |v| => { return v.span },
        Expr.array_literal |v| => { return v.span },
        Expr.paren |v| => { return v.span },
        Expr.if_expr |v| => { return v.span },
        Expr.switch_expr |v| => { return v.span },
        Expr.block_expr |v| => { return v.span },
        Expr.struct_init |v| => { return v.span },
        Expr.new_expr |v| => { return v.span },
        Expr.builtin_call |v| => { return v.span },
        Expr.string_interp |v| => { return v.span },
        Expr.type_expr |v| => { return v.span },
        Expr.try_expr |v| => { return v.span },
        Expr.await_expr |v| => { return v.span },
        Expr.catch_expr |v| => { return v.span },
        Expr.error_literal |v| => { return v.span },
        Expr.closure_expr |v| => { return v.span },
        Expr.tuple_literal |v| => { return v.span },
        Expr.comptime_block |v| => { return v.span },
        Expr.zero_init |v| => { return v.span },
        Expr.addr_of |v| => { return v.span },
        Expr.deref |v| => { return v.span },
        Expr.bad_expr |v| => { return v.span },
    }
}

// ============================================================================
// Statements
// ============================================================================

struct ExprStmt { expr: int, span: Span }
struct ReturnStmt { value: int, span: Span }
struct VarStmt { name: string, type_expr: int, value: int, is_const: bool, is_weak: bool, span: Span }
struct AssignStmt { target: int, op: int, value: int, span: Span }
struct IfStmt { condition: int, then_branch: int, else_branch: int, capture: string, span: Span }
struct WhileStmt { condition: int, body: int, capture: string, continue_expr: int, span: Span }
struct ForStmt {
    binding: string,
    iterable: int,
    range_start: int,
    range_end: int,
    body: int,
    is_inline: bool,
    span: Span,
}
struct BlockStmt { span: Span }
struct BreakStmt { span: Span }
struct ContinueStmt { span: Span }
struct DeferStmt { expr: int, is_errdefer: bool, span: Span }
struct DestructureBinding { name: string, type_expr: int, span: Span }
struct DestructureStmt { value: int, is_const: bool, span: Span }
struct BadStmt { span: Span }

/// Any statement node.
union Stmt {
    expr_stmt: ExprStmt,
    return_stmt: ReturnStmt,
    var_stmt: VarStmt,
    assign_stmt: AssignStmt,
    if_stmt: IfStmt,
    while_stmt: WhileStmt,
    for_stmt: ForStmt,
    block_stmt: BlockStmt,
    break_stmt: BreakStmt,
    continue_stmt: ContinueStmt,
    defer_stmt: DeferStmt,
    destructure_stmt: DestructureStmt,
    bad_stmt: BadStmt,
}

/// Return the source span for any statement.
fn stmtSpan(s: Stmt) Span {
    switch s {
        Stmt.expr_stmt |v| => { return v.span },
        Stmt.return_stmt |v| => { return v.span },
        Stmt.var_stmt |v| => { return v.span },
        Stmt.assign_stmt |v| => { return v.span },
        Stmt.if_stmt |v| => { return v.span },
        Stmt.while_stmt |v| => { return v.span },
        Stmt.for_stmt |v| => { return v.span },
        Stmt.block_stmt |v| => { return v.span },
        Stmt.break_stmt |v| => { return v.span },
        Stmt.continue_stmt |v| => { return v.span },
        Stmt.defer_stmt |v| => { return v.span },
        Stmt.destructure_stmt |v| => { return v.span },
        Stmt.bad_stmt |v| => { return v.span },
    }
}

// ============================================================================
// Unified Node
// ============================================================================

/// Any AST node (declaration, expression, or statement).
union Node {
    decl: Decl,
    expr: Expr,
    stmt: Stmt,
}

/// Return the source span for any node.
fn nodeSpan(n: Node) Span {
    switch n {
        Node.decl |d| => { return declSpan(d) },
        Node.expr |e| => { return exprSpan(e) },
        Node.stmt |s| => { return stmtSpan(s) },
    }
}

// ============================================================================
// BuiltinKind — compiler intrinsic @builtin variants (v0.3.2)
// Runtime functions (alloc, fd_write, etc.) moved to stdlib/sys.cot as extern fn.
// ============================================================================

/// Compiler intrinsic builtins (the @-prefixed functions).
const BuiltinKind = enum {
    // Type introspection
    size_of, align_of, enum_len, has_field, type_of, field, offset_of,
    // Comptime reflection
    type_name, enum_name, type_info,
    // Casts
    int_cast, float_cast, float_from_int, int_from_float,
    ptr_cast, int_to_ptr, ptr_to_int, bit_cast, truncate, @"as",
    align_cast, const_cast,
    // Enum/error/bool conversions
    int_from_enum, enum_from_int, tag_name, error_name, int_from_bool,
    // String construction + decomposition
    @"string", ptr_of, len_of,
    // Assertions
    assert, assertEq,
    // Control
    trap, panic,
    // Comptime
    compile_error, embed_file, target, targetOs, targetArch,
    // ARC management
    arcRetain, arcRelease,
}

/// Look up a builtin name string and return its BuiltinKind index, or null if unknown.
fn builtinFromString(name: string) ?int {
    return switch (name) {
        // Type introspection
        "sizeOf" => @intFromEnum(BuiltinKind.size_of),
        "alignOf" => @intFromEnum(BuiltinKind.align_of),
        "enumLen" => @intFromEnum(BuiltinKind.enum_len),
        "hasField" => @intFromEnum(BuiltinKind.has_field),
        "TypeOf" => @intFromEnum(BuiltinKind.type_of),
        "field" => @intFromEnum(BuiltinKind.field),
        "offsetOf" => @intFromEnum(BuiltinKind.offset_of),
        // Comptime reflection
        "typeName" => @intFromEnum(BuiltinKind.type_name),
        "enumName" => @intFromEnum(BuiltinKind.enum_name),
        "typeInfo" => @intFromEnum(BuiltinKind.type_info),
        // Casts
        "intCast" => @intFromEnum(BuiltinKind.int_cast),
        "floatCast" => @intFromEnum(BuiltinKind.float_cast),
        "floatFromInt" => @intFromEnum(BuiltinKind.float_from_int),
        "intFromFloat" => @intFromEnum(BuiltinKind.int_from_float),
        "ptrCast" => @intFromEnum(BuiltinKind.ptr_cast),
        "intToPtr" => @intFromEnum(BuiltinKind.int_to_ptr),
        "ptrToInt" => @intFromEnum(BuiltinKind.ptr_to_int),
        "bitCast" => @intFromEnum(BuiltinKind.bit_cast),
        "truncate" => @intFromEnum(BuiltinKind.truncate),
        "as" => @intFromEnum(BuiltinKind.@"as"),
        "alignCast" => @intFromEnum(BuiltinKind.align_cast),
        "constCast" => @intFromEnum(BuiltinKind.const_cast),
        // Enum/error/bool
        "intFromEnum" => @intFromEnum(BuiltinKind.int_from_enum),
        "enumFromInt" => @intFromEnum(BuiltinKind.enum_from_int),
        "tagName" => @intFromEnum(BuiltinKind.tag_name),
        "errorName" => @intFromEnum(BuiltinKind.error_name),
        "intFromBool" => @intFromEnum(BuiltinKind.int_from_bool),
        // String
        "string" => @intFromEnum(BuiltinKind.@"string"),
        "ptrOf" => @intFromEnum(BuiltinKind.ptr_of),
        "lenOf" => @intFromEnum(BuiltinKind.len_of),
        // Assertions
        "assert" => @intFromEnum(BuiltinKind.assert),
        "assertEq" => @intFromEnum(BuiltinKind.assertEq),
        // Control
        "trap" => @intFromEnum(BuiltinKind.trap),
        "panic" => @intFromEnum(BuiltinKind.panic),
        // Comptime
        "compileError" => @intFromEnum(BuiltinKind.compile_error),
        "embedFile" => @intFromEnum(BuiltinKind.embed_file),
        "target" => @intFromEnum(BuiltinKind.target),
        "targetOs" => @intFromEnum(BuiltinKind.targetOs),
        "targetArch" => @intFromEnum(BuiltinKind.targetArch),
        // ARC
        "arcRetain" => @intFromEnum(BuiltinKind.arcRetain),
        "arcRelease" => @intFromEnum(BuiltinKind.arcRelease),
        else => null,
    }
}

// ============================================================================
// Tests
// ============================================================================

test "null_node sentinel" {
    @assertEq(null_node, 0xFFFFFFFF)
}

test "span init" {
    const s = Span { start: 5, end: 10 }
    @assertEq(s.start, 5)
    @assertEq(s.end, 10)
}

test "span zero" {
    const s = Span { start: 0, end: 0 }
    @assertEq(s.start, 0)
    @assertEq(s.end, 0)
}

test "StructLayout enum" {
    @assertEq(@intFromEnum(StructLayout.auto), 0)
    @assertEq(@intFromEnum(StructLayout.@"packed"), 1)
    @assertEq(@intFromEnum(StructLayout.@"extern"), 2)
}

test "LiteralKind enum" {
    @assertEq(@intFromEnum(LiteralKind.@"int"), 0)
    @assertEq(@intFromEnum(LiteralKind.@"float"), 1)
    @assertEq(@intFromEnum(LiteralKind.@"string"), 2)
    @assertEq(@intFromEnum(LiteralKind.char), 3)
    @assertEq(@intFromEnum(LiteralKind.true_lit), 4)
    @assertEq(@intFromEnum(LiteralKind.null_lit), 6)
    @assertEq(@intFromEnum(LiteralKind.unreachable_lit), 8)
}

test "Decl union fn_decl" {
    const s = Span { start: 0, end: 10 }
    const fd = FnDecl { name: "main", return_type: null_node, body: null_node, is_extern: false, is_async: false, doc_comment: "", span: s }
    const d: Decl = Decl.fn_decl(fd)
    switch d {
        Decl.fn_decl |v| => {
            @assertEq(v.name, "main")
            @assertEq(v.span.start, 0)
            @assertEq(v.span.end, 10)
            @assertEq(v.is_extern, false)
        },
        else => unreachable,
    }
}

test "Decl union test_decl" {
    const s = Span { start: 5, end: 15 }
    const td = TestDecl { name: "my test", body: 42, span: s }
    const d: Decl = Decl.test_decl(td)
    switch d {
        Decl.test_decl |v| => {
            @assertEq(v.name, "my test")
            @assertEq(v.body, 42)
            @assertEq(v.span.start, 5)
            @assertEq(v.span.end, 15)
        },
        else => unreachable,
    }
}

test "Expr union ident" {
    const s = Span { start: 0, end: 3 }
    const id = Ident { name: "foo", span: s }
    const e: Expr = Expr.ident(id)
    switch e {
        Expr.ident |v| => {
            @assertEq(v.name, "foo")
            @assertEq(v.span.start, 0)
            @assertEq(v.span.end, 3)
        },
        else => unreachable,
    }
}

test "Expr union binary" {
    const s = Span { start: 0, end: 5 }
    const b = Binary { op: 0, left: 1, right: 2, span: s }
    const e: Expr = Expr.binary(b)
    switch e {
        Expr.binary |v| => {
            @assertEq(v.op, 0)
            @assertEq(v.left, 1)
            @assertEq(v.right, 2)
            @assertEq(v.span.end, 5)
        },
        else => unreachable,
    }
}

test "Stmt union return" {
    const s = Span { start: 0, end: 8 }
    const r = ReturnStmt { value: 42, span: s }
    const st: Stmt = Stmt.return_stmt(r)
    switch st {
        Stmt.return_stmt |v| => {
            @assertEq(v.value, 42)
            @assertEq(v.span.start, 0)
            @assertEq(v.span.end, 8)
        },
        else => unreachable,
    }
}

test "Node union wraps expr" {
    const s = Span { start: 1, end: 9 }
    const id = Ident { name: "x", span: s }
    const e: Expr = Expr.ident(id)
    const n: Node = Node.expr(e)
    var matched = false
    switch n {
        Node.expr |inner| => { matched = true },
        else => unreachable,
    }
    @assertEq(matched, true)
}

test "BuiltinKind enum count" {
    @assertEq(@enumLen(BuiltinKind), 41)
}

test "builtinFromString known" {
    @assertEq(builtinFromString("sizeOf").?, @intFromEnum(BuiltinKind.size_of))
    @assertEq(builtinFromString("intCast").?, @intFromEnum(BuiltinKind.int_cast))
    @assertEq(builtinFromString("assertEq").?, @intFromEnum(BuiltinKind.assertEq))
    @assertEq(builtinFromString("typeName").?, @intFromEnum(BuiltinKind.type_name))
    @assertEq(builtinFromString("typeInfo").?, @intFromEnum(BuiltinKind.type_info))
    @assertEq(builtinFromString("panic").?, @intFromEnum(BuiltinKind.panic))
    @assertEq(builtinFromString("arcRetain").?, @intFromEnum(BuiltinKind.arcRetain))
    @assertEq(builtinFromString("arcRelease").?, @intFromEnum(BuiltinKind.arcRelease))
}

test "builtinFromString unknown" {
    @assertEq(builtinFromString("nonexistent") == null, true)
    @assertEq(builtinFromString("") == null, true)
    // Runtime functions are no longer builtins
    @assertEq(builtinFromString("fd_write") == null, true)
    @assertEq(builtinFromString("alloc") == null, true)
    @assertEq(builtinFromString("net_socket") == null, true)
}

test "BuiltinKind quoted identifiers" {
    @assertEq(builtinFromString("string").?, @intFromEnum(BuiltinKind.@"string"))
    @assertEq(builtinFromString("as").?, @intFromEnum(BuiltinKind.@"as"))
}

test "ForStmt isRange pattern" {
    const s = Span { start: 0, end: 10 }
    const fs = ForStmt { binding: "i", iterable: null_node, range_start: 0, range_end: 10, body: 1, is_inline: false, span: s }
    @assertEq(fs.range_start != null_node, true)
    const fs2 = ForStmt { binding: "item", iterable: 5, range_start: null_node, range_end: null_node, body: 1, is_inline: false, span: s }
    @assertEq(fs2.range_start != null_node, false)
}

test "VarStmt fields" {
    const s = Span { start: 0, end: 20 }
    const vs = VarStmt { name: "x", type_expr: null_node, value: 42, is_const: true, is_weak: false, span: s }
    @assertEq(vs.name, "x")
    @assertEq(vs.is_const, true)
    @assertEq(vs.is_weak, false)
    @assertEq(vs.value, 42)
}

test "nested union Decl in Node" {
    const s = Span { start: 0, end: 5 }
    const bd = BadDecl { span: s }
    const d: Decl = Decl.bad_decl(bd)
    const n: Node = Node.decl(d)
    var matched = false
    switch n {
        Node.decl |inner| => { matched = true },
        else => unreachable,
    }
    @assertEq(matched, true)
}
