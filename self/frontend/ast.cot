/// Abstract Syntax Tree — tagged union design.
/// Ported from compiler/frontend/ast.zig
///
/// Nodes are stored as tagged unions in a flat List(Node).
/// Each node is a Node union (decl/expr/stmt), with sub-unions
/// for Decl, Expr, and Stmt. Variant structs hold named fields
/// directly — no hardcoded offsets or parallel arrays.

import "std/list"
import "std/string"
import "source"

// ============================================================================
// Constants and basic types
// ============================================================================

const null_node: int = 0xFFFFFFFF

/// Struct memory layout strategy.
const StructLayout = enum { auto, @"packed", @"extern" }

/// Literal value categories.
const LiteralKind = enum {
    @"int", @"float", @"string", char,
    true_lit, false_lit, null_lit, undefined_lit, unreachable_lit,
}

// ============================================================================
// Type expression kind constants
// ============================================================================

const TYPE_NAMED: int = 0
const TYPE_POINTER: int = 1
const TYPE_OPTIONAL: int = 2
const TYPE_ERROR_UNION: int = 3
const TYPE_SLICE: int = 4
const TYPE_ARRAY: int = 5
const TYPE_FUNCTION: int = 6
const TYPE_MAP: int = 7
const TYPE_LIST: int = 8
const TYPE_TUPLE: int = 9
const TYPE_GENERIC_INSTANCE: int = 10

// ============================================================================
// Declaration variant structs
// ============================================================================

struct FnDecl {
    name: string,
    type_params: List(string),
    type_param_bounds: List(string),
    params: List(int),
    return_type: int,
    body: int,
    is_extern: bool,
    is_export: bool,
    is_async: bool,
    is_static: bool,
    doc_comment: string,
    span: Span,
}

struct VarDecl {
    name: string,
    type_expr: int,
    value: int,
    is_const: bool,
    doc_comment: string,
    span: Span,
}

struct StructDecl {
    name: string,
    type_params: List(string),
    fields: List(int),
    layout: int,
    nested_decls: List(int),
    doc_comment: string,
    span: Span,
}

struct EnumDecl {
    name: string,
    backing_type: int,
    variants: List(int),
    doc_comment: string,
    span: Span,
}

struct UnionDecl {
    name: string,
    variants: List(int),
    doc_comment: string,
    span: Span,
}

struct TypeAlias {
    name: string,
    target: int,
    doc_comment: string,
    span: Span,
}

struct ImportDecl {
    path: string,
    span: Span,
}

struct ImplBlock {
    type_name: string,
    type_params: List(string),
    methods: List(int),
    consts: List(int),
    doc_comment: string,
    span: Span,
}

struct TraitDecl {
    name: string,
    methods: List(int),
    doc_comment: string,
    span: Span,
}

struct ImplTraitBlock {
    trait_name: string,
    target_type: string,
    type_params: List(string),
    methods: List(int),
    doc_comment: string,
    span: Span,
}

struct ErrorSetDecl {
    name: string,
    variants: List(string),
    doc_comment: string,
    span: Span,
}

struct TestDecl {
    name: string,
    body: int,
    span: Span,
}

struct BenchDecl {
    name: string,
    body: int,
    span: Span,
}

struct BadDecl {
    span: Span,
}

// ============================================================================
// Expression variant structs
// ============================================================================

struct Ident {
    name: string,
    span: Span,
}

struct Literal {
    kind: int,
    value: string,
    span: Span,
}

struct Binary {
    op: int,
    left: int,
    right: int,
    span: Span,
}

struct Unary {
    op: int,
    operand: int,
    span: Span,
}

struct Call {
    callee: int,
    args: List(int),
    span: Span,
}

struct IndexExpr {
    base: int,
    idx: int,
    span: Span,
}

struct SliceExpr {
    base: int,
    start: int,
    end: int,
    span: Span,
}

struct FieldAccessExpr {
    base: int,
    field: string,
    span: Span,
}

struct ArrayLiteral {
    elements: List(int),
    span: Span,
}

struct Paren {
    inner: int,
    span: Span,
}

struct IfExpr {
    condition: int,
    then_branch: int,
    else_branch: int,
    capture: string,
    capture_is_ptr: bool,
    span: Span,
}

struct SwitchExpr {
    subject: int,
    cases: List(int),
    else_body: int,
    span: Span,
}

struct BlockExpr {
    stmts: List(int),
    result_expr: int,
    span: Span,
}

struct StructInitExpr {
    type_name: string,
    type_args: List(int),
    fields: List(int),
    span: Span,
}

struct NewExpr {
    type_name: string,
    type_args: List(int),
    fields: List(int),
    constructor_args: List(int),
    is_constructor: bool,
    span: Span,
}

struct BuiltinCallExpr {
    kind: int,
    type_arg: int,
    args: List(int),
    span: Span,
}

struct StringInterpExpr {
    segments: List(int),
    span: Span,
}

struct TypeExprNode {
    kind: int,
    data1: int,
    data2: int,
    span: Span,
}

struct TryExpr {
    operand: int,
    span: Span,
}

struct AwaitExpr {
    operand: int,
    span: Span,
}

struct CatchExpr {
    operand: int,
    capture: string,
    fallback: int,
    span: Span,
}

struct ErrorLiteralExpr {
    error_name: string,
    span: Span,
}

struct ClosureExpr {
    params: List(int),
    return_type: int,
    body: int,
    span: Span,
}

struct TupleLiteral {
    elements: List(int),
    span: Span,
}

struct ComptimeBlock {
    body: int,
    span: Span,
}

struct ZeroInit {
    span: Span,
}

struct AddrOf {
    operand: int,
    span: Span,
}

struct Deref {
    operand: int,
    span: Span,
}

struct GenericInstanceExpr {
    name: string,
    type_args: List(int),
    span: Span,
}

struct TupleTypeNode {
    elements: List(int),
    span: Span,
}

struct BadExpr {
    span: Span,
}

// ============================================================================
// Auxiliary node structs (sub-nodes referenced by declarations/expressions)
// ============================================================================

struct FieldDef {
    name: string,
    type_expr: int,
    default_value: int,
    doc_comment: string,
    span: Span,
}

struct FieldInitNode {
    name: string,
    value: int,
    span: Span,
}

struct EnumVariantNode {
    name: string,
    value: int,
    span: Span,
}

struct UnionVariantNode {
    name: string,
    type_expr: int,
    span: Span,
}

struct DestructureBindNode {
    name: string,
    type_expr: int,
    span: Span,
}

struct SwitchCaseNode {
    capture: string,
    guard: int,
    is_range: bool,
    body: int,
    patterns: List(int),
    span: Span,
}

// ============================================================================
// Statement variant structs
// ============================================================================

struct ExprStmt {
    expr: int,
    span: Span,
}

struct ReturnStmt {
    value: int,
    span: Span,
}

struct VarStmt {
    name: string,
    type_expr: int,
    value: int,
    is_const: bool,
    is_weak: bool,
    is_unowned: bool,
    span: Span,
}

struct AssignStmt {
    target: int,
    op: int,
    value: int,
    span: Span,
}

struct IfStmt {
    condition: int,
    then_branch: int,
    else_branch: int,
    capture: string,
    capture_is_ptr: bool,
    span: Span,
}

struct WhileStmt {
    condition: int,
    body: int,
    capture: string,
    capture_is_ptr: bool,
    continue_expr: int,
    label: string,
    span: Span,
}

struct ForStmt {
    binding: string,
    index_binding: string,
    iterable: int,
    range_start: int,
    range_end: int,
    body: int,
    is_inline: bool,
    label: string,
    span: Span,
}

struct BlockStmt {
    stmts: List(int),
    span: Span,
}

struct BreakStmt {
    label: string,
    span: Span,
}

struct ContinueStmt {
    label: string,
    span: Span,
}

struct DeferStmt {
    expr: int,
    is_errdefer: bool,
    span: Span,
}

struct DestructureStmt {
    bindings: List(int),
    value: int,
    is_const: bool,
    span: Span,
}

struct BadStmt {
    span: Span,
}

// ============================================================================
// Union type hierarchy
// ============================================================================

union Decl {
    fn_decl: FnDecl,
    var_decl: VarDecl,
    struct_decl: StructDecl,
    enum_decl: EnumDecl,
    union_decl: UnionDecl,
    type_alias: TypeAlias,
    import_decl: ImportDecl,
    impl_block: ImplBlock,
    trait_decl: TraitDecl,
    impl_trait: ImplTraitBlock,
    error_set_decl: ErrorSetDecl,
    test_decl: TestDecl,
    bench_decl: BenchDecl,
    bad_decl: BadDecl,
}

union Expr {
    ident: Ident,
    literal: Literal,
    binary: Binary,
    unary: Unary,
    call: Call,
    index_expr: IndexExpr,
    slice_expr: SliceExpr,
    field_access: FieldAccessExpr,
    array_literal: ArrayLiteral,
    paren: Paren,
    if_expr: IfExpr,
    switch_expr: SwitchExpr,
    block_expr: BlockExpr,
    struct_init: StructInitExpr,
    new_expr: NewExpr,
    builtin_call: BuiltinCallExpr,
    string_interp: StringInterpExpr,
    type_expr: TypeExprNode,
    try_expr: TryExpr,
    await_expr: AwaitExpr,
    catch_expr: CatchExpr,
    error_literal: ErrorLiteralExpr,
    closure_expr: ClosureExpr,
    tuple_literal: TupleLiteral,
    comptime_block: ComptimeBlock,
    zero_init: ZeroInit,
    addr_of: AddrOf,
    deref: Deref,
    generic_instance: GenericInstanceExpr,
    tuple_type: TupleTypeNode,
    bad_expr: BadExpr,
    field_def: FieldDef,
    field_init_node: FieldInitNode,
    enum_variant_node: EnumVariantNode,
    union_variant_node: UnionVariantNode,
    destructure_bind: DestructureBindNode,
    switch_case_node: SwitchCaseNode,
}

union Stmt {
    expr_stmt: ExprStmt,
    return_stmt: ReturnStmt,
    var_stmt: VarStmt,
    assign_stmt: AssignStmt,
    if_stmt: IfStmt,
    while_stmt: WhileStmt,
    for_stmt: ForStmt,
    block_stmt: BlockStmt,
    break_stmt: BreakStmt,
    continue_stmt: ContinueStmt,
    defer_stmt: DeferStmt,
    destructure_stmt: DestructureStmt,
    bad_stmt: BadStmt,
}

union Node {
    decl: Decl,
    expr: Expr,
    stmt: Stmt,
}

// ============================================================================
// AST container — tagged union node storage
// ============================================================================

struct Ast {
    nodes: List(Node),
    file_decls: List(int),
    filename: string,
    safe_mode: bool,

    static fn init(filename: string) Ast {
        var nodes: List(Node) = .{}
        var file_decls: List(int) = .{}
        return Ast {
            nodes: nodes,
            file_decls: file_decls,
            filename: filename,
            safe_mode: false,
        }
    }

    static fn initHeap(filename: string) *Ast {
        var nodes: List(Node) = .{}
        var file_decls: List(int) = .{}
        return new Ast {
            nodes: nodes,
            file_decls: file_decls,
            filename: filename,
            safe_mode: false,
        }
    }

    fn addNode(n: Node) int {
        const idx = self.nodes.count
        self.nodes.append(n)
        return idx
    }

    fn addDecl(d: Decl) int {
        return self.addNode(Node.decl(d))
    }

    fn addExpr(e: Expr) int {
        return self.addNode(Node.expr(e))
    }

    fn addStmt(s: Stmt) int {
        return self.addNode(Node.stmt(s))
    }

    fn getNode(idx: int) Node {
        return self.nodes.get(idx)
    }

    /// Get node at index, returning null for null_node or out-of-bounds indices.
    fn getNodeOpt(idx: int) ?Node {
        if (idx == null_node) { return null }
        if (idx < 0 or idx >= self.nodes.count) { return null }
        return self.nodes.get(idx)
    }

    fn nodeCount() int {
        return self.nodes.count
    }

    /// Check if node at idx is a Decl.
    fn isDecl(idx: int) bool {
        const node = self.nodes.get(idx)
        return switch (node) {
            Node.decl |_| => true,
            else => false,
        }
    }

    /// Check if node at idx is an Expr.
    fn isExpr(idx: int) bool {
        const node = self.nodes.get(idx)
        return switch (node) {
            Node.expr |_| => true,
            else => false,
        }
    }

    /// Check if node at idx is a Stmt.
    fn isStmt(idx: int) bool {
        const node = self.nodes.get(idx)
        return switch (node) {
            Node.stmt |_| => true,
            else => false,
        }
    }

    fn addFileDecl(idx: int) void {
        self.file_decls.append(idx)
    }

    fn getImports() List(string) {
        var imports: List(string) = .{}
        for i in 0..self.file_decls.count {
            const decl_idx = self.file_decls.get(i)
            const node = self.getNode(decl_idx)
            switch (node) {
                Node.decl |d| => {
                    switch (d) {
                        Decl.import_decl |imp| => {
                            const raw = imp.path
                            const path_str = substring(raw, 1, @lenOf(raw) - 1)
                            imports.append(path_str)
                        },
                        else => {},
                    }
                },
                else => {},
            }
        }
        return imports
    }

    /// Get the span of any node by index.
    fn nodeSpan(idx: int) Span {
        const node = self.getNode(idx)
        return switch (node) {
            Node.decl |d| => declSpan(d),
            Node.expr |e| => exprSpan(e),
            Node.stmt |s| => stmtSpan(s),
        }
    }
}

/// Extract span from a Decl.
fn declSpan(d: Decl) Span {
    return switch (d) {
        Decl.fn_decl |v| => v.span,
        Decl.var_decl |v| => v.span,
        Decl.struct_decl |v| => v.span,
        Decl.enum_decl |v| => v.span,
        Decl.union_decl |v| => v.span,
        Decl.type_alias |v| => v.span,
        Decl.import_decl |v| => v.span,
        Decl.impl_block |v| => v.span,
        Decl.trait_decl |v| => v.span,
        Decl.impl_trait |v| => v.span,
        Decl.error_set_decl |v| => v.span,
        Decl.test_decl |v| => v.span,
        Decl.bench_decl |v| => v.span,
        Decl.bad_decl |v| => v.span,
    }
}

/// Extract span from an Expr.
fn exprSpan(e: Expr) Span {
    return switch (e) {
        Expr.ident |v| => v.span,
        Expr.literal |v| => v.span,
        Expr.binary |v| => v.span,
        Expr.unary |v| => v.span,
        Expr.call |v| => v.span,
        Expr.index_expr |v| => v.span,
        Expr.slice_expr |v| => v.span,
        Expr.field_access |v| => v.span,
        Expr.array_literal |v| => v.span,
        Expr.paren |v| => v.span,
        Expr.if_expr |v| => v.span,
        Expr.switch_expr |v| => v.span,
        Expr.block_expr |v| => v.span,
        Expr.struct_init |v| => v.span,
        Expr.new_expr |v| => v.span,
        Expr.builtin_call |v| => v.span,
        Expr.string_interp |v| => v.span,
        Expr.type_expr |v| => v.span,
        Expr.try_expr |v| => v.span,
        Expr.await_expr |v| => v.span,
        Expr.catch_expr |v| => v.span,
        Expr.error_literal |v| => v.span,
        Expr.closure_expr |v| => v.span,
        Expr.tuple_literal |v| => v.span,
        Expr.comptime_block |v| => v.span,
        Expr.zero_init |v| => v.span,
        Expr.addr_of |v| => v.span,
        Expr.deref |v| => v.span,
        Expr.generic_instance |v| => v.span,
        Expr.tuple_type |v| => v.span,
        Expr.bad_expr |v| => v.span,
        Expr.field_def |v| => v.span,
        Expr.field_init_node |v| => v.span,
        Expr.enum_variant_node |v| => v.span,
        Expr.union_variant_node |v| => v.span,
        Expr.destructure_bind |v| => v.span,
        Expr.switch_case_node |v| => v.span,
    }
}

/// Extract span from a Stmt.
fn stmtSpan(s: Stmt) Span {
    return switch (s) {
        Stmt.expr_stmt |v| => v.span,
        Stmt.return_stmt |v| => v.span,
        Stmt.var_stmt |v| => v.span,
        Stmt.assign_stmt |v| => v.span,
        Stmt.if_stmt |v| => v.span,
        Stmt.while_stmt |v| => v.span,
        Stmt.for_stmt |v| => v.span,
        Stmt.block_stmt |v| => v.span,
        Stmt.break_stmt |v| => v.span,
        Stmt.continue_stmt |v| => v.span,
        Stmt.defer_stmt |v| => v.span,
        Stmt.destructure_stmt |v| => v.span,
        Stmt.bad_stmt |v| => v.span,
    }
}

// ============================================================================
// Node query helpers
// ============================================================================

/// Return a string tag name for a declaration node (for tests/debugging).
fn nodeDeclTag(ast: *Ast, idx: int) string {
    var result = ""
    const node = ast.getNode(idx)
    switch (node) {
        Node.decl |d| => {
            switch (d) {
                Decl.fn_decl |_| => { result = "fn_decl" },
                Decl.var_decl |_| => { result = "var_decl" },
                Decl.struct_decl |_| => { result = "struct_decl" },
                Decl.enum_decl |_| => { result = "enum_decl" },
                Decl.union_decl |_| => { result = "union_decl" },
                Decl.type_alias |_| => { result = "type_alias" },
                Decl.import_decl |_| => { result = "import_decl" },
                Decl.impl_block |_| => { result = "impl_block" },
                Decl.trait_decl |_| => { result = "trait_decl" },
                Decl.impl_trait |_| => { result = "impl_trait" },
                Decl.error_set_decl |_| => { result = "error_set_decl" },
                Decl.test_decl |_| => { result = "test_decl" },
                Decl.bench_decl |_| => { result = "bench_decl" },
                Decl.bad_decl |_| => { result = "bad_decl" },
            }
        },
        Node.expr |_| => { result = "expr" },
        Node.stmt |_| => { result = "stmt" },
    }
    return result
}

/// Get the name from a field_def node, or "".
fn nodeFieldDefName(ast: *Ast, idx: int) string {
    var result = ""
    const node = ast.getNode(idx)
    switch (node) {
        Node.expr |e| => {
            switch (e) {
                Expr.field_def |fd| => { result = fd.name },
                else => {},
            }
        },
        else => {},
    }
    return result
}

/// Check if a node is an ident expression and return the name, or "".
fn nodeIdentName(ast: *Ast, idx: int) string {
    var result = ""
    const node = ast.getNode(idx)
    switch (node) {
        Node.expr |e| => {
            switch (e) {
                Expr.ident |id| => { result = id.name },
                else => {},
            }
        },
        else => {},
    }
    return result
}

/// Check if a node is an expr_stmt and return the inner expr index, or null_node.
fn nodeExprStmtExpr(ast: *Ast, idx: int) int {
    var result = null_node
    const node = ast.getNode(idx)
    switch (node) {
        Node.stmt |s| => {
            switch (s) {
                Stmt.expr_stmt |es| => { result = es.expr },
                else => {},
            }
        },
        else => {},
    }
    return result
}

/// Return the tag string for a Decl.
fn declTagStr(d: Decl) string {
    return switch (d) {
        Decl.fn_decl |_| => "fn_decl",
        Decl.var_decl |_| => "var_decl",
        Decl.struct_decl |_| => "struct_decl",
        Decl.enum_decl |_| => "enum_decl",
        Decl.union_decl |_| => "union_decl",
        Decl.type_alias |_| => "type_alias",
        Decl.import_decl |_| => "import_decl",
        Decl.impl_block |_| => "impl_block",
        Decl.trait_decl |_| => "trait_decl",
        Decl.impl_trait |_| => "impl_trait",
        Decl.error_set_decl |_| => "error_set_decl",
        Decl.test_decl |_| => "test_decl",
        Decl.bench_decl |_| => "bench_decl",
        Decl.bad_decl |_| => "bad_decl",
    }
}

/// Return the tag string for an Expr (split to avoid large stack frames).
fn exprTagStr1(e: Expr) string {
    return switch (e) {
        Expr.ident |_| => "ident",
        Expr.literal |_| => "literal",
        Expr.binary |_| => "binary",
        Expr.unary |_| => "unary",
        Expr.call |_| => "call",
        Expr.index_expr |_| => "index_expr",
        Expr.slice_expr |_| => "slice_expr",
        Expr.field_access |_| => "field_access",
        Expr.array_literal |_| => "array_literal",
        Expr.paren |_| => "paren",
        Expr.if_expr |_| => "if_expr",
        Expr.switch_expr |_| => "switch_expr",
        Expr.block_expr |_| => "block_expr",
        Expr.struct_init |_| => "struct_init",
        Expr.new_expr |_| => "new_expr",
        Expr.builtin_call |_| => "builtin_call",
        Expr.string_interp |_| => "string_interp",
        Expr.type_expr |_| => "type_expr",
        else => "",
    }
}

fn exprTagStr2(e: Expr) string {
    return switch (e) {
        Expr.try_expr |_| => "try_expr",
        Expr.await_expr |_| => "await_expr",
        Expr.catch_expr |_| => "catch_expr",
        Expr.error_literal |_| => "error_literal",
        Expr.closure_expr |_| => "closure_expr",
        Expr.tuple_literal |_| => "tuple_literal",
        Expr.comptime_block |_| => "comptime_block",
        Expr.zero_init |_| => "zero_init",
        Expr.addr_of |_| => "addr_of",
        Expr.deref |_| => "deref",
        Expr.generic_instance |_| => "generic_instance",
        Expr.bad_expr |_| => "bad_expr",
        Expr.field_def |_| => "field_def",
        Expr.field_init_node |_| => "field_init_node",
        Expr.enum_variant_node |_| => "enum_variant_node",
        Expr.union_variant_node |_| => "union_variant_node",
        Expr.destructure_bind |_| => "destructure_bind",
        Expr.switch_case_node |_| => "switch_case_node",
        Expr.tuple_type |_| => "tuple_type",
        else => "",
    }
}

/// Return the tag string for a Stmt.
fn stmtTagStr(s: Stmt) string {
    return switch (s) {
        Stmt.expr_stmt |_| => "expr_stmt",
        Stmt.return_stmt |_| => "return_stmt",
        Stmt.var_stmt |_| => "var_stmt",
        Stmt.assign_stmt |_| => "assign_stmt",
        Stmt.if_stmt |_| => "if_stmt",
        Stmt.while_stmt |_| => "while_stmt",
        Stmt.for_stmt |_| => "for_stmt",
        Stmt.block_stmt |_| => "block_stmt",
        Stmt.break_stmt |_| => "break_stmt",
        Stmt.continue_stmt |_| => "continue_stmt",
        Stmt.defer_stmt |_| => "defer_stmt",
        Stmt.destructure_stmt |_| => "destructure_stmt",
        Stmt.bad_stmt |_| => "bad_stmt",
    }
}

/// Return the node tag as a string for any node (decl, expr, stmt).
fn nodeTag(ast: *Ast, idx: int) string {
    const node = ast.getNode(idx)
    return switch (node) {
        Node.decl |d| => declTagStr(d),
        Node.expr |e| => {
            const r1 = exprTagStr1(e)
            if (@lenOf(r1) > 0) { return r1 }
            return exprTagStr2(e)
        },
        Node.stmt |s| => stmtTagStr(s),
    }
}

// ============================================================================
// BuiltinKind — compiler intrinsic @builtin variants (v0.3.3)
// ============================================================================

/// Compiler intrinsic builtins (the @-prefixed functions).
const BuiltinKind = enum {
    // Type introspection
    size_of, align_of, enum_len, has_field, type_of, field, offset_of,
    // Comptime reflection
    type_name, enum_name, type_info,
    // Math unary
    abs, ceil, floor, trunc, round, sqrt,
    // Math binary
    fmin, fmax, min, max,
    // Casts
    int_cast, float_cast, float_from_int, int_from_float,
    ptr_cast, int_to_ptr, ptr_to_int, bit_cast, truncate, @"as",
    align_cast, const_cast,
    // Enum/error/bool conversions
    int_from_enum, enum_from_int, tag_name, error_name, int_from_bool,
    // String construction + decomposition
    @"string", ptr_of, len_of,
    // Bit manipulation
    ctz, clz, pop_count,
    // Assertions
    assert, assert_eq,
    // Control
    trap, panic,
    // Comptime
    compile_error, embed_file, target, target_os, target_arch,
    // ARC management
    arc_retain, arc_release,
    // Atomics — sequential consistency
    atomic_load, atomic_store, atomic_add, atomic_cas, atomic_exchange,
}

/// Look up a builtin name string and return its BuiltinKind index, or null if unknown.
fn builtinFromString(name: string) ?int {
    return switch (name) {
        "sizeOf" => @intFromEnum(BuiltinKind.size_of),
        "alignOf" => @intFromEnum(BuiltinKind.align_of),
        "enumLen" => @intFromEnum(BuiltinKind.enum_len),
        "hasField" => @intFromEnum(BuiltinKind.has_field),
        "TypeOf" => @intFromEnum(BuiltinKind.type_of),
        "field" => @intFromEnum(BuiltinKind.field),
        "offsetOf" => @intFromEnum(BuiltinKind.offset_of),
        "typeName" => @intFromEnum(BuiltinKind.type_name),
        "enumName" => @intFromEnum(BuiltinKind.enum_name),
        "typeInfo" => @intFromEnum(BuiltinKind.type_info),
        "abs" => @intFromEnum(BuiltinKind.abs),
        "ceil" => @intFromEnum(BuiltinKind.ceil),
        "floor" => @intFromEnum(BuiltinKind.floor),
        "trunc" => @intFromEnum(BuiltinKind.trunc),
        "round" => @intFromEnum(BuiltinKind.round),
        "sqrt" => @intFromEnum(BuiltinKind.sqrt),
        "fmin" => @intFromEnum(BuiltinKind.fmin),
        "fmax" => @intFromEnum(BuiltinKind.fmax),
        "min" => @intFromEnum(BuiltinKind.min),
        "max" => @intFromEnum(BuiltinKind.max),
        "intCast" => @intFromEnum(BuiltinKind.int_cast),
        "floatCast" => @intFromEnum(BuiltinKind.float_cast),
        "floatFromInt" => @intFromEnum(BuiltinKind.float_from_int),
        "intFromFloat" => @intFromEnum(BuiltinKind.int_from_float),
        "ptrCast" => @intFromEnum(BuiltinKind.ptr_cast),
        "intToPtr" => @intFromEnum(BuiltinKind.int_to_ptr),
        "ptrToInt" => @intFromEnum(BuiltinKind.ptr_to_int),
        "bitCast" => @intFromEnum(BuiltinKind.bit_cast),
        "truncate" => @intFromEnum(BuiltinKind.truncate),
        "as" => @intFromEnum(BuiltinKind.@"as"),
        "alignCast" => @intFromEnum(BuiltinKind.align_cast),
        "constCast" => @intFromEnum(BuiltinKind.const_cast),
        "intFromEnum" => @intFromEnum(BuiltinKind.int_from_enum),
        "enumFromInt" => @intFromEnum(BuiltinKind.enum_from_int),
        "tagName" => @intFromEnum(BuiltinKind.tag_name),
        "errorName" => @intFromEnum(BuiltinKind.error_name),
        "intFromBool" => @intFromEnum(BuiltinKind.int_from_bool),
        "string" => @intFromEnum(BuiltinKind.@"string"),
        "ptrOf" => @intFromEnum(BuiltinKind.ptr_of),
        "lenOf" => @intFromEnum(BuiltinKind.len_of),
        "ctz" => @intFromEnum(BuiltinKind.ctz),
        "clz" => @intFromEnum(BuiltinKind.clz),
        "popCount" => @intFromEnum(BuiltinKind.pop_count),
        "assert" => @intFromEnum(BuiltinKind.assert),
        "assertEq" => @intFromEnum(BuiltinKind.assert_eq),
        "trap" => @intFromEnum(BuiltinKind.trap),
        "panic" => @intFromEnum(BuiltinKind.panic),
        "compileError" => @intFromEnum(BuiltinKind.compile_error),
        "embedFile" => @intFromEnum(BuiltinKind.embed_file),
        "target" => @intFromEnum(BuiltinKind.target),
        "targetOs" => @intFromEnum(BuiltinKind.target_os),
        "targetArch" => @intFromEnum(BuiltinKind.target_arch),
        "arcRetain" => @intFromEnum(BuiltinKind.arc_retain),
        "arcRelease" => @intFromEnum(BuiltinKind.arc_release),
        "atomicLoad" => @intFromEnum(BuiltinKind.atomic_load),
        "atomicStore" => @intFromEnum(BuiltinKind.atomic_store),
        "atomicAdd" => @intFromEnum(BuiltinKind.atomic_add),
        "atomicCas" => @intFromEnum(BuiltinKind.atomic_cas),
        "atomicExchange" => @intFromEnum(BuiltinKind.atomic_exchange),
        else => null,
    }
}

// ============================================================================
// Node accessor helpers
// ============================================================================

/// Extract Decl from Node, or null if not a decl.
fn asDecl(n: Node) ?Decl {
    return switch (n) {
        Node.decl |d| => d,
        else => null,
    }
}

/// Extract Expr from Node, or null if not an expr.
fn asExpr(n: Node) ?Expr {
    return switch (n) {
        Node.expr |e| => e,
        else => null,
    }
}

/// Extract Stmt from Node, or null if not a stmt.
fn asStmt(n: Node) ?Stmt {
    return switch (n) {
        Node.stmt |s| => s,
        else => null,
    }
}

// ============================================================================
// ForStmt helper
// ============================================================================

/// Check if a ForStmt is a range-based for loop.
fn isRange(fs: ForStmt) bool {
    return fs.range_start != null_node
}

// ============================================================================
// builtinToString — reverse lookup from BuiltinKind to source name
// ============================================================================

fn builtinToString(kind: int) string {
    return switch (@enumFromInt(BuiltinKind, kind)) {
        BuiltinKind.size_of => "sizeOf",
        BuiltinKind.align_of => "alignOf",
        BuiltinKind.enum_len => "enumLen",
        BuiltinKind.has_field => "hasField",
        BuiltinKind.type_of => "TypeOf",
        BuiltinKind.field => "field",
        BuiltinKind.offset_of => "offsetOf",
        BuiltinKind.type_name => "typeName",
        BuiltinKind.enum_name => "enumName",
        BuiltinKind.type_info => "typeInfo",
        BuiltinKind.abs => "abs",
        BuiltinKind.ceil => "ceil",
        BuiltinKind.floor => "floor",
        BuiltinKind.trunc => "trunc",
        BuiltinKind.round => "round",
        BuiltinKind.sqrt => "sqrt",
        BuiltinKind.fmin => "fmin",
        BuiltinKind.fmax => "fmax",
        BuiltinKind.min => "min",
        BuiltinKind.max => "max",
        BuiltinKind.int_cast => "intCast",
        BuiltinKind.float_cast => "floatCast",
        BuiltinKind.float_from_int => "floatFromInt",
        BuiltinKind.int_from_float => "intFromFloat",
        BuiltinKind.ptr_cast => "ptrCast",
        BuiltinKind.int_to_ptr => "intToPtr",
        BuiltinKind.ptr_to_int => "ptrToInt",
        BuiltinKind.bit_cast => "bitCast",
        BuiltinKind.truncate => "truncate",
        BuiltinKind.@"as" => "as",
        BuiltinKind.align_cast => "alignCast",
        BuiltinKind.const_cast => "constCast",
        BuiltinKind.int_from_enum => "intFromEnum",
        BuiltinKind.enum_from_int => "enumFromInt",
        BuiltinKind.tag_name => "tagName",
        BuiltinKind.error_name => "errorName",
        BuiltinKind.int_from_bool => "intFromBool",
        BuiltinKind.@"string" => "string",
        BuiltinKind.ptr_of => "ptrOf",
        BuiltinKind.len_of => "lenOf",
        BuiltinKind.ctz => "ctz",
        BuiltinKind.clz => "clz",
        BuiltinKind.pop_count => "popCount",
        BuiltinKind.assert => "assert",
        BuiltinKind.assert_eq => "assertEq",
        BuiltinKind.trap => "trap",
        BuiltinKind.panic => "panic",
        BuiltinKind.compile_error => "compileError",
        BuiltinKind.embed_file => "embedFile",
        BuiltinKind.target => "target",
        BuiltinKind.target_os => "targetOs",
        BuiltinKind.target_arch => "targetArch",
        BuiltinKind.arc_retain => "arcRetain",
        BuiltinKind.arc_release => "arcRelease",
        BuiltinKind.atomic_load => "atomicLoad",
        BuiltinKind.atomic_store => "atomicStore",
        BuiltinKind.atomic_add => "atomicAdd",
        BuiltinKind.atomic_cas => "atomicCas",
        BuiltinKind.atomic_exchange => "atomicExchange",
    }
}

// ============================================================================
// Tests
// ============================================================================

test "null_node sentinel" {
    @assertEq(null_node, 0xFFFFFFFF)
}

test "span init" {
    const s = Span { .start = 5, .end = 10 }
    @assertEq(s.start, 5)
    @assertEq(s.end, 10)
}

test "StructLayout enum" {
    @assertEq(@intFromEnum(StructLayout.auto), 0)
    @assertEq(@intFromEnum(StructLayout.@"packed"), 1)
    @assertEq(@intFromEnum(StructLayout.@"extern"), 2)
}

test "LiteralKind enum" {
    @assertEq(@intFromEnum(LiteralKind.@"int"), 0)
    @assertEq(@intFromEnum(LiteralKind.@"float"), 1)
    @assertEq(@intFromEnum(LiteralKind.@"string"), 2)
    @assertEq(@intFromEnum(LiteralKind.char), 3)
    @assertEq(@intFromEnum(LiteralKind.true_lit), 4)
    @assertEq(@intFromEnum(LiteralKind.null_lit), 6)
    @assertEq(@intFromEnum(LiteralKind.unreachable_lit), 8)
}

test "BuiltinKind enum count" {
    @assertEq(@enumLen(BuiltinKind), 59)
}

test "builtinFromString known" {
    @assertEq(builtinFromString("sizeOf").?, @intFromEnum(BuiltinKind.size_of))
    @assertEq(builtinFromString("intCast").?, @intFromEnum(BuiltinKind.int_cast))
    @assertEq(builtinFromString("assertEq").?, @intFromEnum(BuiltinKind.assert_eq))
    @assertEq(builtinFromString("typeName").?, @intFromEnum(BuiltinKind.type_name))
    @assertEq(builtinFromString("typeInfo").?, @intFromEnum(BuiltinKind.type_info))
    @assertEq(builtinFromString("panic").?, @intFromEnum(BuiltinKind.panic))
    @assertEq(builtinFromString("arcRetain").?, @intFromEnum(BuiltinKind.arc_retain))
    @assertEq(builtinFromString("arcRelease").?, @intFromEnum(BuiltinKind.arc_release))
}

test "builtinFromString unknown" {
    @assert(builtinFromString("nonexistent") == null)
    @assert(builtinFromString("") == null)
    @assert(builtinFromString("fd_write") == null)
    @assert(builtinFromString("alloc") == null)
}

test "BuiltinKind quoted identifiers" {
    @assertEq(builtinFromString("string").?, @intFromEnum(BuiltinKind.@"string"))
    @assertEq(builtinFromString("as").?, @intFromEnum(BuiltinKind.@"as"))
}

test "Ast init" {
    var ast = Ast.init("test.cot")
    @assertEq(ast.nodeCount(), 0)
    @assertEq(ast.filename, "test.cot")
    @assertEq(ast.safe_mode, false)
}

test "Ast addExpr ident" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 5, .end = 8 }
    const idx = ast.addExpr(Expr.ident(Ident { .name = "foo", .span = s }))
    @assertEq(idx, 0)
    @assertEq(ast.nodeCount(), 1)
    const node = ast.getNode(0)
    switch (node) {
        Node.expr |e| => {
            switch (e) {
                Expr.ident |id| => {
                    @assertEq(id.name, "foo")
                    @assertEq(id.span.start, 5)
                    @assertEq(id.span.end, 8)
                },
                else => @assert(false),
            }
        },
        else => @assert(false),
    }
}

test "Ast addExpr binary" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 0, .end = 5 }
    const left = ast.addExpr(Expr.ident(Ident { .name = "a", .span = s }))
    const right = ast.addExpr(Expr.ident(Ident { .name = "b", .span = s }))
    const bin = ast.addExpr(Expr.binary(Binary { .op = 10, .left = left, .right = right, .span = s }))
    @assertEq(ast.nodeCount(), 3)
    const node = ast.getNode(bin)
    switch (node) {
        Node.expr |e| => {
            switch (e) {
                Expr.binary |b| => {
                    @assertEq(b.op, 10)
                    @assertEq(b.left, 0)
                    @assertEq(b.right, 1)
                },
                else => @assert(false),
            }
        },
        else => @assert(false),
    }
}

test "Ast addDecl fn_decl" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 0, .end = 20 }
    var params: List(int) = .{}
    var tp: List(string) = .{}
    var tpb: List(string) = .{}
    const fn_idx = ast.addDecl(Decl.fn_decl(FnDecl {
        .name = "main",
        .type_params = tp,
        .type_param_bounds = tpb,
        .params = params,
        .return_type = null_node,
        .body = null_node,
        .is_extern = false,
        .is_export = false,
        .is_async = false,
        .is_static = false,
        .doc_comment = "",
        .span = s,
    }))
    const node = ast.getNode(fn_idx)
    switch (node) {
        Node.decl |d| => {
            switch (d) {
                Decl.fn_decl |f| => @assertEq(f.name, "main"),
                else => @assert(false),
            }
        },
        else => @assert(false),
    }
}

test "Ast addDecl import" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 0, .end = 15 }
    const idx = ast.addDecl(Decl.import_decl(ImportDecl { .path = "\"std/list\"", .span = s }))
    const node = ast.getNode(idx)
    switch (node) {
        Node.decl |d| => {
            switch (d) {
                Decl.import_decl |imp| => @assertEq(imp.path, "\"std/list\""),
                else => @assert(false),
            }
        },
        else => @assert(false),
    }
}

test "Ast addStmt block" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 0, .end = 10 }
    const s0 = ast.addStmt(Stmt.return_stmt(ReturnStmt { .value = null_node, .span = s }))
    const s1 = ast.addStmt(Stmt.expr_stmt(ExprStmt { .expr = 0, .span = s }))
    var stmts: List(int) = .{}
    stmts.append(s0)
    stmts.append(s1)
    const blk = ast.addStmt(Stmt.block_stmt(BlockStmt { .stmts = stmts, .span = s }))
    const node = ast.getNode(blk)
    switch (node) {
        Node.stmt |st| => {
            switch (st) {
                Stmt.block_stmt |b| => @assertEq(b.stmts.count, 2),
                else => @assert(false),
            }
        },
        else => @assert(false),
    }
}

test "Ast file_decls" {
    var ast = Ast.init("main.cot")
    const s = Span { .start = 0, .end = 10 }
    const imp = ast.addDecl(Decl.import_decl(ImportDecl { .path = "\"std/list\"", .span = s }))
    const test_n = ast.addDecl(Decl.test_decl(TestDecl { .name = "basic", .body = null_node, .span = s }))
    ast.file_decls.append(imp)
    ast.file_decls.append(test_n)
    @assertEq(ast.file_decls.count, 2)
    @assertEq(ast.file_decls.get(0), imp)
    @assertEq(ast.file_decls.get(1), test_n)
}

test "Ast nodeSpan" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 5, .end = 15 }
    const idx = ast.addExpr(Expr.ident(Ident { .name = "x", .span = s }))
    const sp = ast.nodeSpan(idx)
    @assertEq(sp.start, 5)
    @assertEq(sp.end, 15)
}

test "getNodeOpt valid" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 0, .end = 5 }
    const idx = ast.addExpr(Expr.ident(Ident { .name = "x", .span = s }))
    const n = ast.getNodeOpt(idx)
    @assert(n != null)
}

test "getNodeOpt null_node" {
    var ast = Ast.init("test.cot")
    const n = ast.getNodeOpt(null_node)
    @assert(n == null)
}

test "getNodeOpt out of bounds" {
    var ast = Ast.init("test.cot")
    const n = ast.getNodeOpt(999)
    @assert(n == null)
}

test "asDecl returns decl" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 0, .end = 10 }
    const idx = ast.addDecl(Decl.import_decl(ImportDecl { .path = "\"foo\"", .span = s }))
    const node = ast.getNode(idx)
    @assert(asDecl(node) != null)
    @assert(asExpr(node) == null)
    @assert(asStmt(node) == null)
}

test "asExpr returns expr" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 0, .end = 5 }
    const idx = ast.addExpr(Expr.ident(Ident { .name = "x", .span = s }))
    const node = ast.getNode(idx)
    @assert(asExpr(node) != null)
    @assert(asDecl(node) == null)
    @assert(asStmt(node) == null)
}

test "asStmt returns stmt" {
    var ast = Ast.init("test.cot")
    const s = Span { .start = 0, .end = 5 }
    const idx = ast.addStmt(Stmt.return_stmt(ReturnStmt { .value = null_node, .span = s }))
    const node = ast.getNode(idx)
    @assert(asStmt(node) != null)
    @assert(asDecl(node) == null)
    @assert(asExpr(node) == null)
}

test "isRange for range loop" {
    const fs = ForStmt {
        .binding = "i",
        .index_binding = "",
        .iterable = null_node,
        .range_start = 0,
        .range_end = 10,
        .body = null_node,
        .is_inline = false,
        .label = "",
        .span = Span { .start = 0, .end = 20 },
    }
    @assert(isRange(fs))
}

test "isRange for iterable loop" {
    const fs = ForStmt {
        .binding = "x",
        .index_binding = "",
        .iterable = 5,
        .range_start = null_node,
        .range_end = null_node,
        .body = null_node,
        .is_inline = false,
        .label = "",
        .span = Span { .start = 0, .end = 20 },
    }
    @assert(!isRange(fs))
}

test "builtinToString roundtrip" {
    @assertEq(builtinToString(@intFromEnum(BuiltinKind.size_of)), "sizeOf")
    @assertEq(builtinToString(@intFromEnum(BuiltinKind.int_cast)), "intCast")
    @assertEq(builtinToString(@intFromEnum(BuiltinKind.assert_eq)), "assertEq")
    @assertEq(builtinToString(@intFromEnum(BuiltinKind.panic)), "panic")
    @assertEq(builtinToString(@intFromEnum(BuiltinKind.@"string")), "string")
    @assertEq(builtinToString(@intFromEnum(BuiltinKind.@"as")), "as")
    @assertEq(builtinToString(@intFromEnum(BuiltinKind.arc_retain)), "arcRetain")
}

test "builtinToString/builtinFromString consistency" {
    // Every builtin should roundtrip: builtinFromString(builtinToString(kind)) == kind
    @assertEq(builtinFromString(builtinToString(0)).?, 0)
    @assertEq(builtinFromString(builtinToString(10)).?, 10)
    @assertEq(builtinFromString(builtinToString(20)).?, 20)
    @assertEq(builtinFromString(builtinToString(30)).?, 30)
    @assertEq(builtinFromString(builtinToString(40)).?, 40)
    @assertEq(builtinFromString(builtinToString(50)).?, 50)
    @assertEq(builtinFromString(builtinToString(53)).?, 53)
}
