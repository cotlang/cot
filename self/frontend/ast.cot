/// Abstract Syntax Tree node definitions.
/// Ported from compiler/frontend/ast.zig
///
/// Nodes are stored in parallel arrays (Zig AST flat-encoding pattern).
/// Each node has a tag (NodeTag), and its data fields are packed
/// sequentially in the `data` array starting at `offsets[node_idx]`.
/// String data lives in a separate `strings` array, referenced by index.
/// This cache-friendly layout matches Zig's own std.zig.Ast design.

import "std/list"

// ============================================================================
// Constants and basic types
// ============================================================================

const null_node: int = 0xFFFFFFFF

/// Half-open byte range [start, end) in source text.
struct Span {
    start: int,
    end: int,
}

/// Struct memory layout strategy.
const StructLayout = enum { auto, @"packed", @"extern" }

/// Literal value categories.
const LiteralKind = enum {
    @"int", @"float", @"string", char,
    true_lit, false_lit, null_lit, undefined_lit, unreachable_lit,
}

// ============================================================================
// NodeTag — identifies node kind and determines data layout
// ============================================================================
//
// Data layout for each tag is documented in brackets.
// _s = string index into strings array
// _n = node index
// Variable-length lists: [count, elem0, elem1, ...]
// All nodes end with [span_start, span_end].

const NodeTag = enum {
    // === Declarations ===
    fn_decl,          // [name_s, ret_type_n, body_n, is_extern, is_async, doc_s, params_count, ...param_nodes, tp_count, ...tp_strings, span_s, span_e]
    var_decl,         // [name_s, type_expr_n, value_n, is_const, doc_s, span_s, span_e]
    struct_decl,      // [name_s, layout, doc_s, fields_count, ...field_nodes, tp_count, ...tp_strings, nested_count, ...nested_nodes, span_s, span_e]
    enum_decl,        // [name_s, backing_type_n, doc_s, variants_count, ...variant_nodes, span_s, span_e]
    union_decl,       // [name_s, doc_s, variants_count, ...variant_nodes, span_s, span_e]
    type_alias,       // [name_s, target_n, doc_s, span_s, span_e]
    import_decl,      // [path_s, span_s, span_e]
    impl_block,       // [type_name_s, doc_s, methods_count, ...method_nodes, tp_count, ...tp_strings, span_s, span_e]
    trait_decl,       // [name_s, doc_s, methods_count, ...method_nodes, span_s, span_e]
    impl_trait,       // [trait_name_s, target_type_s, doc_s, methods_count, ...method_nodes, tp_count, ...tp_strings, span_s, span_e]
    error_set_decl,   // [name_s, doc_s, variants_count, ...variant_strings, span_s, span_e]
    test_decl,        // [name_s, body_n, span_s, span_e]
    bench_decl,       // [name_s, body_n, span_s, span_e]
    bad_decl,         // [span_s, span_e]

    // === Expressions ===
    ident,            // [name_s, span_s, span_e]
    literal,          // [kind, value_s, span_s, span_e]
    binary,           // [op, left_n, right_n, span_s, span_e]
    unary,            // [op, operand_n, span_s, span_e]
    call,             // [callee_n, args_count, ...arg_nodes, span_s, span_e]
    index_expr,       // [base_n, idx_n, span_s, span_e]
    slice_expr,       // [base_n, start_n, end_n, span_s, span_e]
    field_access,     // [base_n, field_s, span_s, span_e]
    array_literal,    // [elems_count, ...elem_nodes, span_s, span_e]
    paren,            // [inner_n, span_s, span_e]
    if_expr,          // [cond_n, then_n, else_n, capture_s, span_s, span_e]
    switch_expr,      // [subject_n, else_body_n, cases_count, ...case_nodes, span_s, span_e]
    switch_case,      // [capture_s, guard_n, is_range, body_n, patterns_count, ...pattern_nodes, span_s, span_e]
    block_expr,       // [result_expr_n, stmts_count, ...stmt_nodes, span_s, span_e]
    struct_init,      // [type_name_s, fi_count, ...fi_nodes, ta_count, ...ta_nodes, span_s, span_e]
    new_expr,         // [type_name_s, is_ctor, fi_count, ...fi_nodes, ta_count, ...ta_nodes, ca_count, ...ca_nodes, span_s, span_e]
    builtin_call,     // [kind, type_arg_n, args_count, ...arg_nodes, span_s, span_e]
    string_interp,    // [segments_count, ...segment_nodes, span_s, span_e]
    type_expr,        // [kind, data1, data2, span_s, span_e]
    try_expr,         // [operand_n, span_s, span_e]
    await_expr,       // [operand_n, span_s, span_e]
    catch_expr,       // [operand_n, capture_s, fallback_n, span_s, span_e]
    error_literal,    // [name_s, span_s, span_e]
    closure_expr,     // [ret_type_n, body_n, params_count, ...param_nodes, span_s, span_e]
    tuple_literal,    // [elems_count, ...elem_nodes, span_s, span_e]
    comptime_block,   // [body_n, span_s, span_e]
    zero_init,        // [span_s, span_e]
    addr_of,          // [operand_n, span_s, span_e]
    deref,            // [operand_n, span_s, span_e]
    generic_instance, // [name_s, ta_count, ...ta_nodes, span_s, span_e]
    bad_expr,         // [span_s, span_e]

    // === Auxiliary (sub-nodes referenced by declarations/expressions) ===
    field_def,        // [name_s, type_expr_n, default_val_n, doc_s, span_s, span_e]
    field_init_node,  // [name_s, value_n, span_s, span_e]
    enum_variant,     // [name_s, value_n, span_s, span_e]
    union_variant,    // [name_s, type_expr_n, span_s, span_e]
    destructure_bind, // [name_s, type_expr_n, span_s, span_e]

    // === Statements ===
    expr_stmt,        // [expr_n, span_s, span_e]
    return_stmt,      // [value_n, span_s, span_e]
    var_stmt,         // [name_s, type_expr_n, value_n, is_const, is_weak, span_s, span_e]
    assign_stmt,      // [target_n, op, value_n, span_s, span_e]
    if_stmt,          // [cond_n, then_n, else_n, capture_s, span_s, span_e]
    while_stmt,       // [cond_n, body_n, capture_s, cont_expr_n, label_s, span_s, span_e]
    for_stmt,         // [binding_s, index_s, iterable_n, range_start_n, range_end_n, body_n, is_inline, label_s, span_s, span_e]
    block_stmt,       // [stmts_count, ...stmt_nodes, span_s, span_e]
    break_stmt,       // [label_s, span_s, span_e]
    continue_stmt,    // [label_s, span_s, span_e]
    defer_stmt,       // [expr_n, is_errdefer, span_s, span_e]
    destructure_stmt, // [value_n, is_const, bindings_count, ...binding_nodes, span_s, span_e]
    bad_stmt,         // [span_s, span_e]
}

// ============================================================================
// AST container — flat-encoded node storage
// ============================================================================

/// AST container: nodes stored as parallel arrays.
struct Ast {
    tags: List(int),
    offsets: List(int),
    data: List(int),
    strings: List(string),
    file_decls: List(int),
    filename: string,
    safe_mode: bool,
}

impl Ast {
    /// Create a new empty AST for a file.
    static fn init(filename: string) Ast {
        var tags: List(int) = undefined
        tags.items = 0
        tags.count = 0
        tags.capacity = 0
        var offsets: List(int) = undefined
        offsets.items = 0
        offsets.count = 0
        offsets.capacity = 0
        var data_list: List(int) = undefined
        data_list.items = 0
        data_list.count = 0
        data_list.capacity = 0
        var strings: List(string) = undefined
        strings.items = 0
        strings.count = 0
        strings.capacity = 0
        var file_decls: List(int) = undefined
        file_decls.items = 0
        file_decls.count = 0
        file_decls.capacity = 0
        return Ast {
            tags: tags,
            offsets: offsets,
            data: data_list,
            strings: strings,
            file_decls: file_decls,
            filename: filename,
            safe_mode: false,
        }
    }

    // ---- Core methods ----

    /// Start a new node. Returns node index. Call addData() to append fields.
    fn addNode(tag: int) int {
        const idx = self.tags.count
        self.tags.append(tag)
        self.offsets.append(self.data.count)
        return idx
    }

    /// Append an int data field to the current node being built.
    fn addData(val: int) void {
        self.data.append(val)
    }

    /// Store a string and return its index.
    fn addStr(s: string) int {
        const idx = self.strings.count
        self.strings.append(s)
        return idx
    }

    /// Append a top-level declaration index.
    fn addFileDecl(idx: int) void {
        self.file_decls.append(idx)
    }

    /// Number of nodes.
    fn nodeCount() int {
        return self.tags.count
    }

    /// Get the tag of node at idx.
    fn getTag(idx: int) int {
        return self.tags.get(idx)
    }

    /// Get the Nth data field of node at idx.
    fn getData(idx: int, field: int) int {
        return self.data.get(self.offsets.get(idx) + field)
    }

    /// Get a string by its index.
    fn getStr(idx: int) string {
        return self.strings.get(idx)
    }

    // ---- Typed add helpers: Expressions ----

    fn addIdent(name: string, s: Span) int {
        const str_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.ident))
        self.addData(str_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addLiteral(kind: int, value: string, s: Span) int {
        const str_idx = self.addStr(value)
        const idx = self.addNode(@intFromEnum(NodeTag.literal))
        self.addData(kind)
        self.addData(str_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addBinary(op: int, left: int, right: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.binary))
        self.addData(op)
        self.addData(left)
        self.addData(right)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addUnary(op: int, operand: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.unary))
        self.addData(op)
        self.addData(operand)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addCallNode(callee: int, args: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.call))
        self.addData(callee)
        self.addData(args.count)
        for i in 0..args.count {
            self.addData(args.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addIndexExpr(base: int, index: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.index_expr))
        self.addData(base)
        self.addData(index)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addSliceExpr(base: int, start: int, end: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.slice_expr))
        self.addData(base)
        self.addData(start)
        self.addData(end)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addFieldAccess(base: int, field: string, s: Span) int {
        const str_idx = self.addStr(field)
        const idx = self.addNode(@intFromEnum(NodeTag.field_access))
        self.addData(base)
        self.addData(str_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addArrayLit(elems: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.array_literal))
        self.addData(elems.count)
        for i in 0..elems.count {
            self.addData(elems.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addParen(inner: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.paren))
        self.addData(inner)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addIfExpr(cond: int, then_br: int, else_br: int, capture: string, s: Span) int {
        const cap_idx = self.addStr(capture)
        const idx = self.addNode(@intFromEnum(NodeTag.if_expr))
        self.addData(cond)
        self.addData(then_br)
        self.addData(else_br)
        self.addData(cap_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addSwitchExpr(subject: int, else_body: int, cases: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.switch_expr))
        self.addData(subject)
        self.addData(else_body)
        self.addData(cases.count)
        for i in 0..cases.count {
            self.addData(cases.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addSwitchCase(capture: string, guard: int, is_range: int, body: int, patterns: List(int), s: Span) int {
        const cap_idx = self.addStr(capture)
        const idx = self.addNode(@intFromEnum(NodeTag.switch_case))
        self.addData(cap_idx)
        self.addData(guard)
        self.addData(is_range)
        self.addData(body)
        self.addData(patterns.count)
        for i in 0..patterns.count {
            self.addData(patterns.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addBlockExpr(result_expr: int, stmts: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.block_expr))
        self.addData(result_expr)
        self.addData(stmts.count)
        for i in 0..stmts.count {
            self.addData(stmts.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addStructInit(type_name: string, fields: List(int), type_args: List(int), s: Span) int {
        const str_idx = self.addStr(type_name)
        const idx = self.addNode(@intFromEnum(NodeTag.struct_init))
        self.addData(str_idx)
        self.addData(fields.count)
        for i in 0..fields.count {
            self.addData(fields.get(i))
        }
        self.addData(type_args.count)
        for i in 0..type_args.count {
            self.addData(type_args.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addNewExpr(type_name: string, is_ctor: int, fields: List(int), type_args: List(int), ctor_args: List(int), s: Span) int {
        const str_idx = self.addStr(type_name)
        const idx = self.addNode(@intFromEnum(NodeTag.new_expr))
        self.addData(str_idx)
        self.addData(is_ctor)
        self.addData(fields.count)
        for fi in 0..fields.count {
            self.addData(fields.get(fi))
        }
        self.addData(type_args.count)
        for ti in 0..type_args.count {
            self.addData(type_args.get(ti))
        }
        self.addData(ctor_args.count)
        for ci in 0..ctor_args.count {
            self.addData(ctor_args.get(ci))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addBuiltinCall(kind: int, type_arg: int, args: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.builtin_call))
        self.addData(kind)
        self.addData(type_arg)
        self.addData(args.count)
        for i in 0..args.count {
            self.addData(args.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addStringInterp(segments: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.string_interp))
        self.addData(segments.count)
        for i in 0..segments.count {
            self.addData(segments.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addTypeExpr(kind: int, d1: int, d2: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.type_expr))
        self.addData(kind)
        self.addData(d1)
        self.addData(d2)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addTryExpr(operand: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.try_expr))
        self.addData(operand)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addAwaitExpr(operand: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.await_expr))
        self.addData(operand)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addCatchExpr(operand: int, capture: string, fallback: int, s: Span) int {
        const cap_idx = self.addStr(capture)
        const idx = self.addNode(@intFromEnum(NodeTag.catch_expr))
        self.addData(operand)
        self.addData(cap_idx)
        self.addData(fallback)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addErrorLit(name: string, s: Span) int {
        const str_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.error_literal))
        self.addData(str_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addClosureExpr(ret_type: int, body: int, params: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.closure_expr))
        self.addData(ret_type)
        self.addData(body)
        self.addData(params.count)
        for i in 0..params.count {
            self.addData(params.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addTupleLit(elems: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.tuple_literal))
        self.addData(elems.count)
        for i in 0..elems.count {
            self.addData(elems.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addComptimeBlock(body: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.comptime_block))
        self.addData(body)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addZeroInit(s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.zero_init))
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addAddrOf(operand: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.addr_of))
        self.addData(operand)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addDeref(operand: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.deref))
        self.addData(operand)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addGenericInst(name: string, type_args: List(int), s: Span) int {
        const str_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.generic_instance))
        self.addData(str_idx)
        self.addData(type_args.count)
        for i in 0..type_args.count {
            self.addData(type_args.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addBadExpr(s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.bad_expr))
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    // ---- Typed add helpers: Auxiliary ----

    fn addFieldDef(name: string, type_expr: int, default_val: int, doc: string, s: Span) int {
        const name_idx = self.addStr(name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.field_def))
        self.addData(name_idx)
        self.addData(type_expr)
        self.addData(default_val)
        self.addData(doc_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addFieldInitNode(name: string, value: int, s: Span) int {
        const str_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.field_init_node))
        self.addData(str_idx)
        self.addData(value)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addEnumVariant(name: string, value: int, s: Span) int {
        const str_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.enum_variant))
        self.addData(str_idx)
        self.addData(value)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addUnionVariant(name: string, type_expr: int, s: Span) int {
        const str_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.union_variant))
        self.addData(str_idx)
        self.addData(type_expr)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addDestructureBind(name: string, type_expr: int, s: Span) int {
        const str_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.destructure_bind))
        self.addData(str_idx)
        self.addData(type_expr)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    // ---- Typed add helpers: Declarations ----

    fn addFnDecl(name: string, ret_type: int, body: int, is_extern: int, is_async: int, doc: string, params: List(int), type_params: List(string), type_param_bounds: List(string), s: Span) int {
        const name_idx = self.addStr(name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.fn_decl))
        self.addData(name_idx)
        self.addData(ret_type)
        self.addData(body)
        self.addData(is_extern)
        self.addData(is_async)
        self.addData(doc_idx)
        self.addData(params.count)
        for i in 0..params.count {
            self.addData(params.get(i))
        }
        self.addData(type_params.count)
        for i in 0..type_params.count {
            const tp_str = self.addStr(type_params.get(i))
            self.addData(tp_str)
        }
        // Where clause bounds: one per type param, "" = no bound
        self.addData(type_param_bounds.count)
        for i in 0..type_param_bounds.count {
            const bound_str = self.addStr(type_param_bounds.get(i))
            self.addData(bound_str)
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addVarDecl(name: string, type_expr: int, value: int, is_const: int, doc: string, s: Span) int {
        const name_idx = self.addStr(name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.var_decl))
        self.addData(name_idx)
        self.addData(type_expr)
        self.addData(value)
        self.addData(is_const)
        self.addData(doc_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addStructDecl(name: string, layout: int, doc: string, fields: List(int), type_params: List(string), nested: List(int), s: Span) int {
        const name_idx = self.addStr(name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.struct_decl))
        self.addData(name_idx)
        self.addData(layout)
        self.addData(doc_idx)
        self.addData(fields.count)
        for i in 0..fields.count {
            self.addData(fields.get(i))
        }
        self.addData(type_params.count)
        for i in 0..type_params.count {
            const tp_str = self.addStr(type_params.get(i))
            self.addData(tp_str)
        }
        self.addData(nested.count)
        for i in 0..nested.count {
            self.addData(nested.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addEnumDecl(name: string, backing_type: int, doc: string, variants: List(int), s: Span) int {
        const name_idx = self.addStr(name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.enum_decl))
        self.addData(name_idx)
        self.addData(backing_type)
        self.addData(doc_idx)
        self.addData(variants.count)
        for i in 0..variants.count {
            self.addData(variants.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addUnionDecl(name: string, doc: string, variants: List(int), s: Span) int {
        const name_idx = self.addStr(name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.union_decl))
        self.addData(name_idx)
        self.addData(doc_idx)
        self.addData(variants.count)
        for i in 0..variants.count {
            self.addData(variants.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addTypeAliasDecl(name: string, target: int, doc: string, s: Span) int {
        const name_idx = self.addStr(name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.type_alias))
        self.addData(name_idx)
        self.addData(target)
        self.addData(doc_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addImportDecl(path: string, s: Span) int {
        const str_idx = self.addStr(path)
        const idx = self.addNode(@intFromEnum(NodeTag.import_decl))
        self.addData(str_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addImplBlock(type_name: string, doc: string, methods: List(int), type_params: List(string), s: Span) int {
        const name_idx = self.addStr(type_name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.impl_block))
        self.addData(name_idx)
        self.addData(doc_idx)
        self.addData(methods.count)
        for i in 0..methods.count {
            self.addData(methods.get(i))
        }
        self.addData(type_params.count)
        for i in 0..type_params.count {
            const tp_str = self.addStr(type_params.get(i))
            self.addData(tp_str)
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addTraitDecl(name: string, doc: string, methods: List(int), s: Span) int {
        const name_idx = self.addStr(name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.trait_decl))
        self.addData(name_idx)
        self.addData(doc_idx)
        self.addData(methods.count)
        for i in 0..methods.count {
            self.addData(methods.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addImplTrait(trait_name: string, target_type: string, doc: string, methods: List(int), type_params: List(string), s: Span) int {
        const tn_idx = self.addStr(trait_name)
        const tt_idx = self.addStr(target_type)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.impl_trait))
        self.addData(tn_idx)
        self.addData(tt_idx)
        self.addData(doc_idx)
        self.addData(methods.count)
        for i in 0..methods.count {
            self.addData(methods.get(i))
        }
        self.addData(type_params.count)
        for i in 0..type_params.count {
            const tp_str = self.addStr(type_params.get(i))
            self.addData(tp_str)
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addErrorSetDecl(name: string, doc: string, variants: List(string), s: Span) int {
        const name_idx = self.addStr(name)
        const doc_idx = self.addStr(doc)
        const idx = self.addNode(@intFromEnum(NodeTag.error_set_decl))
        self.addData(name_idx)
        self.addData(doc_idx)
        self.addData(variants.count)
        for i in 0..variants.count {
            const v_str = self.addStr(variants.get(i))
            self.addData(v_str)
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addTestDecl(name: string, body: int, s: Span) int {
        const str_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.test_decl))
        self.addData(str_idx)
        self.addData(body)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addBenchDecl(name: string, body: int, s: Span) int {
        const str_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.bench_decl))
        self.addData(str_idx)
        self.addData(body)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addBadDecl(s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.bad_decl))
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    // ---- Typed add helpers: Statements ----

    fn addExprStmt(expr: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.expr_stmt))
        self.addData(expr)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addReturnStmt(value: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.return_stmt))
        self.addData(value)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addVarStmt(name: string, type_expr: int, value: int, is_const: int, is_weak: int, s: Span) int {
        const name_idx = self.addStr(name)
        const idx = self.addNode(@intFromEnum(NodeTag.var_stmt))
        self.addData(name_idx)
        self.addData(type_expr)
        self.addData(value)
        self.addData(is_const)
        self.addData(is_weak)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addAssignStmt(target: int, op: int, value: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.assign_stmt))
        self.addData(target)
        self.addData(op)
        self.addData(value)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addIfStmt(cond: int, then_br: int, else_br: int, capture: string, s: Span) int {
        const cap_idx = self.addStr(capture)
        const idx = self.addNode(@intFromEnum(NodeTag.if_stmt))
        self.addData(cond)
        self.addData(then_br)
        self.addData(else_br)
        self.addData(cap_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addWhileStmt(cond: int, body: int, capture: string, cont_expr: int, label: string, s: Span) int {
        const cap_idx = self.addStr(capture)
        const lbl_idx = self.addStr(label)
        const idx = self.addNode(@intFromEnum(NodeTag.while_stmt))
        self.addData(cond)
        self.addData(body)
        self.addData(cap_idx)
        self.addData(cont_expr)
        self.addData(lbl_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addForStmt(binding: string, index_binding: string, iterable: int, range_start: int, range_end: int, body: int, is_inline: int, label: string, s: Span) int {
        const bind_idx = self.addStr(binding)
        const ibind_idx = self.addStr(index_binding)
        const lbl_idx = self.addStr(label)
        const idx = self.addNode(@intFromEnum(NodeTag.for_stmt))
        self.addData(bind_idx)
        self.addData(ibind_idx)
        self.addData(iterable)
        self.addData(range_start)
        self.addData(range_end)
        self.addData(body)
        self.addData(is_inline)
        self.addData(lbl_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addBlockStmt(stmts: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.block_stmt))
        self.addData(stmts.count)
        for i in 0..stmts.count {
            self.addData(stmts.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addBreakStmt(label: string, s: Span) int {
        const lbl_idx = self.addStr(label)
        const idx = self.addNode(@intFromEnum(NodeTag.break_stmt))
        self.addData(lbl_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addContinueStmt(label: string, s: Span) int {
        const lbl_idx = self.addStr(label)
        const idx = self.addNode(@intFromEnum(NodeTag.continue_stmt))
        self.addData(lbl_idx)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addDeferStmt(expr: int, is_errdefer: int, s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.defer_stmt))
        self.addData(expr)
        self.addData(is_errdefer)
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addDestructureStmt(value: int, is_const: int, bindings: List(int), s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.destructure_stmt))
        self.addData(value)
        self.addData(is_const)
        self.addData(bindings.count)
        for i in 0..bindings.count {
            self.addData(bindings.get(i))
        }
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }

    fn addBadStmt(s: Span) int {
        const idx = self.addNode(@intFromEnum(NodeTag.bad_stmt))
        self.addData(s.start)
        self.addData(s.end)
        return idx
    }
}

// ============================================================================
// BuiltinKind — compiler intrinsic @builtin variants (v0.3.2)
// ============================================================================

/// Compiler intrinsic builtins (the @-prefixed functions).
const BuiltinKind = enum {
    // Type introspection
    size_of, align_of, enum_len, has_field, type_of, field, offset_of,
    // Comptime reflection
    type_name, enum_name, type_info,
    // Math unary
    abs, ceil, floor, trunc, round,
    // Math binary
    fmin, fmax, min, max,
    // Casts
    int_cast, float_cast, float_from_int, int_from_float,
    ptr_cast, int_to_ptr, ptr_to_int, bit_cast, truncate, @"as",
    align_cast, const_cast,
    // Enum/error/bool conversions
    int_from_enum, enum_from_int, tag_name, error_name, int_from_bool,
    // String construction + decomposition
    @"string", ptr_of, len_of,
    // Bit manipulation
    ctz, clz, pop_count,
    // Assertions
    assert, assertEq,
    // Control
    trap, panic,
    // Comptime
    compile_error, embed_file, target, targetOs, targetArch,
    // ARC management
    arcRetain, arcRelease,
}

/// Look up a builtin name string and return its BuiltinKind index, or null if unknown.
fn builtinFromString(name: string) ?int {
    return switch (name) {
        "sizeOf" => @intFromEnum(BuiltinKind.size_of),
        "alignOf" => @intFromEnum(BuiltinKind.align_of),
        "enumLen" => @intFromEnum(BuiltinKind.enum_len),
        "hasField" => @intFromEnum(BuiltinKind.has_field),
        "TypeOf" => @intFromEnum(BuiltinKind.type_of),
        "field" => @intFromEnum(BuiltinKind.field),
        "offsetOf" => @intFromEnum(BuiltinKind.offset_of),
        "typeName" => @intFromEnum(BuiltinKind.type_name),
        "enumName" => @intFromEnum(BuiltinKind.enum_name),
        "typeInfo" => @intFromEnum(BuiltinKind.type_info),
        "abs" => @intFromEnum(BuiltinKind.abs),
        "ceil" => @intFromEnum(BuiltinKind.ceil),
        "floor" => @intFromEnum(BuiltinKind.floor),
        "trunc" => @intFromEnum(BuiltinKind.trunc),
        "round" => @intFromEnum(BuiltinKind.round),
        "fmin" => @intFromEnum(BuiltinKind.fmin),
        "fmax" => @intFromEnum(BuiltinKind.fmax),
        "min" => @intFromEnum(BuiltinKind.min),
        "max" => @intFromEnum(BuiltinKind.max),
        "intCast" => @intFromEnum(BuiltinKind.int_cast),
        "floatCast" => @intFromEnum(BuiltinKind.float_cast),
        "floatFromInt" => @intFromEnum(BuiltinKind.float_from_int),
        "intFromFloat" => @intFromEnum(BuiltinKind.int_from_float),
        "ptrCast" => @intFromEnum(BuiltinKind.ptr_cast),
        "intToPtr" => @intFromEnum(BuiltinKind.int_to_ptr),
        "ptrToInt" => @intFromEnum(BuiltinKind.ptr_to_int),
        "bitCast" => @intFromEnum(BuiltinKind.bit_cast),
        "truncate" => @intFromEnum(BuiltinKind.truncate),
        "as" => @intFromEnum(BuiltinKind.@"as"),
        "alignCast" => @intFromEnum(BuiltinKind.align_cast),
        "constCast" => @intFromEnum(BuiltinKind.const_cast),
        "intFromEnum" => @intFromEnum(BuiltinKind.int_from_enum),
        "enumFromInt" => @intFromEnum(BuiltinKind.enum_from_int),
        "tagName" => @intFromEnum(BuiltinKind.tag_name),
        "errorName" => @intFromEnum(BuiltinKind.error_name),
        "intFromBool" => @intFromEnum(BuiltinKind.int_from_bool),
        "string" => @intFromEnum(BuiltinKind.@"string"),
        "ptrOf" => @intFromEnum(BuiltinKind.ptr_of),
        "lenOf" => @intFromEnum(BuiltinKind.len_of),
        "ctz" => @intFromEnum(BuiltinKind.ctz),
        "clz" => @intFromEnum(BuiltinKind.clz),
        "popCount" => @intFromEnum(BuiltinKind.pop_count),
        "assert" => @intFromEnum(BuiltinKind.assert),
        "assertEq" => @intFromEnum(BuiltinKind.assertEq),
        "trap" => @intFromEnum(BuiltinKind.trap),
        "panic" => @intFromEnum(BuiltinKind.panic),
        "compileError" => @intFromEnum(BuiltinKind.compile_error),
        "embedFile" => @intFromEnum(BuiltinKind.embed_file),
        "target" => @intFromEnum(BuiltinKind.target),
        "targetOs" => @intFromEnum(BuiltinKind.targetOs),
        "targetArch" => @intFromEnum(BuiltinKind.targetArch),
        "arcRetain" => @intFromEnum(BuiltinKind.arcRetain),
        "arcRelease" => @intFromEnum(BuiltinKind.arcRelease),
        else => null,
    }
}

// ============================================================================
// Tests
// ============================================================================

test "null_node sentinel" {
    @assertEq(null_node, 0xFFFFFFFF)
}

test "span init" {
    const s = Span { start: 5, end: 10 }
    @assertEq(s.start, 5)
    @assertEq(s.end, 10)
}

test "StructLayout enum" {
    @assertEq(@intFromEnum(StructLayout.auto), 0)
    @assertEq(@intFromEnum(StructLayout.@"packed"), 1)
    @assertEq(@intFromEnum(StructLayout.@"extern"), 2)
}

test "LiteralKind enum" {
    @assertEq(@intFromEnum(LiteralKind.@"int"), 0)
    @assertEq(@intFromEnum(LiteralKind.@"float"), 1)
    @assertEq(@intFromEnum(LiteralKind.@"string"), 2)
    @assertEq(@intFromEnum(LiteralKind.char), 3)
    @assertEq(@intFromEnum(LiteralKind.true_lit), 4)
    @assertEq(@intFromEnum(LiteralKind.null_lit), 6)
    @assertEq(@intFromEnum(LiteralKind.unreachable_lit), 8)
}

test "BuiltinKind enum count" {
    @assertEq(@enumLen(BuiltinKind), 53)
}

test "builtinFromString known" {
    @assertEq(builtinFromString("sizeOf").?, @intFromEnum(BuiltinKind.size_of))
    @assertEq(builtinFromString("intCast").?, @intFromEnum(BuiltinKind.int_cast))
    @assertEq(builtinFromString("assertEq").?, @intFromEnum(BuiltinKind.assertEq))
    @assertEq(builtinFromString("typeName").?, @intFromEnum(BuiltinKind.type_name))
    @assertEq(builtinFromString("typeInfo").?, @intFromEnum(BuiltinKind.type_info))
    @assertEq(builtinFromString("panic").?, @intFromEnum(BuiltinKind.panic))
    @assertEq(builtinFromString("arcRetain").?, @intFromEnum(BuiltinKind.arcRetain))
    @assertEq(builtinFromString("arcRelease").?, @intFromEnum(BuiltinKind.arcRelease))
}

test "builtinFromString unknown" {
    @assert(builtinFromString("nonexistent") == null)
    @assert(builtinFromString("") == null)
    @assert(builtinFromString("fd_write") == null)
    @assert(builtinFromString("alloc") == null)
}

test "BuiltinKind quoted identifiers" {
    @assertEq(builtinFromString("string").?, @intFromEnum(BuiltinKind.@"string"))
    @assertEq(builtinFromString("as").?, @intFromEnum(BuiltinKind.@"as"))
}

test "Ast init" {
    var ast = Ast.init("test.cot")
    @assertEq(ast.nodeCount(), 0)
    @assertEq(ast.filename, "test.cot")
    @assertEq(ast.safe_mode, false)
}

test "Ast addIdent" {
    var ast = Ast.init("test.cot")
    const s = Span { start: 5, end: 8 }
    const idx = ast.addIdent("foo", s)
    @assertEq(idx, 0)
    @assertEq(ast.nodeCount(), 1)
    @assertEq(ast.getTag(0), @intFromEnum(NodeTag.ident))
    // data: [name_str_idx, span_start, span_end]
    @assertEq(ast.getStr(ast.getData(0, 0)), "foo")
    @assertEq(ast.getData(0, 1), 5)
    @assertEq(ast.getData(0, 2), 8)
}

test "Ast addBinary" {
    var ast = Ast.init("test.cot")
    const s = Span { start: 0, end: 5 }
    const left = ast.addIdent("a", s)
    const right = ast.addIdent("b", s)
    const bin = ast.addBinary(10, left, right, s)
    @assertEq(ast.nodeCount(), 3)
    @assertEq(ast.getTag(bin), @intFromEnum(NodeTag.binary))
    @assertEq(ast.getData(bin, 0), 10)
    @assertEq(ast.getData(bin, 1), 0)
    @assertEq(ast.getData(bin, 2), 1)
}

test "Ast addCallNode" {
    var ast = Ast.init("test.cot")
    const s = Span { start: 0, end: 10 }
    const callee = ast.addIdent("foo", s)
    const arg0 = ast.addLiteral(0, "1", s)
    const arg1 = ast.addLiteral(0, "2", s)
    var args: List(int) = undefined
    args.items = 0
    args.count = 0
    args.capacity = 0
    args.append(arg0)
    args.append(arg1)
    const call = ast.addCallNode(callee, args, s)
    @assertEq(ast.getTag(call), @intFromEnum(NodeTag.call))
    // data: [callee, args_count, arg0, arg1, span_s, span_e]
    @assertEq(ast.getData(call, 0), callee)
    @assertEq(ast.getData(call, 1), 2)
    @assertEq(ast.getData(call, 2), arg0)
    @assertEq(ast.getData(call, 3), arg1)
}

test "Ast addFnDecl" {
    var ast = Ast.init("test.cot")
    const s = Span { start: 0, end: 20 }
    var params: List(int) = undefined
    params.items = 0
    params.count = 0
    params.capacity = 0
    var tp: List(string) = undefined
    tp.items = 0
    tp.count = 0
    tp.capacity = 0
    var tpb: List(string) = undefined
    tpb.items = 0
    tpb.count = 0
    tpb.capacity = 0
    const fn_idx = ast.addFnDecl("main", null_node, null_node, 0, 0, "", params, tp, tpb, s)
    @assertEq(ast.getTag(fn_idx), @intFromEnum(NodeTag.fn_decl))
    @assertEq(ast.getStr(ast.getData(fn_idx, 0)), "main")
}

test "Ast addImportDecl" {
    var ast = Ast.init("test.cot")
    const s = Span { start: 0, end: 15 }
    const idx = ast.addImportDecl("std/list", s)
    @assertEq(ast.getTag(idx), @intFromEnum(NodeTag.import_decl))
    @assertEq(ast.getStr(ast.getData(idx, 0)), "std/list")
    @assertEq(ast.getData(idx, 1), 0)
    @assertEq(ast.getData(idx, 2), 15)
}

test "Ast addBlockStmt" {
    var ast = Ast.init("test.cot")
    const s = Span { start: 0, end: 10 }
    const s0 = ast.addReturnStmt(null_node, s)
    const s1 = ast.addExprStmt(0, s)
    var stmts: List(int) = undefined
    stmts.items = 0
    stmts.count = 0
    stmts.capacity = 0
    stmts.append(s0)
    stmts.append(s1)
    const blk = ast.addBlockStmt(stmts, s)
    @assertEq(ast.getTag(blk), @intFromEnum(NodeTag.block_stmt))
    @assertEq(ast.getData(blk, 0), 2)
    @assertEq(ast.getData(blk, 1), s0)
    @assertEq(ast.getData(blk, 2), s1)
}

test "Ast file_decls" {
    var ast = Ast.init("main.cot")
    const s = Span { start: 0, end: 10 }
    const imp = ast.addImportDecl("std/list", s)
    const test_n = ast.addTestDecl("basic", null_node, s)
    ast.file_decls.append(imp)
    ast.file_decls.append(test_n)
    @assertEq(ast.file_decls.count, 2)
    @assertEq(ast.file_decls.get(0), imp)
    @assertEq(ast.file_decls.get(1), test_n)
}
