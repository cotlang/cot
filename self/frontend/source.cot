/// Source text handling and position tracking.
/// Ported from compiler/frontend/source.zig

import "std/list"
import "std/string"

/// Byte offset into source text.
struct Pos {
    offset: int,

    /// Zero position (offset 0).
    static fn zero() Pos {
        return Pos { offset: 0 }
    }

    /// Return a new Pos advanced by n bytes.
    fn advance(n: int) Pos {
        return Pos { offset: self.offset + n }
    }
}

/// Human-readable source position for error messages (1-based line/column).
struct Position {
    filename: string,
    offset: int,
    line: int,
    column: int,

    /// Format as "filename:line:column".
    fn toString() string {
        return "${self.filename}:${self.line}:${self.column}"
    }
}

/// Half-open byte range [start, end) in source text.
/// This is THE canonical Span type â€” imported by ast.cot, errors.cot, etc.
struct Span {
    start: int,
    end: int,

    /// Zero span (offset 0, length 0).
    static fn zero() Span {
        return Span { start: 0, end: 0 }
    }

    /// Create a span from start to end offsets.
    static fn init(start: int, end: int) Span {
        return Span { start: start, end: end }
    }

    /// Create a zero-length span at a single offset.
    static fn fromPos(offset: int) Span {
        return Span { start: offset, end: offset }
    }

    /// Merge two spans into the smallest span containing both.
    fn merge(other: Span) Span {
        var s = self.start
        if (other.start < s) {
            s = other.start
        }
        var e = self.end
        if (other.end > e) {
            e = other.end
        }
        return Span { start: s, end: e }
    }

    /// Number of bytes in this span.
    fn len() int {
        return self.end - self.start
    }
}

/// A source file: filename + content + lazy line offset tracking.
struct Source {
    filename: string,
    content: string,
    line_offsets: List(int),
    line_offsets_computed: bool,

    /// Create a source with filename and content.
    static fn init(filename: string, content: string) Source {
        var offsets: List(int) = .{}
        return Source {
            filename: filename,
            content: content,
            line_offsets: offsets,
            line_offsets_computed: false,
        }
    }

    /// Free the line_offsets list. Call when done with this source.
    fn deinit() void {
        self.line_offsets.clearAndFree()
    }

    /// Return the byte at offset, or null if past end.
    fn at(offset: int) ?int {
        if (offset >= @lenOf(self.content)) {
            return null
        }
        return charAt(self.content, offset)
    }

    /// Return a substring [start, end) of the source content (bounds-clamped).
    fn slice(start: int, end: int) string {
        var s = start
        var e = end
        const clen = @lenOf(self.content)
        if (s < 0) { s = 0 }
        if (s > clen) { s = clen }
        if (e > clen) { e = clen }
        if (s >= e) { return "" }
        return substring(self.content, s, e)
    }

    /// Return the source text covered by a span.
    fn spanText(s: Span) string {
        return substring(self.content, s.start, s.end)
    }

    /// Compute line offset array (lazy, computed once on first call).
    fn ensureLineOffsets() void {
        if (self.line_offsets_computed) {
            return
        }
        // Line 1 starts at offset 0
        self.line_offsets.append(0)
        var i = 0
        const clen = @lenOf(self.content)
        while (i < clen) {
            if (charAt(self.content, i) == '\n') {
                self.line_offsets.append(i + 1)
            }
            i += 1
        }
        self.line_offsets_computed = true
    }

    /// Return human-readable position (1-based line/column) for an offset.
    fn position(offset: int) Position {
        self.ensureLineOffsets()
        // Binary search for line containing offset
        var line = 0
        var lo = 0
        var hi = self.line_offsets.count
        while (lo < hi) {
            const mid = lo + (hi - lo) / 2
            if (self.line_offsets.get(mid) <= offset) {
                line = mid
                lo = mid + 1
            } else {
                hi = mid
            }
        }
        return Position {
            filename: self.filename,
            offset: offset,
            line: line + 1,
            column: offset - self.line_offsets.get(line) + 1,
        }
    }

    /// Return the full source line containing the given offset.
    fn getLine(offset: int) string {
        self.ensureLineOffsets()
        const pos = self.position(offset)
        const start = self.line_offsets.get(pos.line - 1)
        var end = start
        const clen = @lenOf(self.content)
        while (end < clen) {
            if (charAt(self.content, end) == '\n') {
                break
            }
            end += 1
        }
        return substring(self.content, start, end)
    }

    /// Return the number of lines in the source.
    fn lineCount() int {
        self.ensureLineOffsets()
        return self.line_offsets.count
    }
}

// ============================================================================
// Tests
// ============================================================================

test "pos advance" {
    var p = Pos { offset: 5 }
    const p2 = p.advance(3)
    @assertEq(p2.offset, 8)
}

test "position struct" {
    const pos = Position { filename: "test.cot", offset: 10, line: 2, column: 5 }
    @assertEq(pos.line, 2)
    @assertEq(pos.column, 5)
    @assertEq(pos.filename, "test.cot")
}

test "span init" {
    const s = Span.init(5, 10)
    @assertEq(s.start, 5)
    @assertEq(s.end, 10)
}

test "span from pos" {
    const s = Span.fromPos(7)
    @assertEq(s.start, 7)
    @assertEq(s.end, 7)
}

test "span len" {
    var s = Span.init(5, 10)
    @assertEq(s.len(), 5)
}

test "span merge" {
    var a = Span.init(5, 10)
    const b = Span.init(8, 15)
    const merged = a.merge(b)
    @assertEq(merged.start, 5)
    @assertEq(merged.end, 15)
}

test "span merge reversed" {
    var a = Span.init(8, 15)
    const b = Span.init(5, 10)
    const merged = a.merge(b)
    @assertEq(merged.start, 5)
    @assertEq(merged.end, 15)
}

test "source at" {
    var src = Source.init("test.cot", "abc")
    const a = src.at(0)
    @assertEq(a.?, 97)
    const b = src.at(1)
    @assertEq(b.?, 98)
    const c = src.at(2)
    @assertEq(c.?, 99)
}

test "source at past end" {
    var src = Source.init("test.cot", "abc")
    const result = src.at(3)
    @assert(result == null)
}

test "source slice" {
    var src = Source.init("test.cot", "hello world")
    const s = src.slice(0, 5)
    @assertEq(s, "hello")
    const s2 = src.slice(6, 11)
    @assertEq(s2, "world")
}

test "source spanText" {
    var src = Source.init("test.cot", "hello world")
    const text = src.spanText(Span.init(0, 5))
    @assertEq(text, "hello")
}

test "source position first char" {
    var src = Source.init("test.cot", "fn main() {\n    return 0\n}")
    const pos = src.position(0)
    @assertEq(pos.line, 1)
    @assertEq(pos.column, 1)
}

test "source position second line" {
    var src = Source.init("test.cot", "fn main() {\n    return 0\n}")
    const pos = src.position(16)
    @assertEq(pos.line, 2)
    @assertEq(pos.column, 5)
}

test "source getLine" {
    var src = Source.init("test.cot", "line one\nline two\nline three")
    @assertEq(src.getLine(0), "line one")
    @assertEq(src.getLine(10), "line two")
}

test "source lineCount" {
    var src = Source.init("test.cot", "line 1\nline 2\nline 3")
    @assertEq(src.lineCount(), 3)
}

test "pos zero" {
    const p = Pos.zero()
    @assertEq(p.offset, 0)
}

test "span zero" {
    const s = Span.zero()
    @assertEq(s.start, 0)
    @assertEq(s.end, 0)
}

test "position toString" {
    var pos = Position { filename: "main.cot", offset: 0, line: 3, column: 7 }
    @assertEq(pos.toString(), "main.cot:3:7")
}

test "source slice bounds clamping" {
    var src = Source.init("test.cot", "hello")
    @assertEq(src.slice(0, 100), "hello")
    @assertEq(src.slice(-5, 3), "hel")
    @assertEq(src.slice(10, 20), "")
    @assertEq(src.slice(3, 2), "")
}
