/// Self-hosted Cot compiler CLI.
/// Usage: cot <command> <file.cot>
///
/// Commands:
///   parse <file>  — Parse and report syntax errors
///   check <file>  — Type-check and report errors
///   lex <file>    — Tokenize and print tokens
///   help          — Print usage

import "std/os"
import "std/fs"
import "std/sys"
import "std/string"
import "std/path"
import "std/map"
import "std/debug"
import "frontend/token"
import "frontend/scanner"
import "frontend/source"
import "frontend/ast"
import "frontend/errors"
import "frontend/parser"
import "frontend/types"
import "frontend/checker"
import "frontend/ir"

fn main() void {
    if (argsCount() < 2) {
        printUsage()
        exit(1)
    }

    const cmd = arg(1)

    if (cmd == "help" or cmd == "--help" or cmd == "-h") {
        printUsage()
        return
    }

    if (cmd == "version" or cmd == "--version") {
        writeOut("cot 0.3.3 (self-hosted)\n")
        return
    }

    if (argsCount() < 3) {
        writeErr("error: missing file argument\n")
        printUsage()
        exit(1)
    }

    const path = arg(2)
    const content = readFile(path) catch {
        writeErr("error: cannot read file: ${path}\n")
        exit(1)
    }

    switch (cmd) {
        "parse" => cmdParse(path, content),
        "check" => cmdCheck(path, content),
        "lex" => cmdLex(path, content),
        else => {
            writeErr("error: unknown command: ${cmd}\n")
            printUsage()
            exit(1)
        },
    }
}

/// Parse a file and report syntax errors.
fn cmdParse(path: string, content: string) void {
    var errs = ErrorReporter.initWithSource(path, content)
    var s = Scanner.initWithErrors(content, &errs)
    var ast = Ast.init(path)
    var p = Parser.init(s, ast, errs)
    p.parseFile()

    if (errs.hasErrors()) {
        // Errors already printed by ErrorReporter.printErr during parsing
        exit(1)
    }

    writeOut("${path}: ok (${ast.file_decls.len()} declarations)\n")
}

/// Type-check a file and all its imports.
/// Port of driver.zig compileFile phases 1+2: recursive parse, shared check.
fn cmdCheck(path: string, content: string) void {
    // Single-file fast path: parse and check directly (no import resolution)
    var errs = ErrorReporter.initWithSource(path, content)
    var s = Scanner.initWithErrors(content, &errs)
    var ast = Ast.init(path)
    var p = Parser.init(s, ast, errs)
    p.parseFile()

    if (errs.hasErrors()) {
        exit(1)
    }

    // Check if file has imports — use multi-file path
    var imports = ast.getImports()
    if (imports.count > 0) {
        cmdCheckMultiFile(path)
        return
    }

    // No imports — single-file check
    var types = TypeRegistry.init()
    var checker = Checker.init(ast, types, errs)
    checker.checkFile()

    if (errs.hasErrors()) {
        exit(1)
    }

    writeOut("${path}: ok\n")
}

/// Multi-file check: recursively parse and check all imports.
fn cmdCheckMultiFile(path: string) void {
    var seen: Map(string, int) = .{}
    var in_progress: Map(string, int) = .{}

    var types = TypeRegistry.init()
    var shared = SharedCheckerState.init()
    const project_safe = isProjectSafe(path)

    checkFileRecursive(path, &shared, &types, &seen, &in_progress, project_safe)

    writeOut("${path}: ok\n")
}

/// Recursively parse and type-check a file and all its imports.
/// Dependencies are checked first (depth-first), matching driver.zig pattern.
fn checkFileRecursive(file_path: string, shared: *SharedCheckerState, types: *TypeRegistry, seen: *Map(string, int), in_progress: *Map(string, int), project_safe: bool) void {
    // Circular import detection (must check BEFORE seen)
    if (in_progress.getOrDefault(file_path, 0) == 1) {
        println("error: circular import detected: ${file_path}")
        exit(1)
    }

    // Already processed
    if (seen.has(file_path) != 0) { return }

    // Mark as seen and in-progress
    seen.set(file_path, 1)
    in_progress.set(file_path, 1)

    const content = readFile(file_path) catch {
        println("error: cannot read file: ${file_path}")
        exit(1)
    }

    // Parse — heap-allocate Ast so pointer survives after function returns
    // (GenericInfo stores ast_ptr for cross-file generic resolution)
    var errs = ErrorReporter.initWithSource(file_path, content)
    var s = Scanner.initWithErrors(content, &errs)
    var ast = Ast.initHeap(file_path)
    var p = Parser.init(s, ast, errs)
    if (project_safe) { p.safe_mode = true }
    p.parseFile()
    ast.safe_mode = p.safe_mode

    if (errs.hasErrors()) {
        exit(1)
    }

    // Recurse into imports (dependencies checked first)
    var imports = ast.getImports()
    const source_dir = dirname(file_path)
    for i in 0..imports.count {
        const resolved = resolveImportPath(imports.get(i), source_dir)
        checkFileRecursive(resolved, shared, types, seen, in_progress, project_safe)
    }

    // Done with this file's imports — unmark in-progress
    in_progress.set(file_path, 0)

    // Type check with shared state (all dependencies already checked)
    var check_errs = ErrorReporter.initWithSource(file_path, content)
    var checker = Checker.initShared(ast, types, check_errs, shared.global_map)
    checker.loadSharedState(shared)
    checker.checkFile()
    checker.syncToShared(shared)

    if (check_errs.hasErrors()) {
        exit(1)
    }
}

/// Resolve an import path to a file path.
fn resolveImportPath(import_str: string, source_dir: string) string {
    if (startsWith(import_str, "std/")) {
        return resolveStdImport(import_str, source_dir)
    }
    // Relative import: source_dir + import_str + ".cot"
    return join(source_dir, import_str ++ ".cot")
}

/// Resolve stdlib import: "std/list" → "<stdlib_dir>/list.cot"
/// Port of driver.zig resolveStdImport: walk up looking for stdlib/.
fn resolveStdImport(import_path: string, source_dir: string) string {
    const module = substring(import_path, 4, @lenOf(import_path))
    const filename = module ++ ".cot"

    // Walk up from source directory looking for stdlib/
    var dir = source_dir
    while (@lenOf(dir) > 0) {
        const candidate = join3(dir, "stdlib", filename)
        if (fileExists(candidate)) {
            return candidate
        }
        const parent = dirname(dir)
        if (parent == dir) { break }
        dir = parent
    }

    // Fallback: stdlib/ from CWD
    return join("stdlib", filename)
}

/// Check if file is in a @safe project (cot.json has "safe": true).
fn isProjectSafe(file_path: string) bool {
    var dir = dirname(file_path)
    while (@lenOf(dir) > 0) {
        const candidate = join(dir, "cot.json")
        if (fileExists(candidate)) {
            const content = readFile(candidate) catch { return false }
            if (contains(content, "\"safe\": true") or contains(content, "\"safe\":true")) {
                return true
            }
            return false
        }
        const parent = dirname(dir)
        if (parent == dir) { return false }
        dir = parent
    }
    return false
}

/// Tokenize a file and print each token.
fn cmdLex(path: string, content: string) void {
    var s = Scanner.init(content)
    while (true) {
        const t = s.scanNext()
        const tok = @as(Token, @enumFromInt(t.tok))
        const name = tok.toString()
        if (@lenOf(t.text) > 0) {
            writeOut("${name} \"${t.text}\"\n")
        } else {
            writeOut("${name}\n")
        }
        if (tok == Token.eof) { break }
    }
}

fn printUsage() void {
    writeErr("Cot 0.3 (self-hosted)\n")
    writeErr("\n")
    writeErr("Usage: cot <command> <file.cot>\n")
    writeErr("\n")
    writeErr("Commands:\n")
    writeErr("  parse <file>    Parse and report syntax errors\n")
    writeErr("  check <file>    Type-check and report errors\n")
    writeErr("  lex <file>      Tokenize and print tokens\n")
    writeErr("  version         Print version\n")
    writeErr("  help            Print this help\n")
}

/// Write to stdout.
fn writeOut(msg: string) void {
    fd_write(1, @ptrOf(msg), @lenOf(msg))
}

/// Write to stderr.
fn writeErr(msg: string) void {
    fd_write(2, @ptrOf(msg), @lenOf(msg))
}

// ============================================================================
// Tests
// ============================================================================

test "ir builder integration" {
    // Exercise IR builder with real types from types.cot and spans from source.cot
    var builder = Builder.init()
    const span = Span.zero()

    builder.startFunc("main", 0, INT, span)
    if (builder.func()) |fb| {
        fb.emitConstInt(42, INT, span)
        fb.emitRet(null_node, span)
    }
    builder.endFunc()
    builder.addGlobal(Global.init("counter", INT, false, span))

    const ir = builder.getIR()
    @assertEq(ir.funcs.count, 1)
    @assert(ir.getFunc("main") != null)
    @assertEq(ir.globals.count, 1)
    @assert(ir.getGlobal("counter") != null)

    // Verify basic function structure (first 7 fields are accessible)
    const f = ir.funcs.get(0)
    @assertEq(f.name, "main")
    @assertEq(f.return_type, INT)
    @assertEq(f.params.count, 0)
    @assertEq(f.locals.count, 0)
    @assertEq(f.blocks.count, 1)
    @assertEq(f.entry, 0)
    // NOTE: f.nodes.count is inaccessible in multi-file context due to a
    // large struct return value bug (field offset 112+ corrupted). The same
    // operations work in ir.cot's standalone tests. Track separately.
}

test "ir builder with blocks and branches" {
    // Test block/branch creation via FuncBuilder directly (not through Builder)
    // because Builder.func() returns ?FuncBuilder by VALUE — optional capture
    // |fb| creates a copy, so mutations (newBlock, emit) are lost when
    // endFunc() builds from the original self.current_func.
    var fb = FuncBuilder.init("branch_test", 0, INT, Span.zero())
    const cond = fb.emitConstBool(true, Span.zero())
    const then_block = fb.newBlock("then")
    const else_block = fb.newBlock("else")
    fb.emitBranch(cond, then_block, else_block, Span.zero())

    fb.setBlock(then_block)
    const v1 = fb.emitConstInt(1, INT, Span.zero())
    fb.emitRet(v1, Span.zero())

    fb.setBlock(else_block)
    const v2 = fb.emitConstInt(2, INT, Span.zero())
    fb.emitRet(v2, Span.zero())

    const f = fb.build()
    @assertEq(f.name, "branch_test")
    @assertEq(f.blocks.count, 3)
}

test "ir scope management integration" {
    var builder = Builder.init()
    const span = Span.zero()

    builder.startFunc("scope_test", 0, INT, span)
    if (builder.func()) |fb| {
        fb.addLocalWithSize("x", INT, true, 8)
        @assertEq(fb.lookupLocal("x").?, 0)

        const scope = fb.markScopeEntry()
        fb.addLocalWithSize("x", INT, true, 8)
        @assertEq(fb.lookupLocal("x").?, 1)

        fb.restoreScope(scope)
        @assertEq(fb.lookupLocal("x").?, 0)
    }
    builder.endFunc()
}

test "parse valid source" {
    var s = Scanner.init("const x = 42")
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), false)
    @assertEq(ast.file_decls.len(), 1)
}

test "parse reports errors" {
    var s = Scanner.init("fn { }")
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), true)
}


