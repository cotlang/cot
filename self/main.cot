/// Self-hosted Cot compiler CLI.
/// Usage: cot <command> <file.cot>
///
/// Commands:
///   parse <file>  — Parse and report syntax errors
///   check <file>  — Type-check and report errors
///   lex <file>    — Tokenize and print tokens
///   help          — Print usage

import "std/os"
import "std/fs"
import "std/sys"
import "std/string"
import "frontend/token"
import "frontend/scanner"
import "frontend/ast"
import "frontend/errors"
import "frontend/parser"
import "frontend/types"
import "frontend/checker"

fn main() void {
    if (argsCount() < 2) {
        printUsage()
        exit(1)
    }

    const cmd = arg(1)

    if (cmd == "help" or cmd == "--help" or cmd == "-h") {
        printUsage()
        return
    }

    if (cmd == "version" or cmd == "--version") {
        writeOut("cot 0.3.2 (self-hosted)\n")
        return
    }

    if (argsCount() < 3) {
        writeErr("error: missing file argument\n")
        printUsage()
        exit(1)
    }

    const path = arg(2)
    const content = readFile(path) catch {
        writeErr("error: cannot read file: ${path}\n")
        exit(1)
    }

    switch (cmd) {
        "parse" => cmdParse(path, content),
        "check" => cmdCheck(path, content),
        "lex" => cmdLex(path, content),
        else => {
            writeErr("error: unknown command: ${cmd}\n")
            printUsage()
            exit(1)
        },
    }
}

/// Parse a file and report syntax errors.
fn cmdParse(path: string, content: string) void {
    var s = Scanner.init(content)
    var ast = Ast.init(path)
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()

    if (errs.hasErrors()) {
        const diag = Diagnostic { offset: errs.first_offset, code: errs.first_code, msg: errs.first_msg }
        writeErr("${formatDiagnostic(path, content, diag)}\n")
        if (errs.errorCount() > 1) {
            writeErr("... and ${errs.errorCount() - 1} more error(s)\n")
        }
        exit(1)
    }

    writeOut("${path}: ok (${ast.file_decls.len()} declarations)\n")
}

/// Type-check a file and report errors.
fn cmdCheck(path: string, content: string) void {
    var s = Scanner.init(content)
    var ast = Ast.init(path)
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()

    if (errs.hasErrors()) {
        const diag = Diagnostic { offset: errs.first_offset, code: errs.first_code, msg: errs.first_msg }
        writeErr("${formatDiagnostic(path, content, diag)}\n")
        exit(1)
    }

    var types = TypeRegistry.init()
    var checker = Checker.init(ast, types, errs)
    checker.checkFile()

    if (errs.hasErrors()) {
        const diag = Diagnostic { offset: errs.first_offset, code: errs.first_code, msg: errs.first_msg }
        writeErr("${formatDiagnostic(path, content, diag)}\n")
        if (errs.errorCount() > 1) {
            writeErr("... and ${errs.errorCount() - 1} more error(s)\n")
        }
        exit(1)
    }

    writeOut("${path}: ok\n")
}

/// Tokenize a file and print each token.
fn cmdLex(path: string, content: string) void {
    var s = Scanner.init(content)
    while (true) {
        const t = s.scanNext()
        const tok = @as(Token, @enumFromInt(t.tok))
        const name = tok.toString()
        if (@lenOf(t.text) > 0) {
            writeOut("${name} \"${t.text}\"\n")
        } else {
            writeOut("${name}\n")
        }
        if (tok == Token.eof) { break }
    }
}

fn printUsage() void {
    writeErr("Cot 0.3 (self-hosted)\n")
    writeErr("\n")
    writeErr("Usage: cot <command> <file.cot>\n")
    writeErr("\n")
    writeErr("Commands:\n")
    writeErr("  parse <file>    Parse and report syntax errors\n")
    writeErr("  check <file>    Type-check and report errors\n")
    writeErr("  lex <file>      Tokenize and print tokens\n")
    writeErr("  version         Print version\n")
    writeErr("  help            Print this help\n")
}

/// Write to stdout.
fn writeOut(msg: string) void {
    fd_write(1, @ptrOf(msg), @lenOf(msg))
}

/// Write to stderr.
fn writeErr(msg: string) void {
    fd_write(2, @ptrOf(msg), @lenOf(msg))
}

// ============================================================================
// Tests
// ============================================================================

test "parse valid source" {
    var s = Scanner.init("const x = 42")
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), false)
    @assertEq(ast.file_decls.len(), 1)
}

test "parse reports errors" {
    var s = Scanner.init("fn { }")
    var ast = Ast.init("test.cot")
    var errs = ErrorReporter.init()
    var p = Parser.init(s, ast, errs)
    p.parseFile()
    @assertEq(errs.hasErrors(), true)
}


