// token â€” Token definitions for the self-hosted compiler.
// Ported from compiler/frontend/token.zig

import "std/string_map"

const Token = enum {
    // Special
    illegal, eof, comment, doc_comment,

    // Literals (literal_beg..literal_end)
    literal_beg,
    ident, int_lit, float_lit, string_lit,
    string_interp_start, string_interp_mid, string_interp_end,
    char_lit,
    literal_end,

    // Operators (operator_beg..operator_end)
    operator_beg,
    add, sub, mul, quo, rem,
    bit_and, bit_or, xor, shl, shr, bit_not,
    add_assign, sub_assign, mul_assign, quo_assign, rem_assign,
    and_assign, or_assign, xor_assign,
    eql, neq, lss, leq, gtr, geq,
    land, lor, lnot,
    assign, arrow, fat_arrow, optional_chain,
    lparen, rparen, lbrack, rbrack, lbrace, rbrace,
    comma, period, period_period, period_star, period_question,
    semicolon, colon, at, question,
    operator_end,

    // Keywords (keyword_beg..keyword_end)
    keyword_beg,
    kw_fn, kw_var, kw_let, kw_const, kw_struct, kw_impl, kw_trait, kw_where,
    kw_enum, kw_union, kw_type, kw_import, kw_extern, kw_test, kw_bench,
    kw_if, kw_else, kw_switch, kw_while, kw_for, kw_in,
    kw_return, kw_break, kw_continue, kw_defer, kw_errdefer, kw_try, kw_catch, kw_orelse, kw_error,
    kw_true, kw_false, kw_null, kw_new, kw_undefined,
    kw_comptime,
    kw_async, kw_await,
    kw_inline,
    kw_unreachable,
    kw_packed,
    kw_weak,
    kw_and, kw_or, kw_not,
    kw_int, kw_float, kw_bool, kw_string, kw_byte, kw_void, kw_noreturn,
    kw_i8, kw_i16, kw_i32, kw_i64, kw_u8, kw_u16, kw_u32, kw_u64, kw_f32, kw_f64,
    keyword_end,
}

impl Token {
    fn toString(self: Token) string {
        return switch (self) {
            .illegal => "ILLEGAL",
            .eof => "EOF",
            .comment => "COMMENT",
            .doc_comment => "DOC_COMMENT",
            .ident => "IDENT",
            .int_lit => "INT",
            .float_lit => "FLOAT",
            .string_lit => "STRING",
            .char_lit => "CHAR",
            .add => "+",
            .sub => "-",
            .mul => "*",
            .quo => "/",
            .rem => "%",
            .bit_and => "&",
            .bit_or => "|",
            .xor => "^",
            .shl => "<<",
            .shr => ">>",
            .bit_not => "~",
            .add_assign => "+=",
            .sub_assign => "-=",
            .mul_assign => "*=",
            .quo_assign => "/=",
            .rem_assign => "%=",
            .and_assign => "&=",
            .or_assign => "|=",
            .xor_assign => "^=",
            .eql => "==",
            .neq => "!=",
            .lss => "<",
            .leq => "<=",
            .gtr => ">",
            .geq => ">=",
            .land => "&&",
            .lor => "||",
            .lnot => "!",
            .assign => "=",
            .arrow => "->",
            .fat_arrow => "=>",
            .optional_chain => "?.",
            .lparen => "(",
            .rparen => ")",
            .lbrack => "[",
            .rbrack => "]",
            .lbrace => "{",
            .rbrace => "}",
            .comma => ",",
            .period => ".",
            .period_period => "..",
            .period_star => ".*",
            .period_question => ".?",
            .semicolon => ";",
            .colon => ":",
            .at => "@",
            .question => "?",
            .kw_fn => "fn",
            .kw_var => "var",
            .kw_let => "let",
            .kw_const => "const",
            .kw_struct => "struct",
            .kw_impl => "impl",
            .kw_trait => "trait",
            .kw_where => "where",
            .kw_enum => "enum",
            .kw_union => "union",
            .kw_type => "type",
            .kw_import => "import",
            .kw_extern => "extern",
            .kw_test => "test",
            .kw_bench => "bench",
            .kw_if => "if",
            .kw_else => "else",
            .kw_switch => "switch",
            .kw_while => "while",
            .kw_for => "for",
            .kw_in => "in",
            .kw_return => "return",
            .kw_break => "break",
            .kw_continue => "continue",
            .kw_defer => "defer",
            .kw_errdefer => "errdefer",
            .kw_try => "try",
            .kw_catch => "catch",
            .kw_orelse => "orelse",
            .kw_error => "error",
            .kw_true => "true",
            .kw_false => "false",
            .kw_null => "null",
            .kw_new => "new",
            .kw_undefined => "undefined",
            .kw_comptime => "comptime",
            .kw_async => "async",
            .kw_await => "await",
            .kw_inline => "inline",
            .kw_unreachable => "unreachable",
            .kw_packed => "packed",
            .kw_weak => "weak",
            .kw_and => "and",
            .kw_or => "or",
            .kw_not => "not",
            .kw_int => "int",
            .kw_float => "float",
            .kw_bool => "bool",
            .kw_string => "string",
            .kw_byte => "byte",
            .kw_void => "void",
            .kw_noreturn => "noreturn",
            .kw_i8 => "i8",
            .kw_i16 => "i16",
            .kw_i32 => "i32",
            .kw_i64 => "i64",
            .kw_u8 => "u8",
            .kw_u16 => "u16",
            .kw_u32 => "u32",
            .kw_u64 => "u64",
            .kw_f32 => "f32",
            .kw_f64 => "f64",
            else => "?",
        }
    }

    fn precedence(self: Token) i64 {
        if (self == Token.kw_orelse) { return 1 }
        if (self == Token.lor or self == Token.kw_or) { return 2 }
        if (self == Token.land or self == Token.kw_and) { return 3 }
        if (self == Token.eql or self == Token.neq or self == Token.lss or self == Token.leq or self == Token.gtr or self == Token.geq) { return 4 }
        if (self == Token.add or self == Token.sub or self == Token.bit_or or self == Token.xor) { return 5 }
        if (self == Token.mul or self == Token.quo or self == Token.rem or self == Token.bit_and or self == Token.shl or self == Token.shr) { return 6 }
        return 0
    }

    fn isLiteral(self: Token) bool {
        return self > Token.literal_beg and self < Token.literal_end
    }

    fn isOperator(self: Token) bool {
        return self > Token.operator_beg and self < Token.operator_end
    }

    fn isKeyword(self: Token) bool {
        return self > Token.keyword_beg and self < Token.keyword_end
    }

    fn isAssignment(self: Token) bool {
        if (self == Token.assign) { return true }
        if (self == Token.add_assign) { return true }
        if (self == Token.sub_assign) { return true }
        if (self == Token.mul_assign) { return true }
        if (self == Token.quo_assign) { return true }
        if (self == Token.rem_assign) { return true }
        if (self == Token.and_assign) { return true }
        if (self == Token.or_assign) { return true }
        if (self == Token.xor_assign) { return true }
        return false
    }
}

fn initKeywords() StringMap {
    var m: StringMap = StringMap { .key_ptrs = 0, .key_lens = 0, .values = 0, .states = 0, .count = 0, .capacity = 0 }
    m.set("fn", @intFromEnum(Token.kw_fn))
    m.set("var", @intFromEnum(Token.kw_var))
    m.set("let", @intFromEnum(Token.kw_let))
    m.set("const", @intFromEnum(Token.kw_const))
    m.set("struct", @intFromEnum(Token.kw_struct))
    m.set("impl", @intFromEnum(Token.kw_impl))
    m.set("trait", @intFromEnum(Token.kw_trait))
    m.set("where", @intFromEnum(Token.kw_where))
    m.set("enum", @intFromEnum(Token.kw_enum))
    m.set("union", @intFromEnum(Token.kw_union))
    m.set("type", @intFromEnum(Token.kw_type))
    m.set("import", @intFromEnum(Token.kw_import))
    m.set("extern", @intFromEnum(Token.kw_extern))
    m.set("test", @intFromEnum(Token.kw_test))
    m.set("bench", @intFromEnum(Token.kw_bench))
    m.set("if", @intFromEnum(Token.kw_if))
    m.set("else", @intFromEnum(Token.kw_else))
    m.set("switch", @intFromEnum(Token.kw_switch))
    m.set("while", @intFromEnum(Token.kw_while))
    m.set("for", @intFromEnum(Token.kw_for))
    m.set("in", @intFromEnum(Token.kw_in))
    m.set("return", @intFromEnum(Token.kw_return))
    m.set("break", @intFromEnum(Token.kw_break))
    m.set("continue", @intFromEnum(Token.kw_continue))
    m.set("defer", @intFromEnum(Token.kw_defer))
    m.set("errdefer", @intFromEnum(Token.kw_errdefer))
    m.set("try", @intFromEnum(Token.kw_try))
    m.set("catch", @intFromEnum(Token.kw_catch))
    m.set("orelse", @intFromEnum(Token.kw_orelse))
    m.set("error", @intFromEnum(Token.kw_error))
    m.set("true", @intFromEnum(Token.kw_true))
    m.set("false", @intFromEnum(Token.kw_false))
    m.set("null", @intFromEnum(Token.kw_null))
    m.set("new", @intFromEnum(Token.kw_new))
    m.set("undefined", @intFromEnum(Token.kw_undefined))
    m.set("comptime", @intFromEnum(Token.kw_comptime))
    m.set("async", @intFromEnum(Token.kw_async))
    m.set("await", @intFromEnum(Token.kw_await))
    m.set("inline", @intFromEnum(Token.kw_inline))
    m.set("unreachable", @intFromEnum(Token.kw_unreachable))
    m.set("packed", @intFromEnum(Token.kw_packed))
    m.set("weak", @intFromEnum(Token.kw_weak))
    m.set("and", @intFromEnum(Token.kw_and))
    m.set("or", @intFromEnum(Token.kw_or))
    m.set("not", @intFromEnum(Token.kw_not))
    m.set("int", @intFromEnum(Token.kw_int))
    m.set("float", @intFromEnum(Token.kw_float))
    m.set("bool", @intFromEnum(Token.kw_bool))
    m.set("string", @intFromEnum(Token.kw_string))
    m.set("byte", @intFromEnum(Token.kw_byte))
    m.set("void", @intFromEnum(Token.kw_void))
    m.set("noreturn", @intFromEnum(Token.kw_noreturn))
    m.set("i8", @intFromEnum(Token.kw_i8))
    m.set("i16", @intFromEnum(Token.kw_i16))
    m.set("i32", @intFromEnum(Token.kw_i32))
    m.set("i64", @intFromEnum(Token.kw_i64))
    m.set("u8", @intFromEnum(Token.kw_u8))
    m.set("u16", @intFromEnum(Token.kw_u16))
    m.set("u32", @intFromEnum(Token.kw_u32))
    m.set("u64", @intFromEnum(Token.kw_u64))
    m.set("f32", @intFromEnum(Token.kw_f32))
    m.set("f64", @intFromEnum(Token.kw_f64))
    return m
}

fn lookupKeyword(keywords: *StringMap, name: string) Token {
    return @enumFromInt(Token, keywords.getOrDefault(name, @intFromEnum(Token.ident)))
}

// ============================================================================
// Tests
// ============================================================================

test "token to string" {
    var tok = Token.add
    @assert_eq(tok.toString(), "+")
    @assert_eq(Token.kw_fn.toString(), "fn")
    @assert_eq(Token.eql.toString(), "==")
    @assert_eq(Token.eof.toString(), "EOF")
}

test "keyword lookup" {
    var kw = initKeywords()
    @assert_eq(lookupKeyword(&kw, "fn"), Token.kw_fn)
    @assert_eq(lookupKeyword(&kw, "var"), Token.kw_var)
    @assert_eq(lookupKeyword(&kw, "and"), Token.kw_and)
    @assert_eq(lookupKeyword(&kw, "i64"), Token.kw_i64)
    @assert_eq(lookupKeyword(&kw, "notakeyword"), Token.ident)
    @assert_eq(lookupKeyword(&kw, "main"), Token.ident)
}

test "precedence" {
    @assert_eq(Token.mul.precedence(), 6)
    @assert_eq(Token.add.precedence(), 5)
    @assert_eq(Token.eql.precedence(), 4)
    @assert_eq(Token.kw_and.precedence(), 3)
    @assert_eq(Token.kw_or.precedence(), 2)
    @assert_eq(Token.kw_orelse.precedence(), 1)
    @assert_eq(Token.lparen.precedence(), 0)
}

test "isLiteral" {
    @assert_eq(Token.ident.isLiteral(), true)
    @assert_eq(Token.int_lit.isLiteral(), true)
    @assert_eq(Token.string_lit.isLiteral(), true)
    @assert_eq(Token.add.isLiteral(), false)
    @assert_eq(Token.kw_fn.isLiteral(), false)
}

test "isOperator" {
    @assert_eq(Token.add.isOperator(), true)
    @assert_eq(Token.eql.isOperator(), true)
    @assert_eq(Token.lparen.isOperator(), true)
    @assert_eq(Token.ident.isOperator(), false)
    @assert_eq(Token.kw_fn.isOperator(), false)
}

test "isKeyword" {
    @assert_eq(Token.kw_fn.isKeyword(), true)
    @assert_eq(Token.kw_and.isKeyword(), true)
    @assert_eq(Token.kw_i64.isKeyword(), true)
    @assert_eq(Token.add.isKeyword(), false)
    @assert_eq(Token.ident.isKeyword(), false)
}

test "isAssignment" {
    @assert_eq(Token.assign.isAssignment(), true)
    @assert_eq(Token.add_assign.isAssignment(), true)
    @assert_eq(Token.add.isAssignment(), false)
    @assert_eq(Token.eql.isAssignment(), false)
}

test "string method via switch shorthand" {
    var tok = Token.arrow
    @assert_eq(tok.toString(), "->")
    @assert_eq(Token.fat_arrow.toString(), "=>")
    @assert_eq(Token.question.toString(), "?")
}
